<!DOCTYPE html>
<html>
<head>
    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Page Meta -->
    <title>从源代码看 ObjC 中消息的发送</title>
    <meta name="description" content="" />

    <!-- Mobile Meta -->
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- Brand icon -->
    <link rel="shortcut icon" href="/reprinted/assets/images/favicon.ico" >

    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/reprinted/assets/css/screen.css" />
    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400" />
    <link rel="stylesheet" type="text/css" href="/reprinted/assets/css/syntax.css" />

    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/styles/default.min.css">
    <style>.hljs { background: none; }</style>

    <!-- Ghost outputs important style and meta data with this tag -->
        <link rel="canonical" href="/reprinted//message" />
    <meta name="referrer" content="origin" />
    <link rel="next" href="/reprinted/page2/" />

    <meta property="og:site_name" content="" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="从源代码看 ObjC 中消息的发送" />
    <meta property="og:description" content="" />
    <meta property="og:url" content="/reprinted//message" />
    <meta property="og:image" content="/reprinted/assets/images/cover2.jpg" />

    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="从源代码看 ObjC 中消息的发送" />
    <meta name="twitter:description" content="" />
    <meta name="twitter:url" content="/reprinted//message" />
    <meta name="twitter:image:src" content="/reprinted/assets/images/cover2.jpg" />

    <script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "Website",
    "publisher": "",
    "name": "从源代码看 ObjC 中消息的发送",
    "url": "/reprinted//message",
    "image": "/reprinted/assets/images/cover2.jpg",
    "description": ""
}
    </script>

    <meta name="generator" content="Jekyll 3.0.0" />
    <link rel="alternate" type="application/rss+xml" title="" href="/reprinted/feed.xml" />


</head>
<body class="home-template nav-closed">

    <!-- The blog navigation links -->
    <div class="nav">
    <h3 class="nav-title">Menu</h3>
    <a href="#" class="nav-close">
        <span class="hidden">Close</span>
    </a>
    <ul>
        <li class="nav-home " role="presentation"><a href="/reprinted/">Home</a></li>
        <li class="nav-about " role="presentation"><a href="/reprinted/about">About</a></li>
        <li class="nav-ios " role="presentation"><a href="/reprinted/tag/ios">iOS</a></li>
        <li class="nav-objective-c " role="presentation"><a href="/reprinted/tag/objective-c">objective-c</a></li>
        <li class="nav-swift " role="presentation"><a href="/reprinted/tag/swift">Swift</a></li>
        <li class="nav-others " role="presentation"><a href="/reprinted/tag/others">others</a></li>
    </ul>
    <a class="subscribe-button icon-feed" href="/reprinted/feed.xml">Subscribe</a>
</div>
<span class="nav-cover"></span>


    <div class="site-wrapper">

        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- default -->

<!-- The comment above "< default" means - insert everything in this file into -->
    <!-- the [body] of the default.hbs template, which contains our header/footer. -->

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<header class="main-header post-head " style="background-image: url(/reprinted/assets/images/cover2.jpg) ">
    <nav class="main-nav  overlay  clearfix">
        <a class="blog-logo" href="/reprinted/"><img src="/reprinted/assets/images/ghost.png" alt="Blog Logo" /></a>
        
            <a class="menu-button icon-menu" href="#"><span class="word">Menu</span></a>
        
    </nav>
</header>

<main class="content" role="main">

    <article class="post tag-fiction">

        <header class="post-header">
            <h1 class="post-title">从源代码看 ObjC 中消息的发送</h1>
            <section class="post-meta">
            <!-- <a href='/reprinted/'></a> -->

            
                
                    <a href='/reprinted/author/Draveness'>Draveness</a>
                
            
            <time class="post-date" datetime="2016-04-25">25 Apr 2016</time>
                <!-- [[tags prefix=" on "]] -->
                
                on
                
                    
                       <a href='/reprinted/tag/iOS'>iOS</a>,
                    
                
                    
                       <a href='/reprinted/tag/OSS'>OSS</a>
                    
                
                
            </section>
        </header>

        <section class="post-content">

            <p>Blog: <a href="http://draveness.me">Draveness</a></p>

<iframe src="http://ghbtns.com/github-btn.html?user=draveness&amp;type=follow&amp;size=large" height="30" width="240" frameborder="0" scrolling="0" style="width:240px; height: 30px;" allowtransparency="true"></iframe>

<p>关注仓库，及时获得更新：<a href="https://github.com/draveness/iOS-Source-Code-Analyze">iOS-Source-Code-Analyze</a></p>

<blockquote>
  <p>因为 ObjC 的 runtime 只能在 Mac OS 下才能编译，所以文章中的代码都是在 Mac OS，也就是 <code class="highlighter-rouge">x86_64</code> 架构下运行的，对于在 arm64 中运行的代码会特别说明。</p>
</blockquote>

<h2 id="写在前面">写在前面</h2>

<p>如果你点开这篇文章，相信你对 Objective-C 比较熟悉，并且有多年使用 Objective-C 编程的经验，这篇文章会假设你知道：</p>

<ol>
  <li>在 Objective-C 中的“方法调用”其实应该叫做消息传递</li>
  <li><code class="highlighter-rouge">[receiver message]</code> 会被翻译为 <code class="highlighter-rouge">objc_msgSend(receiver, @selector(message))</code></li>
  <li>在消息的响应链中<strong>可能</strong>会调用 <code class="highlighter-rouge">- resolveInstanceMethod:</code> 或者 <code class="highlighter-rouge">- forwardInvocation:</code> 等方法</li>
  <li>
    <p>关于选择子 SEL 的知识</p>

    <blockquote>
      <p>如果对于上述的知识不够了解，可以看一下这篇文章 <a href="http://tech.glowing.com/cn/objective-c-runtime/">Objective-C Runtime</a>，但是其中关于 <code class="highlighter-rouge">objc_class</code> 的结构体的代码已经过时了，不过不影响阅读以及理解。</p>
    </blockquote>
  </li>
  <li>方法在内存中存储的位置，<a href="http://draveness.me/method-struct">深入解析 ObjC 中方法的结构</a>
    <blockquote>
      <p>文章中不会刻意区别方法和函数、消息传递和方法调用之间的区别。</p>
    </blockquote>
  </li>
  <li>能翻墙（会有一个 Youtube 的链接）</li>
</ol>

<h2 id="概述">概述</h2>

<p>关于 Objective-C 中的消息传递的文章真的是太多了，而这篇文章又与其它文章有什么不同呢？</p>

<p>由于这个系列的文章都是对 Objective-C 源代码的分析，所以会<strong>从 Objective-C 源代码中分析并合理地推测一些关于消息传递的问题</strong>。</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-25-objc-message-core.png" alt="objc-message-core" /></p>

<h2 id="关于-selector-你需要知道的">关于 @selector() 你需要知道的</h2>

<p>因为在 Objective-C 中，所有的消息传递中的“消息“都会被转换成一个 <code class="highlighter-rouge">selector</code> 作为 <code class="highlighter-rouge">objc_msgSend</code> 函数的参数：</p>

<pre><code class="language-objectivec">[object hello] -&gt; objc_msgSend(object, @selector(hello))
</code></pre>

<p>这里面使用 <code class="highlighter-rouge">@selector(hello)</code> 生成的选择子 <strong>SEL</strong> 是这一节中关注的重点。</p>

<p>我们需要预先解决的问题是：使用 <code class="highlighter-rouge">@selector(hello)</code> 生成的选择子，是否会因为类的不同而不同？各位读者可以自己思考一下。</p>

<p>先放出结论：使用 <code class="highlighter-rouge">@selector()</code> 生成的选择子不会因为类的不同而改变，其内存地址在编译期间就已经确定了。也就是说<strong>向不同的类发送相同的消息时，其生成的选择子是完全相同的</strong>。</p>

<pre><code class="language-objectivec">XXObject *xx = [[XXObject alloc] init]
YYObject *yy = [[YYObject alloc] init]
objc_msgSend(xx, @selector(hello))
objc_msgSend(yy, @selector(hello))
</code></pre>

<p>接下来，我们开始验证这一结论的正确性，这是程序主要包含的代码：</p>

<pre><code class="language-objectivec">// XXObject.h
#import &lt;Foundation/Foundation.h&gt;

@interface XXObject : NSObject

- (void)hello;

@end

// XXObject.m
#import "XXObject.h"

@implementation XXObject

- (void)hello {
    NSLog(@"Hello");
}

@end
// main.m
#import &lt;Foundation/Foundation.h&gt;
#import "XXObject.h"

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        XXObject *object = [[XXObject alloc] init];
        [object hello];
    }
    return 0;
}
</code></pre>

<p>在主函数任意位置打一个断点， 比如 <code class="highlighter-rouge">-&gt; [object hello];</code> 这里，然后在 lldb 中输入：</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-25-objc-message-selector.png" alt="objc-message-selecto" /></p>

<p>这里面我们打印了两个选择子的地址<code class="highlighter-rouge"> @selector(hello)</code> 以及 <code class="highlighter-rouge">@selector(undefined_hello_method)</code>，需要注意的是：</p>

<blockquote>
  <p><code class="highlighter-rouge">@selector(hello)</code> 是在编译期间就声明的选择子，而后者在编译期间并不存在，<code class="highlighter-rouge">undefined_hello_method</code> 选择子由于是在运行时生成的，所以内存地址明显比 <code class="highlighter-rouge">hello</code> 大很多</p>
</blockquote>

<p>如果我们修改程序的代码：</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-25-objc-message-selector-undefined.png" alt="objc-message-selector-undefined" /></p>

<p>在这里，由于我们在代码中显示地写出了 <code class="highlighter-rouge">@selector(undefined_hello_method)</code>，所以在 lldb 中再次打印这个 <code class="highlighter-rouge">sel</code> 内存地址跟之前相比有了很大的改变。</p>

<p>更重要的是，我没有通过指针的操作来获取 <code class="highlighter-rouge">hello</code> 选择子的内存地址，而只是通过 <code class="highlighter-rouge">@selector(hello)</code> 就可以返回一个选择子。</p>

<p>从上面的这些现象，可以推断出选择子有以下的特性：</p>

<ol>
  <li>Objective-C 为我们维护了一个巨大的选择子表</li>
  <li>在使用 <code class="highlighter-rouge">@selector()</code> 时会从这个选择子表中根据选择子的名字查找对应的 <code class="highlighter-rouge">SEL</code>。如果没有找到，则会生成一个 <code class="highlighter-rouge">SEL</code> 并添加到表中</li>
  <li>在编译期间会扫描全部的头文件和实现文件将其中的方法以及使用 <code class="highlighter-rouge">@selector()</code> 生成的选择子加入到选择子表中</li>
</ol>

<p>在运行时初始化之前，打印 <code class="highlighter-rouge">hello</code> 选择子的的内存地址：</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-25-objc-message-find-selector-before-init.png" alt="objc-message-find-selector-before-init" /></p>

<h2 id="messageh-文件">message.h 文件</h2>

<p>Objective-C 中 <code class="highlighter-rouge">objc_msgSend</code> 的实现并没有开源，它只存在于 <code class="highlighter-rouge">message.h</code> 这个头文件中。</p>

<pre><code class="language-objectivec">/**
 * @note When it encounters a method call, the compiler generates a call to one of the
 *  functions \c objc_msgSend, \c objc_msgSend_stret, \c objc_msgSendSuper, or \c objc_msgSendSuper_stret.
 *  Messages sent to an object’s superclass (using the \c super keyword) are sent using \c objc_msgSendSuper;
 *  other messages are sent using \c objc_msgSend. Methods that have data structures as return values
 *  are sent using \c objc_msgSendSuper_stret and \c objc_msgSend_stret.
 */
OBJC_EXPORT id objc_msgSend(id self, SEL op, ...)
</code></pre>

<p>在这个头文件的注释中对<strong>消息发送的一系列方法</strong>解释得非常清楚：</p>

<blockquote>
  <p>当编译器遇到一个方法调用时，它会将方法的调用翻译成以下函数中的一个 <code class="highlighter-rouge">objc_msgSend</code>、<code class="highlighter-rouge">objc_msgSend_stret</code>、<code class="highlighter-rouge">objc_msgSendSuper</code> 和 <code class="highlighter-rouge">objc_msgSendSuper_stret</code>。
发送给对象的父类的消息会使用 <code class="highlighter-rouge">objc_msgSendSuper</code>
有数据结构作为返回值的方法会使用 <code class="highlighter-rouge">objc_msgSendSuper_stret</code> 或 <code class="highlighter-rouge">objc_msgSend_stret</code>
其它的消息都是使用 <code class="highlighter-rouge">objc_msgSend</code> 发送的</p>
</blockquote>

<p>在这篇文章中，我们只会对<strong>消息发送的过程</strong>进行分析，而不会对<strong>上述消息发送方法的区别</strong>进行分析，默认都使用 <code class="highlighter-rouge">objc_msgSend</code> 函数。</p>

<h2 id="objc_msgsend-调用栈">objc_msgSend 调用栈</h2>

<p>这一小节会以向 <code class="highlighter-rouge">XXObject</code> 的实例发送 <code class="highlighter-rouge">hello</code> 消息为例，在 Xcode 中观察整个消息发送的过程中调用栈的变化，再来看一下程序的代码：</p>

<pre><code class="language-objectivec">// XXObject.h
#import &lt;Foundation/Foundation.h&gt;

@interface XXObject : NSObject

- (void)hello;

@end

// XXObject.m
#import "XXObject.h"

@implementation XXObject

- (void)hello {
    NSLog(@"Hello");
}

@end
// main.m
#import &lt;Foundation/Foundation.h&gt;
#import "XXObject.h"

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        XXObject *object = [[XXObject alloc] init];
        [object hello];
    }
    return 0;
}
</code></pre>

<p>在调用 <code class="highlighter-rouge">hello</code> 方法的这一行打一个断点，当我们尝试进入（Step in）这个方法只会直接跳入这个方法的实现，而不会进入 <code class="highlighter-rouge">objc_msgSend</code>：</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-25-objc-message-wrong-step-in.gif" alt="objc-message-wrong-step-in" /></p>

<p>因为 <code class="highlighter-rouge">objc_msgSend</code> 是一个私有方法，我们没有办法进入它的实现，但是，我们却可以在 <code class="highlighter-rouge">objc_msgSend</code> 的调用栈中“截下”这个函数调用的过程。</p>

<p>调用 <code class="highlighter-rouge">objc_msgSend</code> 时，传入了 <code class="highlighter-rouge">self</code> 以及 <code class="highlighter-rouge">SEL</code> 参数。</p>

<p>既然要执行对应的方法，肯定要寻找选择子对应的实现。</p>

<p>在 <code class="highlighter-rouge">objc-runtime-new.mm</code> 文件中有一个函数 <code class="highlighter-rouge">lookUpImpOrForward</code>，这个函数的作用就是查找方法的实现，于是运行程序，在运行到 <code class="highlighter-rouge">hello</code> 这一行时，激活 <code class="highlighter-rouge">lookUpImpOrForward</code> 函数中的断点。</p>

<p><a href="https://youtu.be/bCdjdI4VhwQ" target="_blank"><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-25-objc-message-youtube-preview.jpg" /></a></p>

<blockquote>
  <p>由于转成 gif 实在是太大了，笔者试着用各种方法生成动图，然而效果也不是很理想，只能贴一个 Youtube 的视频链接，不过对于能够翻墙的开发者们，应该也不是什么问题吧（手动微笑）</p>
</blockquote>

<p>如果跟着视频看这个方法的调用栈有些混乱的话，也是正常的。在下一个节中会对其调用栈进行详细的分析。</p>

<h1 id="解析-objc_msgsend">解析 objc_msgSend</h1>

<p>对 <code class="highlighter-rouge">objc_msgSend</code> 解析总共分两个步骤，我们会向 <code class="highlighter-rouge">XXObject</code> 的实例发送两次 <code class="highlighter-rouge">hello</code> 消息，分别模拟无缓存和有缓存两种情况下的调用栈。</p>

<h2 id="无缓存">无缓存</h2>

<p>在 <code class="highlighter-rouge">-&gt; [object hello]</code> 这里增加一个断点，<strong>当程序运行到这一行时</strong>，再向 <code class="highlighter-rouge">lookUpImpOrForward</code> 函数的第一行添加断点，确保是捕获 <code class="highlighter-rouge">@selector(hello)</code> 的调用栈，而不是调用其它选择子的调用栈。</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-25-objc-message-first-call-hello.png" alt="objc-message-first-call-hello" /></p>

<p>由图中的变量区域可以了解，传入的选择子为 <code class="highlighter-rouge">"hello"</code>，对应的类是 <code class="highlighter-rouge">XXObject</code>。所以我们可以确信这就是当调用 <code class="highlighter-rouge">hello</code> 方法时执行的函数。在 Xcode 左侧能看到方法的调用栈：</p>

<pre><code class="language-objectivec">0 lookUpImpOrForward
1 _class_lookupMethodAndLoadCache3
2 objc_msgSend
3 main
4 start
</code></pre>

<p>调用栈在这里告诉我们： <code class="highlighter-rouge">lookUpImpOrForward</code> 并不是 <code class="highlighter-rouge">objc_msgSend</code> 直接调用的，而是通过 <code class="highlighter-rouge">_class_lookupMethodAndLoadCache3</code> 方法：</p>

<pre><code class="language-objectivec">IMP _class_lookupMethodAndLoadCache3(id obj, SEL sel, Class cls)
{
    return lookUpImpOrForward(cls, sel, obj,
                              YES/*initialize*/, NO/*cache*/, YES/*resolver*/);
}
</code></pre>

<p>这是一个<strong>仅提供给派发器（dispatcher）</strong>用于方法查找的函数，其它的代码都应该使用 <code class="highlighter-rouge">lookUpImpOrNil()</code>（不会进行方法转发）。<code class="highlighter-rouge">_class_lookupMethodAndLoadCache3</code> 会传入 <code class="highlighter-rouge">cache = NO</code> 避免在<strong>没有加锁</strong>的时候对缓存进行查找，因为派发器已经做过这件事情了。</p>

<h3 id="实现的查找-lookupimporforward">实现的查找 lookUpImpOrForward</h3>

<p>由于实现的查找方法 <code class="highlighter-rouge">lookUpImpOrForward</code> 涉及很多函数的调用，所以我们将它分成以下几个部分来分析：</p>

<ol>
  <li>无锁的缓存查找</li>
  <li>如果类没有实现（isRealized）或者初始化（isInitialized），实现或者初始化类</li>
  <li>加锁</li>
  <li>缓存以及当前类中方法的查找</li>
  <li>尝试查找父类的缓存以及方法列表</li>
  <li>没有找到实现，尝试方法解析器</li>
  <li>进行消息转发</li>
  <li>解锁、返回实现</li>
</ol>

<h4 id="无锁的缓存查找">无锁的缓存查找</h4>

<p>下面是在没有加锁的时候对缓存进行查找，提高缓存使用的性能：</p>

<pre><code class="language-objectivec">runtimeLock.assertUnlocked();

// Optimistic cache lookup
if (cache) {
   imp = cache_getImp(cls, sel);
   if (imp) return imp;
}
</code></pre>

<p>不过因为 <code class="highlighter-rouge">_class_lookupMethodAndLoadCache3</code> 传入的 <code class="highlighter-rouge">cache = NO</code>，所以这里会直接跳过 if 中代码的执行，在 <code class="highlighter-rouge">objc_msgSend</code> 中已经使用汇编代码查找过了。</p>

<h4 id="类的实现和初始化">类的实现和初始化</h4>

<p>在 <em>Objective-C 运行时</em> 初始化的过程中会对其中的类进行第一次初始化也就是执行 <code class="highlighter-rouge">realizeClass</code> 方法，为类分配可读写结构体 <code class="highlighter-rouge">class_rw_t</code> 的空间，并返回正确的类结构体。</p>

<p>而 <code class="highlighter-rouge">_class_initialize</code> 方法会调用类的 <code class="highlighter-rouge">initialize</code> 方法，我会在之后的文章中对类的初始化进行分析。</p>

<pre><code class="language-objectivec">if (!cls-&gt;isRealized()) {
    rwlock_writer_t lock(runtimeLock);
    realizeClass(cls);
}

if (initialize  &amp;&amp;  !cls-&gt;isInitialized()) {
    _class_initialize (_class_getNonMetaClass(cls, inst));
}
</code></pre>

<h4 id="加锁">加锁</h4>

<p>加锁这一部分只有一行简单的代码，其主要目的保证方法查找以及缓存填充（cache-fill）的原子性，保证在运行以下代码时不会有<strong>新方法添加导致缓存被冲洗（flush）</strong>。</p>

<pre><code class="language-objectivec">runtimeLock.read();
</code></pre>

<h4 id="在当前类中查找实现">在当前类中查找实现</h4>

<p>实现很简单，先调用了 <code class="highlighter-rouge">cache_getImp</code> 从某个类的 <code class="highlighter-rouge">cache</code> 属性中获取选择子对应的实现：</p>

<pre><code class="language-objectivec">imp = cache_getImp(cls, sel);
if (imp) goto done;
</code></pre>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-25-objc-message-cache-struct.png" alt="objc-message-cache-struct" /></p>

<p>不过 <code class="highlighter-rouge">cache_getImp</code> 的实现目测是不开源的，同时也是汇编写的，在我们尝试 step in 的时候进入了如下的汇编代码。</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-25-objc-message-step-in-cache-getimp.png" alt="objc-message-step-in-cache-getimp" /></p>

<p>它会进入一个 <code class="highlighter-rouge">CacheLookup</code> 的标签，获取实现，使用汇编的原因还是因为要加速整个实现查找的过程，其原理推测是在类的 <code class="highlighter-rouge">cache</code> 中寻找对应的实现，只是做了一些性能上的优化。</p>

<p>如果查找到实现，就会跳转到 <code class="highlighter-rouge">done</code> 标签，因为我们在这个小结中的假设是无缓存的（第一次调用 <code class="highlighter-rouge">hello</code> 方法），所以会进入下面的代码块，从类的方法列表中寻找方法的实现：</p>

<pre><code class="language-objectivec">meth = getMethodNoSuper_nolock(cls, sel);
if (meth) {
    log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls);
    imp = meth-&gt;imp;
    goto done;
}
</code></pre>

<p>调用 <code class="highlighter-rouge">getMethodNoSuper_nolock</code> 方法查找对应的方法的结构体指针 <code class="highlighter-rouge">method_t</code>：</p>

<pre><code class="language-objectivec">static method_t *getMethodNoSuper_nolock(Class cls, SEL sel) {
    for (auto mlists = cls-&gt;data()-&gt;methods.beginLists(),
              end = cls-&gt;data()-&gt;methods.endLists();
         mlists != end;
         ++mlists)
    {
        method_t *m = search_method_list(*mlists, sel);
        if (m) return m;
    }

    return nil;
}
</code></pre>

<p>因为类中数据的方法列表 <code class="highlighter-rouge">methods</code> 是一个二维数组 <code class="highlighter-rouge">method_array_t</code>，写一个 <code class="highlighter-rouge">for</code> 循环遍历整个方法列表，而这个 <code class="highlighter-rouge">search_method_list</code> 的实现也特别简单：</p>

<pre><code class="language-objectivec">static method_t *search_method_list(const method_list_t *mlist, SEL sel)
{
    int methodListIsFixedUp = mlist-&gt;isFixedUp();
    int methodListHasExpectedSize = mlist-&gt;entsize() == sizeof(method_t);

    if (__builtin_expect(methodListIsFixedUp &amp;&amp; methodListHasExpectedSize, 1)) {
        return findMethodInSortedMethodList(sel, mlist);
    } else {
        for (auto&amp; meth : *mlist) {
            if (meth.name == sel) return &amp;meth;
        }
    }

    return nil;
}
</code></pre>

<p><code class="highlighter-rouge">findMethodInSortedMethodList</code> 方法对有序方法列表进行线性探测，返回方法结构体 <code class="highlighter-rouge">method_t</code>。</p>

<p>如果在这里找到了方法的实现，将它加入类的缓存中，这个操作最后是由 <code class="highlighter-rouge">cache_fill_nolock</code> 方法来完成的：</p>

<pre><code class="language-objectivec">static void cache_fill_nolock(Class cls, SEL sel, IMP imp, id receiver)
{
    if (!cls-&gt;isInitialized()) return;
    if (cache_getImp(cls, sel)) return;

    cache_t *cache = getCache(cls);
    cache_key_t key = getKey(sel);

    mask_t newOccupied = cache-&gt;occupied() + 1;
    mask_t capacity = cache-&gt;capacity();
    if (cache-&gt;isConstantEmptyCache()) {
        cache-&gt;reallocate(capacity, capacity ?: INIT_CACHE_SIZE);
    } else if (newOccupied &lt;= capacity / 4 * 3) {

    } else {
        cache-&gt;expand();
    }

    bucket_t *bucket = cache-&gt;find(key, receiver);
    if (bucket-&gt;key() == 0) cache-&gt;incrementOccupied();
    bucket-&gt;set(key, imp);
}
</code></pre>

<p>如果缓存中的内容大于容量的 <code class="highlighter-rouge">3/4</code> 就会扩充缓存，使缓存的大小翻倍。</p>

<blockquote>
  <p>在缓存翻倍的过程中，当前类<strong>全部的缓存都会被清空</strong>，Objective-C 出于性能的考虑不会将原有缓存的 <code class="highlighter-rouge">bucket_t</code> 拷贝到新初始化的内存中。</p>
</blockquote>

<p>找到第一个空的 <code class="highlighter-rouge">bucket_t</code>，以 <code class="highlighter-rouge">(SEL, IMP)</code> 的形式填充进去。</p>

<h4 id="在父类中寻找实现">在父类中寻找实现</h4>

<p>这一部分与上面的实现基本上是一样的，只是多了一个循环用来判断根类：</p>

<ol>
  <li>查找缓存</li>
  <li>搜索方法列表</li>
</ol>

<pre><code class="language-objectivec">curClass = cls;
while ((curClass = curClass-&gt;superclass)) {
    imp = cache_getImp(curClass, sel);
    if (imp) {
        if (imp != (IMP)_objc_msgForward_impcache) {
            log_and_fill_cache(cls, imp, sel, inst, curClass);
            goto done;
        } else {
            break;
        }
    }

    meth = getMethodNoSuper_nolock(curClass, sel);
    if (meth) {
        log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass);
        imp = meth-&gt;imp;
        goto done;
    }
}
</code></pre>

<p>与当前类寻找实现的区别是：在父类中寻找到的 <code class="highlighter-rouge">_objc_msgForward_impcache</code> 实现会交给当前类来处理。</p>

<h4 id="方法决议">方法决议</h4>

<p>选择子在当前类和父类中都没有找到实现，就进入了方法决议（method resolve）的过程：</p>

<pre><code class="language-objectivec">if (resolver  &amp;&amp;  !triedResolver) {
    _class_resolveMethod(cls, sel, inst);
    triedResolver = YES;
    goto retry;
}
</code></pre>

<p>这部分代码调用 <code class="highlighter-rouge">_class_resolveMethod</code> 来解析没有找到实现的方法。</p>

<pre><code class="language-objectivec">void _class_resolveMethod(Class cls, SEL sel, id inst)
{
    if (! cls-&gt;isMetaClass()) {
        _class_resolveInstanceMethod(cls, sel, inst);
    }
    else {
        _class_resolveClassMethod(cls, sel, inst);
        if (!lookUpImpOrNil(cls, sel, inst,
                            NO/*initialize*/, YES/*cache*/, NO/*resolver*/))
        {
            _class_resolveInstanceMethod(cls, sel, inst);
        }
    }
}
</code></pre>

<p>根据当前的类是不是<a href="http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html">元类</a>在 <code class="highlighter-rouge">_class_resolveInstanceMethod</code> 和 <code class="highlighter-rouge">_class_resolveClassMethod</code> 中选择一个进行调用。</p>

<pre><code class="language-objectivec">static void _class_resolveInstanceMethod(Class cls, SEL sel, id inst) {
    if (! lookUpImpOrNil(cls-&gt;ISA(), SEL_resolveInstanceMethod, cls,
                         NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) {
        // 没有找到 resolveInstanceMethod: 方法，直接返回。
        return;
    }

    BOOL (*msg)(Class, SEL, SEL) = (__typeof__(msg))objc_msgSend;
    bool resolved = msg(cls, SEL_resolveInstanceMethod, sel);

    // 缓存结果，以防止下次在调用 resolveInstanceMethod: 方法影响性能。
    IMP imp = lookUpImpOrNil(cls, sel, inst,
                             NO/*initialize*/, YES/*cache*/, NO/*resolver*/);
}
</code></pre>

<p>这两个方法的实现其实就是判断当前类是否实现了 <code class="highlighter-rouge">resolveInstanceMethod:</code> 或者 <code class="highlighter-rouge">resolveClassMethod:</code> 方法，然后用 <code class="highlighter-rouge">objc_msgSend</code> 执行上述方法，并传入需要决议的选择子。</p>

<blockquote>
  <p>关于 <code class="highlighter-rouge">resolveInstanceMethod</code> 之后可能会写一篇文章专门介绍，不过关于这个方法的文章也确实不少，在 Google 上搜索会有很多的文章。</p>
</blockquote>

<p>在执行了 <code class="highlighter-rouge">resolveInstanceMethod:</code> 之后，会跳转到 retry 标签，<strong>重新执行查找方法实现的流程</strong>，只不过不会再调用 <code class="highlighter-rouge">resolveInstanceMethod:</code> 方法了（将 <code class="highlighter-rouge">triedResolver</code> 标记为 <code class="highlighter-rouge">YES</code>）。</p>

<h4 id="消息转发">消息转发</h4>

<p>在缓存、当前类、父类以及 <code class="highlighter-rouge">resolveInstanceMethod:</code> 都没有解决实现查找的问题时，Objective-C 还为我们提供了最后一次翻身的机会，进行方法转发：</p>

<pre><code class="language-objectivec">imp = (IMP)_objc_msgForward_impcache;
cache_fill(cls, sel, imp, inst);
</code></pre>

<p>返回实现 <code class="highlighter-rouge">_objc_msgForward_impcache</code>，然后加入缓存。</p>

<p>====</p>

<p>这样就结束了整个方法第一次的调用过程，缓存没有命中，但是在当前类的方法列表中找到了 <code class="highlighter-rouge">hello</code> 方法的实现，调用了该方法。</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-25-objc-message-first-call-hello.png" alt="objc-message-first-call-hello" /></p>

<h2 id="缓存命中">缓存命中</h2>

<p>如果使用对应的选择子时，缓存命中了，那么情况就大不相同了，我们修改主程序中的代码：</p>

<pre><code class="language-objectivec">int main(int argc, const char * argv[]) {
    @autoreleasepool {
        XXObject *object = [[XXObject alloc] init];
        [object hello];
        [object hello];
    }
    return 0;
}
</code></pre>

<p>然后在第二次调用 <code class="highlighter-rouge">hello</code> 方法时，加一个断点：</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-25-objc-message-objc-msgSend-with-cache.gif" alt="objc-message-objc-msgSend-with-cache" /></p>

<p><code class="highlighter-rouge">objc_msgSend</code> 并没有走 <code class="highlighter-rouge">lookupImpOrForward</code> 这个方法，而是直接结束，打印了另一个 <code class="highlighter-rouge">hello</code> 字符串。</p>

<p>我们如何确定 <code class="highlighter-rouge">objc_msgSend</code> 的实现到底是什么呢？其实我们没有办法来<strong>确认</strong>它的实现，因为这个函数的实现使用汇编写的，并且实现是不开源的。</p>

<p>不过，我们需要确定它是否真的<strong>访问了类中的缓存</strong>来加速实现寻找的过程。</p>

<p>好，现在重新运行程序至第二个 <code class="highlighter-rouge">hello</code> 方法调用之前：</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-25-objc-message-before-flush-cache.png" alt="objc-message-before-flush-cache" /></p>

<p>打印缓存中 bucket 的内容：</p>

<pre><code class="language-objectivec">(lldb) p (objc_class *)[XXObject class]
(objc_class *) $0 = 0x0000000100001230
(lldb) p (cache_t *)0x0000000100001240
(cache_t *) $1 = 0x0000000100001240
(lldb) p *$1
(cache_t) $2 = {
  _buckets = 0x0000000100604bd0
  _mask = 3
  _occupied = 2
}
(lldb) p $2.capacity()
(mask_t) $3 = 4
(lldb) p $2.buckets()[0]
(bucket_t) $4 = {
  _key = 0
  _imp = 0x0000000000000000
}
(lldb) p $2.buckets()[1]
(bucket_t) $5 = {
  _key = 0
  _imp = 0x0000000000000000
}
(lldb) p $2.buckets()[2]
(bucket_t) $6 = {
  _key = 4294971294
  _imp = 0x0000000100000e60 (debug-objc`-[XXObject hello] at XXObject.m:17)
}
(lldb) p $2.buckets()[3]
(bucket_t) $7 = {
  _key = 4300169955
  _imp = 0x00000001000622e0 (libobjc.A.dylib`-[NSObject init] at NSObject.mm:2216)
}
</code></pre>

<p>在这个缓存中只有对 <code class="highlighter-rouge">hello</code> 和 <code class="highlighter-rouge">init</code> 方法实现的缓存，我们要将其中 <code class="highlighter-rouge">hello</code> 的缓存清空：</p>

<pre><code class="language-objectivec">(lldb) expr $2.buckets()[2] = $2.buckets()[1]
(bucket_t) $8 = {
  _key = 0
  _imp = 0x0000000000000000
}
</code></pre>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-25-objc-message-after-flush-cache.png" alt="objc-message-after-flush-cache" /></p>

<p>这样 <code class="highlighter-rouge">XXObject</code> 中就不存在 <code class="highlighter-rouge">hello</code> 方法对应实现的缓存了。然后继续运行程序：</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-25-objc-message-after-flush-cache-trap-in-lookup-again.png" alt="objc-message-after-flush-cache-trap-in-lookup-again" /></p>

<p>虽然第二次调用 <code class="highlighter-rouge">hello</code> 方法，但是因为我们清除了 <code class="highlighter-rouge">hello</code> 的缓存，所以，会再次进入 <code class="highlighter-rouge">lookupImpOrForward</code> 方法。</p>

<p>下面会换一种方法验证猜测：<strong>在 hello 调用之前添加缓存</strong>。</p>

<p>添加一个新的实现 <code class="highlighter-rouge">cached_imp</code>：</p>

<pre><code class="language-objectivec">#import &lt;Foundation/Foundation.h&gt;
#import &lt;objc/runtime.h&gt;
#import "XXObject.h"

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        __unused IMP cached_imp = imp_implementationWithBlock(^() {
            NSLog(@"Cached Hello");
        });
        XXObject *object = [[XXObject alloc] init];
        [object hello];
        [object hello];
    }
    return 0;
}
</code></pre>

<p>我们将以 <code class="highlighter-rouge">@selector(hello), cached_imp</code> 为键值对，将其添加到类结构体的缓存中，这里的实现 <code class="highlighter-rouge">cached_imp</code> 有一些区别，它会打印 <code class="highlighter-rouge">@"Cached Hello"</code> 而不是 <code class="highlighter-rouge">@"Hello"</code> 字符串：</p>

<p>在第一个 <code class="highlighter-rouge">hello</code> 方法调用之前将实现加入缓存：</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-25-objc-message-add-imp-to-cache.png" alt="objc-message-add-imp-to-cache" /></p>

<p>然后继续运行代码：</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-25-objc-message-run-after-add-cache.png" alt="objc-message-run-after-add-cache" /></p>

<p>可以看到，我们虽然没有改变 <code class="highlighter-rouge">hello</code> 方法的实现，但是在 <strong>objc_msgSend</strong> 的消息发送链路中，使用错误的缓存实现 <code class="highlighter-rouge">cached_imp</code> 拦截了实现的查找，打印出了 <code class="highlighter-rouge">Cached Hello</code>。</p>

<p>由此可以推定，<code class="highlighter-rouge">objc_msgSend</code> 在实现中确实检查了缓存。如果没有缓存会调用 <code class="highlighter-rouge">lookupImpOrForward</code> 进行方法查找。</p>

<p>为了提高消息传递的效率，ObjC 对 <code class="highlighter-rouge">objc_msgSend</code> 以及  <code class="highlighter-rouge">cache_getImp</code> 使用了汇编语言来编写。</p>

<p>如果你想了解有关 <code class="highlighter-rouge">objc_msgSend</code> 方法的汇编实现的信息，可以看这篇文章 <a href="https://www.mikeash.com/pyblog/friday-qa-2012-11-16-lets-build-objc_msgsend.html">Let’s Build objc_msgSend</a></p>

<h2 id="小结">小结</h2>

<p>这篇文章与其说是讲 ObjC 中的消息发送的过程，不如说是讲方法的实现是如何查找的。</p>

<p>Objective-C 中实现查找的路径还是比较符合直觉的：</p>

<ol>
  <li>缓存命中</li>
  <li>查找当前类的缓存及方法</li>
  <li>查找父类的缓存及方法</li>
  <li>方法决议</li>
  <li>消息转发</li>
</ol>

<p>文章中关于方法调用栈的视频最开始是用 gif 做的，不过由于 gif 时间较长，试了很多的 gif 转换器，都没有得到一个较好的质量和合适的大小，所以最后选择用一个 Youtube 的视频。</p>

<h2 id="参考资料">参考资料</h2>

<ul>
  <li><a href="https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/objc/深入解析%20ObjC%20中方法的结构.md">深入解析 ObjC 中方法的结构</a></li>
  <li><a href="http://tech.glowing.com/cn/objective-c-runtime/">Objective-C Runtime</a></li>
  <li><a href="https://www.mikeash.com/pyblog/friday-qa-2012-11-16-lets-build-objc_msgsend.html">Let’s Build objc_msgSend</a></li>
</ul>

<iframe src="http://ghbtns.com/github-btn.html?user=draveness&amp;type=follow&amp;size=large" height="30" width="240" frameborder="0" scrolling="0" style="width:240px; height: 30px;" allowtransparency="true"></iframe>

<blockquote>
  <p>关注仓库，及时获得更新：<a href="https://github.com/draveness/iOS-Source-Code-Analyze">iOS-Source-Code-Analyze</a></p>
</blockquote>

<blockquote>
  <p>Blog: <a href="http://draveness.me">Draveness</a></p>
</blockquote>



        </section>

        <footer class="post-footer">

            <!-- Everything inside the #author tags pulls data from the author -->
            <!-- #author-->
            
                
                    
                        <figure class="author-image">
                            <a class="img" href="/reprinted/author/Draveness" style="background-image: url(/reprinted/assets/images/draven.png)"><span class="hidden">Draveness's Picture</span></a>
                        </figure>
                    

                    <section class="author">
                        <h4><a href="/reprinted/author/Draveness">Draveness</a></h4>

                        
                            <p>Read <a href="/reprinted/author/Draveness">more posts</a> by this author.</p>
                        
                        <div class="author-meta">
                            <span class="author-location icon-location"> Beijing, China</span>
                            <span class="author-link icon-link"><a href="https://draveness.me/index"> draveness.me/index</a></span>
                        </div>
                    </section>

                    <!-- /author  -->

                    <section class="share">
                        <h4>Share this post</h4>
                        <a class="icon-twitter" href="http://twitter.com/share?text=从源代码看 ObjC 中消息的发送&amp;url=message"
                            onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
                            <span class="hidden">Twitter</span>
                        </a>
                        <a class="icon-facebook" href="https://www.facebook.com/sharer/sharer.php?u=message"
                            onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
                            <span class="hidden">Facebook</span>
                        </a>
                        <a class="icon-google-plus" href="https://plus.google.com/share?url=message"
                           onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
                            <span class="hidden">Google+</span>
                        </a>
                    </section>
                
            
            <!-- Add Disqus Comments -->
            

        </footer>

    </article>

</main>
<aside class="read-next">

    <!-- [[! next_post ]] -->
    
    <!-- [[! /next_post ]] -->
    <!-- [[! prev_post ]] -->
    
        <a class="read-next-story prev " style="background-image: url(/reprinted/assets/images/cover2.jpg)" href="/reprinted/method-struct">
            <section class="post">
                <h2>深入解析 ObjC 中方法的结构</h2>
                <p>Blog: Draveness 关注仓库，及时获得更新：iOS-Source-Code-Analyze 因为 ObjC 的 runtime 只能在 Mac OS 下才能编译，所以文章中的代码都是在 Mac OS，也就是 x86_64 架构下运行的，对于在...</p>
            </section>
        </a>
    
    <!-- [[! /prev_post ]] -->
</aside>

<!-- /post -->


        <!-- The tiny footer at the very bottom -->
        <footer class="site-footer clearfix">
          <section class="copyright"><a href="/reprinted/"></a> &copy; 2018</section>
          <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> using <a href="https://github.com/jekyller/jasper">Jasper</a></section>
        </footer>
    </div>
    <!-- highlight.js -->
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <!-- jQuery needs to come before `` so that jQuery can be used in code injection -->
    <script type="text/javascript" src="//code.jquery.com/jquery-1.12.0.min.js"></script>
    <!-- Ghost outputs important scripts and data with this tag -->
    <!--  -->
    <!-- Add Google Analytics  -->
        <!-- Google Analytics Tracking code -->
     <script>
	    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	    ga('create', 'UA-69281367-1', 'auto');
	    ga('send', 'pageview');

     </script>
    <!-- Fitvids makes video embeds responsive and awesome -->
    <script type="text/javascript" src="/reprinted/assets/js/jquery.fitvids.js"></script>
    <!-- The main JavaScript file for Casper -->
    <script type="text/javascript" src="/reprinted/assets/js/index.js"></script>

</body>
</html>
