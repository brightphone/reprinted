<!DOCTYPE html>
<html>
<head>
    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Page Meta -->
    <title>关于一些 iOS 面试问题的解答</title>
    <meta name="description" content="" />

    <!-- Mobile Meta -->
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- Brand icon -->
    <link rel="shortcut icon" href="/reprinted/assets/images/favicon.ico" >

    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/reprinted/assets/css/screen.css" />
    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400" />
    <link rel="stylesheet" type="text/css" href="/reprinted/assets/css/syntax.css" />

    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/styles/default.min.css">
    <style>.hljs { background: none; }</style>

    <!-- Ghost outputs important style and meta data with this tag -->
        <link rel="canonical" href="/reprinted//guan-yu-xie-ios-wen-ti-de-jie-da" />
    <meta name="referrer" content="origin" />
    <link rel="next" href="/reprinted/page2/" />

    <meta property="og:site_name" content="" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="关于一些 iOS 面试问题的解答" />
    <meta property="og:description" content="" />
    <meta property="og:url" content="/reprinted//guan-yu-xie-ios-wen-ti-de-jie-da" />
    <meta property="og:image" content="/reprinted/assets/images/cover2.jpg" />

    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="关于一些 iOS 面试问题的解答" />
    <meta name="twitter:description" content="" />
    <meta name="twitter:url" content="/reprinted//guan-yu-xie-ios-wen-ti-de-jie-da" />
    <meta name="twitter:image:src" content="/reprinted/assets/images/cover2.jpg" />

    <script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "Website",
    "publisher": "",
    "name": "关于一些 iOS 面试问题的解答",
    "url": "/reprinted//guan-yu-xie-ios-wen-ti-de-jie-da",
    "image": "/reprinted/assets/images/cover2.jpg",
    "description": ""
}
    </script>

    <meta name="generator" content="Jekyll 3.0.0" />
    <link rel="alternate" type="application/rss+xml" title="" href="/reprinted/feed.xml" />


</head>
<body class="home-template nav-closed">

    <!-- The blog navigation links -->
    <div class="nav">
    <h3 class="nav-title">Menu</h3>
    <a href="#" class="nav-close">
        <span class="hidden">Close</span>
    </a>
    <ul>
        <li class="nav-home " role="presentation"><a href="/reprinted/">Home</a></li>
        <li class="nav-about " role="presentation"><a href="/reprinted/about">About</a></li>
        <li class="nav-ios  nav-current" role="presentation"><a href="/reprinted/tag/ios">iOS</a></li>
        <li class="nav-objective-c " role="presentation"><a href="/reprinted/tag/objective-c">objective-c</a></li>
        <li class="nav-swift " role="presentation"><a href="/reprinted/tag/swift">Swift</a></li>
        <li class="nav-others " role="presentation"><a href="/reprinted/tag/others">others</a></li>
    </ul>
    <a class="subscribe-button icon-feed" href="/reprinted/feed.xml">Subscribe</a>
</div>
<span class="nav-cover"></span>


    <div class="site-wrapper">

        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- default -->

<!-- The comment above "< default" means - insert everything in this file into -->
    <!-- the [body] of the default.hbs template, which contains our header/footer. -->

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<header class="main-header post-head " style="background-image: url(/reprinted/assets/images/cover2.jpg) ">
    <nav class="main-nav  overlay  clearfix">
        <a class="blog-logo" href="/reprinted/"><img src="/reprinted/assets/images/ghost.png" alt="Blog Logo" /></a>
        
            <a class="menu-button icon-menu" href="#"><span class="word">Menu</span></a>
        
    </nav>
</header>

<main class="content" role="main">

    <article class="post tag-fiction">

        <header class="post-header">
            <h1 class="post-title">关于一些 iOS 面试问题的解答</h1>
            <section class="post-meta">
            <!-- <a href='/reprinted/'></a> -->

            
                
                    <a href='/reprinted/author/Draveness'>Draveness</a>
                
            
            <time class="post-date" datetime="2015-04-26">26 Apr 2015</time>
                <!-- [[tags prefix=" on "]] -->
                
                on
                
                    
                       <a href='/reprinted/tag/iOS'>iOS</a>,
                    
                
                    
                       <a href='/reprinted/tag/OSS'>OSS</a>
                    
                
                
            </section>
        </header>

        <section class="post-content">

            <p>这篇 post 主要是对知乎上 <a href="http://www.zhihu.com/question/19604641">iOS程序员的问题列表</a> 的回答, 也算是对自己已有的知识进行整理.</p>

<p>如果你对本篇 post 中的回答有所疑问, 可以在下面留言. 如果有问题, 我一定会修改的 :-)</p>

<h2 id="问题以及回答">问题以及回答</h2>

<h3 id="1-什么是-arc-arc-是为了解决什么问题而诞生的">1. 什么是 ARC? (ARC 是为了解决什么问题而诞生的?)</h3>

<p>ARC 是 Automatic Reference Counting 的缩写, 即自动引用计数. 这是苹果在 iOS5 中引入的内存管理机制. Objective-C 和 Swift 使用 ARC 追踪和管理应用的内存使用. 这一机制使得开发者无需键入 <code class="highlighter-rouge">retain</code> 和 <code class="highlighter-rouge">release</code>, 这不仅能够降低程序崩溃和内存泄露的风险, 而且可以减少开发者的工作量, 能够大幅度提升程序的<strong>流畅性</strong>和<strong>可预测性</strong>. 但是 ARC 不适用于 Core Foundation 框架中, 仍然需要手动管理内存.</p>

<hr />

<h3 id="2-以下-keywords-有什么区别-assign-vs-weak-__block-vs-__weak">2. 以下 keywords 有什么区别: <code class="highlighter-rouge">assign vs weak</code>, <code class="highlighter-rouge">__block vs __weak</code></h3>

<p><code class="highlighter-rouge">assign</code> 和 <code class="highlighter-rouge">weak</code> 是用于在声明属性时, 为属性指定内存管理的语义.</p>

<ul>
  <li><code class="highlighter-rouge">assign</code> 用于简单的赋值, 不改变属性的引用计数, 用于 Objective-C 中的 <code class="highlighter-rouge">NSInteger</code>, <code class="highlighter-rouge">CGFloat</code> 以及 C 语言中 <code class="highlighter-rouge">int</code>, <code class="highlighter-rouge">float</code>, <code class="highlighter-rouge">double</code> 等数据类型.</li>
  <li><code class="highlighter-rouge">weak</code> 用于对象类型,  由于 <code class="highlighter-rouge">weak</code> 同样不改变对象的引用计数且不持有对象实例, 当该对象废弃时, 该弱引用自动失效并且被赋值为 <code class="highlighter-rouge">nil</code>, 所以它可以用于避免两个强引用产生的<strong>循环引用</strong>导致内存无法释放的问题.</li>
</ul>

<p><code class="highlighter-rouge">__block</code> 和 <code class="highlighter-rouge">__weak</code> 之间的却是确实极大的, 不过它们都用于修饰变量.</p>

<ul>
  <li>前者用于指明当前声明的变量在被 block 捕获之后, 可以在 block 中改变变量的值. 因为在 block 声明的同时会截获该 block 所使用的全部自动变量的值, 而这些值只在 block 中<strong>只具有”使用权”而不具有”修改权”</strong>. 而 <code class="highlighter-rouge">__block</code> 说明符就为 block 提供了变量的修改权.</li>
  <li>后者是<strong>所有权修饰符</strong>, 什么是所有权修饰符? 这里涉及到另一个问题, 因为在 ARC 有效时, id 类型和对象类型同 C 语言中的其他类型不同, 必须附加所有权修饰符. 所有权修饰符一种有 4 种:
    <ul>
      <li>__strong</li>
      <li>__weak</li>
      <li>__unsafe_unretained</li>
      <li>__autorelease</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">__weak</code> 与 <code class="highlighter-rouge">weak</code> 的区别只在于, 前者用于变量的声明, 而后者用于属性的声明.</li>
</ul>

<hr />

<h3 id="3-__block-在-arc-和非-arc-下含义一样吗">3. <code class="highlighter-rouge">__block</code> 在 ARC 和非 ARC 下含义一样吗？</h3>

<p><code class="highlighter-rouge">__block</code> <strong>在 ARC 下捕获的变量会被 block retain</strong>, 这样可能导致循环引用, 所以必须要使用弱引用才能解决该问题. 而在非 ARC 下, 可以直接使用 <code class="highlighter-rouge">__block</code> 说明符修饰变量, 因为在非 ARC 下, block 不会 retain 捕获的变量.</p>

<hr />

<h3 id="4-使用-nonatomic-一定是线程安全的吗">4. 使用 <code class="highlighter-rouge">nonatomic</code> 一定是线程安全的吗？</h3>

<p><code class="highlighter-rouge">nonatomic</code> 的内存管理语义是<strong>非原子</strong>的, 非原子的操作本来就是线程不安全的, 而 <code class="highlighter-rouge">atomic</code> 的操作是原子的, 但是<strong>并不意味着它是线程安全的</strong>, 它会增加正确的几率, 能够更好的避免线程的错误, 但是它仍然是线程不安全的.</p>

<p>当使用 <code class="highlighter-rouge">nonatomic</code> 的时候, 属性的 setter 和 getter 操作是非原子的, 所以当多个线程同时对某一属性进行读和写的操作, 属性的最终结果是不能预测的.</p>

<p>当使用 <code class="highlighter-rouge">atomic</code> 时, 虽然对属性的读和写是原子的, 但是仍然可能出现线程错误: 当线程 A 进行写操作, 这时其他线程的读或写操作会因为该操作的进行而等待. 当 A 线程的写操作结束后, B 线程进行写操作, 然后当 A 线程进行读操作时, 却获得了在 B 线程中的值, 这就破坏了线程安全, 如果有线程 C 在 A 线程读操作前 release 了该属性, 那么还会导致程序崩溃. 所以仅仅使用 <code class="highlighter-rouge">atomic</code> 并不会使得线程安全, 我们还需要为线程添加 <code class="highlighter-rouge">lock</code> 来确保线程的安全.</p>

<p><code class="highlighter-rouge">atomic</code> 都不是一定线程安全的, <code class="highlighter-rouge">nonatomic</code> 就更不必多说了.</p>

<hr />

<h3 id="5-描述一个你遇到过的-retain-cycle-例子">5. <del>描述一个你遇到过的 retain cycle 例子.</del></h3>

<hr />

<h3 id="6--voidload-和--voidinitialize-有什么用处">6. <code class="highlighter-rouge">+ (void)load;</code> 和 <code class="highlighter-rouge">+ (void)initialize;</code> 有什么用处？</h3>

<p>当类对象被引入项目时, runtime 会向每一个类对象发送 <code class="highlighter-rouge">load</code> 消息. <code class="highlighter-rouge">load</code> 方法还是非常的神奇的, 因为它会在<strong>每一个类甚至分类</strong>被引入时仅调用一次, 调用的顺序是父类优先于子类, 子类优先于分类. 而且 <code class="highlighter-rouge">load</code> 方法不会被类自动继承, 每一个类中的 <code class="highlighter-rouge">load</code> 方法都不需要像 <code class="highlighter-rouge">viewDidLoad</code> 方法一样调用父类的方法. 由于 <code class="highlighter-rouge">load</code> 方法会在类被 <code class="highlighter-rouge">import</code> 时调用一次, 而这时往往是改变类的行为的最佳时机. 我在 <a href="https://github.com/Draveness/DKNightVersion">DKNightVersion</a> 中使用 <code class="highlighter-rouge">method swizlling</code> 来修改原有的方法时, 就是在分类 <code class="highlighter-rouge">load</code> 中实现的.</p>

<p><code class="highlighter-rouge">initialize</code> 方法和 <code class="highlighter-rouge">load</code> 方法有一些不同, 它虽然也会在整个 runtime 过程中调用一次, 但是它是在<strong>该类的第一个方法执行之前</strong>调用, 也就是说 <code class="highlighter-rouge">initialize</code> 的调用是<strong>惰性</strong>的, 它的实现也与我们在平时使用的惰性初始化属性时基本相同. 我在实际的项目中并没有遇到过必须使用这个方法的情况, 在该方法中主要做<strong>静态变量的设置</strong>并用于<strong>确保在实例初始化前某些条件必须满足</strong>.</p>

<hr />

<h3 id="7-为什么其他语言里叫函数调用-objective-c-中是给对象发送消息-谈下对-runtime-的理解">7. 为什么其他语言里叫函数调用, Objective-C 中是给对象发送消息 (谈下对 runtime 的理解)</h3>

<p>我们在其他语言中比如说: C, Python, Java, C++, Haskell … 中提到函数调用或者方法调用(面向对象). 函数调用是在编译期就已经决定了会调用哪个函数(方法), 编译器在编译期就能检查出函数的执行是否正确.</p>

<p>然而 Objective-C(ObjC) 是一门动态的语言, 整个 ObjC 语言都是尽可能的将所有的工作推迟到运行时才决定. 它基于 runtime 来工作, runtime 就是 ObjC 的灵魂, 其核心就是消息发送<code class="highlighter-rouge">objc_msgSend </code>.</p>

<blockquote>
  <p>What makes Objective-C truly powerful is its runtime.</p>
</blockquote>

<p>所有的消息都会在运行时才会确定, <code class="highlighter-rouge">[obj message]</code> 在运行时会被转化为 <code class="highlighter-rouge">objc_msgSend(id self, SEL cmd, ...)</code> 来执行, 它会在运行时从<strong>选择子表中寻找对应的选择子</strong>并将选择子与实现进行绑定. 而如果没有找到对应的实现, 就会进入类似黑魔法的消息转发流程. 调用 <code class="highlighter-rouge">+ (BOOL)resolveInstanceMethod:(SEL)aSelector</code> 方法, 我们可以在这个方法中<strong>为类动态地生成方法</strong>.</p>

<p>我们几乎可以使用 runtime 魔改 Objective-C 中的一切: <code class="highlighter-rouge">class</code> <code class="highlighter-rouge">property</code> <code class="highlighter-rouge">object</code> <code class="highlighter-rouge">ivar</code> <code class="highlighter-rouge">method</code> <code class="highlighter-rouge">protocol</code>, 而下面就是它的主要应用:</p>

<ul>
  <li>内省</li>
  <li>为分类动态的添加属性</li>
  <li>使用方法调剂修改原有的方法实现</li>
  <li>…</li>
</ul>

<hr />

<h3 id="8-什么是-method-swizzling">8. 什么是 Method Swizzling?</h3>

<p><code class="highlighter-rouge">method swizzling</code> 实际上就是一种在运行时动态修改原有方法实现的技术, 它实际上是基于 ObjC runtime 的特性, 而 <code class="highlighter-rouge">method swizzling</code> 的核心方法就是 <code class="highlighter-rouge">method_exchangeImplementations(SEL origin, SEL swizzle)</code>. 使用这个方法就可以在运行时动态地改变原有的方法实现, 在 <a href="https://github.com/Draveness/DKNightVersion/blob/master/Pod/Classes/UIKit/Auto/UILabel/UILabel%2BTextColor.m">DKNigtVersion</a>(为 iOS 应用添加夜间模式) 中能够看到大量 <code class="highlighter-rouge">method swizzling</code> 的使用, 方法的调用时机就是在上面提到的 <code class="highlighter-rouge">load</code> 方法中, 不在 <code class="highlighter-rouge">initialize</code> 方法中改变方法实现的原因是 <strong><code class="highlighter-rouge">initialize</code> 可能会被子类所继承并重新执行最终导致无限递归</strong>, 而 <code class="highlighter-rouge">load</code> 并不会被继承.</p>

<hr />

<h3 id="9-uiview-和-calayer-有什么关系">9. <code class="highlighter-rouge">UIView</code> 和 <code class="highlighter-rouge">CALayer</code> 有什么关系?</h3>

<p>看到这个问题不禁想到大一在网易面试时的经历, 当时的两位面试官就问了我这么一个问题, <code class="highlighter-rouge">UIView </code>和 <code class="highlighter-rouge">CALayer</code> 是什么关系, 为什么要这么设计? 我已经忘记了当时是怎么回答的. 隐约记得当时说每一个 <code class="highlighter-rouge">UIView</code> 都会对应一个 <code class="highlighter-rouge">CALayer</code> 至于为什么这样, 当时的我实在是太弱无法回答出来了.</p>

<p>每一个 <code class="highlighter-rouge">UIView</code> 的身后对应一个 <code class="highlighter-rouge">Core Animation</code> 框架中的 <code class="highlighter-rouge">CALayer</code>. 每一个 <code class="highlighter-rouge">UIView</code> 都是 ` CALayer` 的代理.</p>

<blockquote>
  <p>Many of the methods you call on UIView simply delegate to the layer</p>
</blockquote>

<p>在 iOS 上当你处理一个又一个的 <code class="highlighter-rouge">UIView</code> 时, 实际上是在操作 <code class="highlighter-rouge">CALayer</code>. 尽管有的时候你并不知道 (直接操作 <code class="highlighter-rouge">CALayer</code> 并不会对效率有着显著的提升).</p>

<p><code class="highlighter-rouge">UIView</code> 实际上就是对 <code class="highlighter-rouge">CALayer</code> 的轻量级的封装. <code class="highlighter-rouge">UIView</code> 继承自 <code class="highlighter-rouge">UIResponder</code>, 用来处理来自用户的事件; <code class="highlighter-rouge">CALayer</code> 继承自 <code class="highlighter-rouge">NSObject</code> 主要用于处理图层的渲染和动画. 这么设计有以下几个原因:</p>

<ul>
  <li>你可以通过操作 <code class="highlighter-rouge">UIView</code> 在一个更高的层级上处理与用户的交互, 触摸, 点击, 拖拽等事件, 这些都是在 <code class="highlighter-rouge">UIKit</code> 这个层级上完成的.</li>
  <li><code class="highlighter-rouge">UIView</code> 和 <code class="highlighter-rouge">NSView(AppKit)</code> 的实现极其不同, 而使用 <code class="highlighter-rouge">Core Animation</code> 可以实现底层代码地重用, 在 Mac 和 iOS 平台上都使用着近乎相同的 <code class="highlighter-rouge">Core Animation</code> 代码, 这样我们可以对这个层级进行抽象在两种平台上产生 <code class="highlighter-rouge">UIKit</code> 和 <code class="highlighter-rouge">AppKit</code> 用于不同平台的框架.</li>
</ul>

<p>使用 <code class="highlighter-rouge">CALayer</code> 的唯一原因大概是便于移植到不同的平台, 如果仅仅使用 <code class="highlighter-rouge">Core Animation</code> 层级进行开发, 处理用户的交互时间需要写更多的代码.</p>

<hr />

<h3 id="10-如何高性能的给-uiimageview-加个圆角-不准说-layercornerradius">10. 如何高性能的给 <code class="highlighter-rouge">UIImageView</code> 加个圆角? (不准说 <code class="highlighter-rouge">layer.cornerRadius</code>!)</h3>

<p>一般情况下给 UIImageView 或者说 UIKit 的控件添加圆角都是改变 <code class="highlighter-rouge">clipsToBounds</code> 和 <code class="highlighter-rouge">layer.cornerRadius</code>, 这样大约两行代码就可以解决这个问题. 但是, 这样使用这样的方法会<strong>强制 Core Animation 提前渲染屏幕的离屏绘制</strong>, 而离屏绘制就会为性能带来负面影响.</p>

<p>我们也可以使用另一种比较复杂的方式来为图片添加圆角, 这里就用到了贝塞尔曲线.</p>

<pre><code class="language-objectivec">UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, 100, 100)];
imageView.center = CGPointMake(200, 300);
UIImage *anotherImage = [UIImage imageNamed:@"image"];
UIGraphicsBeginImageContextWithOptions(imageView.bounds.size, NO, 1.0);
[[UIBezierPath bezierPathWithRoundedRect:imageView.bounds
                           cornerRadius:50] addClip];
[anotherImage drawInRect:imageView.bounds];
imageView.image = UIGraphicsGetImageFromCurrentImageContext();
UIGraphicsEndImageContext();
[self.view addSubview:imageView];
</code></pre>

<p>在这里使用了贝塞尔曲线”切割”个这个图片, 给 <code class="highlighter-rouge">UIImageView</code> 添加了的圆角.</p>

<hr />

<h3 id="11-使用-drawrect-有什么影响">11. 使用 <code class="highlighter-rouge">drawRect:</code> 有什么影响?</h3>

<p>这个问题对于我来说确实有些难以回答, 我记得我在我人生的第一个 iOS 项目 SportJoin 中曾经使用这个方法来绘制图形, 但是具体怎么做的, 我已经忘记了.</p>

<p>这个方法的主要作用是根据传入的 <code class="highlighter-rouge">rect</code> 来绘制图像 <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/#//apple_ref/occ/instm/UIView/drawRect:">参见文档</a>. 这个方法的默认实现没有做任何事情, 我们<strong>可以</strong>在这个方法中使用 <code class="highlighter-rouge">Core Graphics</code> 和 <code class="highlighter-rouge">UIKit</code> 来绘制视图的内容.</p>

<p>这个方法的调用机制也是非常特别. 当你调用 <code class="highlighter-rouge">setNeedsDisplay</code> 方法时, UIKit 将会把当前图层标记为 dirty, 但<strong>还是会显示原来的内容</strong>, 直到下一次的视图渲染周期, 才会为标记为 dirty 的图层重新建立 Core Graphics 上下文, 然后将内存中的数据恢复出来, 再使用 CGContextRef 进行绘制.</p>

<hr />

<h3 id="12-asihttprequest-或者-sdwebimage-里面给-uiimageview-加载图片的逻辑是什么样的">12. ASIHttpRequest 或者 SDWebImage 里面给 UIImageView 加载图片的逻辑是什么样的?</h3>

<p>我曾经阅读过 SDWebImage 的源代码, 就在这里对如何给 UIImageView 加载图片做一个总结吧, SDWebImage 中为 UIView 提供了一个分类叫做 WebCache, 这个分类中有一个最常用的接口, <code class="highlighter-rouge">sd_setImageWithURL:placeholderImage:</code>, 这个分类同时提供了很多类似的方法, 这些方法最终会调用一个同时具有 <code class="highlighter-rouge">option</code> <code class="highlighter-rouge">progressBlock</code> <code class="highlighter-rouge">completionBlock</code> 的方法, 而在这个类最终被调用的方法首先会检查是否传入了 <code class="highlighter-rouge">placeholderImage</code> 以及对应的参数, 并设置 <code class="highlighter-rouge">placeholderImage</code>.</p>

<p>然后会获取 <code class="highlighter-rouge">SDWebImageManager</code> 中的单例调用一个 <code class="highlighter-rouge">downloadImageWithURL:...</code> 的方法来获取图片, 而这个 manager 获取图片的过程有大体上分为两部分, 它首先会在 <code class="highlighter-rouge">SDWebImageCache</code> 中寻找图片是否有对应的缓存, 它会以 url 作为数据的索引先在内存中寻找是否有对应的缓存, 如果缓存未命中就会在磁盘中利用 MD5 处理过的 key 来继续查询对应的数据, 如果找到了, 就会把磁盘中的缓存备份到内存中.</p>

<p>然而, 假设我们在内存和磁盘缓存中都没有命中, 那么 manager 就会调用它持有的一个 <code class="highlighter-rouge">SDWebImageDownloader</code> 对象的方法 <code class="highlighter-rouge">downloadImageWithURL:...</code> 来下载图片, 这个方法会在执行的过程中调用另一个方法 <code class="highlighter-rouge">addProgressCallback:andCompletedBlock:fotURL:createCallback:</code> 来存储下载过程中和下载完成的回调, 当回调块是第一次添加的时候, 方法会实例化一个 <code class="highlighter-rouge">NSMutableURLRequest</code> 和 <code class="highlighter-rouge">SDWebImageDownloaderOperation</code>, 并将后者加入 downloader 持有的下载队列开始图片的异步下载.</p>

<p>而在图片下载完成之后, 就会在主线程设置 image, 完成整个图像的异步下载和配置.</p>

<hr />

<h3 id="13-设计一个简单的图片内存缓存器-包含移除策略">13. 设计一个简单的图片内存缓存器 (包含移除策略)</h3>

<p>待我阅读完 path 开源的 <a href="https://github.com/path/FastImageCache">FastImageCache</a>的源代码就来回答.</p>

<hr />

<h3 id="14-讲讲你用instrument优化动画性能的经历">14. <del>讲讲你用Instrument优化动画性能的经历</del></h3>

<hr />

<h3 id="15-loadview-的作用是什么">15. <code class="highlighter-rouge">loadView</code> 的作用是什么?</h3>

<blockquote>
  <p>This method loads or creates a view and assigns it to the <code class="highlighter-rouge">view</code> property.</p>
</blockquote>

<p><code class="highlighter-rouge">loadView</code> 是 <code class="highlighter-rouge">UIViewController</code> 的实例方法, 我们永远不要直接调用这个方法 <code class="highlighter-rouge">[self loadView]</code>. 这在苹果的<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIViewController_Class/#//apple_ref/occ/instm/UIViewController/loadView">官方文档</a>中已经明确的写出了. <code class="highlighter-rouge">loadView</code> 会在获取视图控制器的 <code class="highlighter-rouge">view</code> 但是却得到 <code class="highlighter-rouge">nil</code> 时被调用.</p>

<p><code class="highlighter-rouge">loadView</code> 的具体实现会做下面两件事情中的一件:</p>

<ol>
  <li>
    <p>如果你的视图控制器关联了一个 storyboard, 那么它就会加载 storyboard 中的视图.</p>
  </li>
  <li>
    <p>如果试图控制器没有关联的 storyboard, 那么就会创建一个空的视图, 并分配给 <code class="highlighter-rouge">view</code> 属性</p>
  </li>
</ol>

<p>如果你需要覆写 <code class="highlighter-rouge">loadView</code> 方法:</p>

<ol>
  <li>你需要创建一个根视图.</li>
  <li>创建并初始化 <code class="highlighter-rouge">view</code> 的子视图, 调用 <code class="highlighter-rouge">addSubview:</code> 方法将它们添加到父视图上.</li>
  <li>如果你使用了自动布局, 提供足够的约束来保证视图的位置.</li>
  <li>将根视图分配给 <code class="highlighter-rouge">view</code> 属性.</li>
</ol>

<p>永远不要在这个方法中调用 <code class="highlighter-rouge">[super loadView]</code>.</p>

<hr />

<h3 id="16-viewwilllayoutsubviews-的作用是什么">16. <code class="highlighter-rouge">viewWillLayoutSubviews</code> 的作用是什么?</h3>

<p><code class="highlighter-rouge">viewWillLayoutSubviews</code> 方法会在视图的 bounds 改变时, 视图会调整子视图的位置, 我们可以在视图控制器中覆写这个方法在视图放置子视图前做出改变, 当屏幕的方向改变时, 这个方法会被调用.</p>

<hr />

<h3 id="17-gcd-里面有哪几种-queue-背后的线程模型是什么样的">17. GCD 里面有哪几种 Queue? 背后的线程模型是什么样的?</h3>

<p>GCD 中 Queue 的种类还要看我们怎么进行分类, 如果根据同一时间内处理的操作数分类的话, GCD 中的 Queue 分为两类</p>

<ol>
  <li>Serial Dispatch Queue</li>
  <li>Concurrent Dispatch Queue</li>
</ol>

<p>一类是串行派发队列, 它只使用一个线程, 会等待当前执行的操作结束后才会执行下一个操作, 它按照追加的顺序进行处理. 另一类是并行派发队列, 它同时使用多个线程, 如果当前的线程数足够, 那么就不会等待正在执行的操作, 使用多个线程同时执行多个处理.</p>

<p>另外的一种分类方式如下:</p>

<ol>
  <li>Main Dispatch Queue</li>
  <li>Global Dispatch Queue</li>
  <li>Custom Dispatch Queue</li>
</ol>

<p>主线程只有一个, 它是一个串行的进程. 所有追加到 Main Dispatch Queue 中的处理都会在 RunLoop 在执行. Global Dispatch Queue 是所有应用程序都能使用的并行派发队列, 它有 4 个执行优先级 High, Default, Low, Background. 当然我们也可以使用 <code class="highlighter-rouge">dispatch_queue_create</code> 创建派发队列.</p>

<hr />

<h3 id="18--core-data-或者-sqlite-的读写是分线程的吗-死锁如何解决">18.  Core Data 或者 sqlite 的读写是分线程的吗? 死锁如何解决?</h3>

<p>Core Data 和 sqlite 这两个我还真没深入用过, 我只在小的玩具应用上使用过 Core Data, 但是发现这货实在是太难用了, 我就果断放弃了, sqlite 我也用过, 每次输入 SQL 语句的时候我多想吐槽, 写一些简单的还好, 复杂的就直接 Orz 了. 所以我一般会使用 levelDB 对进行数据的持久存储.</p>

<p>数据库读取操作一般都是多线程的, 在对数据进行读取的时候, 我们要确保当前的状态不会被修改, 所以加锁, 防止由于线程竞争而出现的错误. 在 Core Data 中使用并行的最重要的规则是: <strong>每一个 <code class="highlighter-rouge">NSManagedObjectContext</code> 必须只从创建它的进程中访问</strong>.</p>

<hr />

<h3 id="19-http-的-post-和-get-有什么区别">19. http 的 POST 和 GET 有什么区别?</h3>

<p>根据 HTTP 协议的定义 GET 类型的请求是幂等的, 而 POST 请求是有副作用的, 也就是说 GET 用于获取一些资源, 而 POST 用于改变一些资源, 这可能会创建新的资源或更新已有的资源.</p>

<p>POST 请求比 GET 请求更加的安全, 因为你不会把信息添加到 URL 上的查询字符串上. 所以使用 GET 来收集密码或者一些敏感信息并不是什么好主意.</p>

<p>最后, POST 请求比 GET 请求也可以传输更多的信息.</p>

<hr />

<h3 id="20-什么是-binary-search-tree-它的时间复杂度是多少">20. 什么是 Binary search tree, 它的时间复杂度是多少?</h3>

<p>二叉搜索树是一棵以二叉树来组织的, 它搜索的时间复杂度 $O(h)$ 与树的高度成正比, 最坏的运行时间是 $\Theta(\lg n)$.</p>

<hr />

<h2 id="参考资料">参考资料</h2>
<ul>
  <li><a href="http://www.mgenware.com/blog/?p=1493">iOS: ARC和非ARC下使用Block属性的问题</a></li>
  <li><a href="http://stackoverflow.com/nquestions/12347236/which-is-threadsafe-atomic-or-non-atomic">Which is threadsafe atomic or non atomic?</a></li>
  <li><a href="http://stackoverflow.com/questions/13326435/nsobject-load-and-initialize-what-do-they-do">NSObject +load and +initialize - What do they do?</a></li>
  <li><a href="https://www.mikeash.com/pyblog/friday-qa-2009-05-22-objective-c-class-loading-and-initialization.html">Objective-C Class Loading and Initialization</a></li>
  <li><a href="http://stackoverflow.com/questions/6191480/objective-c-init-vs-initialize">Objective-C: init vs initialize</a></li>
  <li><a href="http://pilky.me/21/">Dynamic Tips &amp; Tricks With Objective-C
</a></li>
  <li><a href="http://nshipster.com/method-swizzling/">Method Swizzling</a></li>
  <li><a href="http://stackoverflow.com/questions/7826306/what-are-the-differences-between-a-uiview-and-a-calayer">What are the differences between a UIView and a CALayer?</a></li>
  <li><a href="http://raptureinvenice.com/ios-brownbag-view-vs-layers-including-clock-demo/">iOS Brownbag: View vs. Layers (including Clock Demo)</a></li>
  <li><a href="http://stackoverflow.com/questions/4735623/uilabel-layer-cornerradius-negatively-impacting-performance">UILabel layer cornerRadius negatively impacting performance</a></li>
  <li><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/#//apple_ref/occ/instm/UIView/drawRect:">UIView Class Reference</a></li>
  <li><a href="http://objccn.io/issue-3-1/">绘制像素到屏幕上</a></li>
  <li><a href="http://stackoverflow.com/questions/8876212/proper-use-of-loadview-and-viewdidload-with-uiviewcontroller-without-nibs-xibs">Proper use of loadView and viewDidLoad with UIViewController without nibs/xibs</a></li>
  <li><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIViewController_Class/#//apple_ref/occ/instm/UIViewController/loadView">UIViewController Class Reference</a></li>
  <li><a href="http://stackoverflow.com/questions/14662120/core-data-threads/14662206#14662206">Core Data &amp; Threads</a></li>
  <li><a href="http://stackoverflow.com/questions/10593735/making-core-data-thread-safe">Making Core Data Thread-safe</a></li>
  <li><a href="http://stackoverflow.com/questions/3477333/what-is-the-difference-between-post-and-get">What is the difference between POST and GET?</a></li>
  <li><a href="http://stackoverflow.com/questions/46585/when-do-you-use-post-and-when-do-you-use-get">When do you use POST and when do you use GET?</a></li>
  <li><a href="http://www.amazon.cn/Objective-C%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-iOS%E4%B8%8EOS-X%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E5%9D%82%E6%9C%AC%E4%B8%80%E6%A0%91/dp/B00DE60G3S/ref=sr_1_1?ie=UTF8&amp;qid=1430229077&amp;sr=8-1&amp;keywords=objective-c%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B+ios%E4%B8%8Eos+x%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86">Objective-C高级编程-iOS与OS-X多线程和内存管理</a></li>
</ul>



        </section>

        <footer class="post-footer">

            <!-- Everything inside the #author tags pulls data from the author -->
            <!-- #author-->
            
                
                    
                        <figure class="author-image">
                            <a class="img" href="/reprinted/author/Draveness" style="background-image: url(/reprinted/assets/images/draven.png)"><span class="hidden">Draveness's Picture</span></a>
                        </figure>
                    

                    <section class="author">
                        <h4><a href="/reprinted/author/Draveness">Draveness</a></h4>

                        
                            <p>Read <a href="/reprinted/author/Draveness">more posts</a> by this author.</p>
                        
                        <div class="author-meta">
                            <span class="author-location icon-location"> Beijing, China</span>
                            <span class="author-link icon-link"><a href="https://draveness.me/index"> draveness.me/index</a></span>
                        </div>
                    </section>

                    <!-- /author  -->

                    <section class="share">
                        <h4>Share this post</h4>
                        <a class="icon-twitter" href="http://twitter.com/share?text=关于一些 iOS 面试问题的解答&amp;url=guan-yu-xie-ios-wen-ti-de-jie-da"
                            onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
                            <span class="hidden">Twitter</span>
                        </a>
                        <a class="icon-facebook" href="https://www.facebook.com/sharer/sharer.php?u=guan-yu-xie-ios-wen-ti-de-jie-da"
                            onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
                            <span class="hidden">Facebook</span>
                        </a>
                        <a class="icon-google-plus" href="https://plus.google.com/share?url=guan-yu-xie-ios-wen-ti-de-jie-da"
                           onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
                            <span class="hidden">Google+</span>
                        </a>
                    </section>
                
            
            <!-- Add Disqus Comments -->
            

        </footer>

    </article>

</main>
<aside class="read-next">

    <!-- [[! next_post ]] -->
    
        <a class="read-next-story " style="background-image: url(/reprinted/assets/images/cover2.jpg)" href="/reprinted/ios-yuan-dai-ma-fen-xi-masonry">
            <section class="post">
                <h2>iOS 源代码分析----Masonry</h2>
                <p>[Masonry](https://github.com/SnapKit/Masonry) 是 Objective-C 中用于自动布局的第三方框架, 我们一般使用它来代替冗长, 繁琐的 AutoLayout 代码. Masonry 的使用还是很简洁的: ~~~objectivec [button mas_makeConstraints:^(MASConstraintMaker *make) {...</p>
            </section>
        </a>
    
    <!-- [[! /next_post ]] -->
    <!-- [[! prev_post ]] -->
    
        <a class="read-next-story prev " style="background-image: url(/reprinted/assets/images/cover2.jpg)" href="/reprinted/swift-zhong-init-de-shi-yong">
            <section class="post">
                <h2>Swift 类构造器的使用</h2>
                <p>这几天在使用 Swift 重写原来的一个运动社交应用 SportJoin. 为什么要重写呢? 首先因为实在找不到设计师给我作图; 其次, 原来写的代码太烂了我也闲不下来, 想找一些项目做, 所以只好将原来的代码重写了. 原来的代码大约是一年半以前写的, 我现在真的不想吐槽当时写的代码有多烂, 有一句话怎么说来着: 程序员连自己写的源代码都不想读, 怎么可能看别人写的源代码!...</p>
            </section>
        </a>
    
    <!-- [[! /prev_post ]] -->
</aside>

<!-- /post -->


        <!-- The tiny footer at the very bottom -->
        <footer class="site-footer clearfix">
          <section class="copyright"><a href="/reprinted/"></a> &copy; 2018</section>
          <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> using <a href="https://github.com/jekyller/jasper">Jasper</a></section>
        </footer>
    </div>
    <!-- highlight.js -->
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <!-- jQuery needs to come before `` so that jQuery can be used in code injection -->
    <script type="text/javascript" src="//code.jquery.com/jquery-1.12.0.min.js"></script>
    <!-- Ghost outputs important scripts and data with this tag -->
    <!--  -->
    <!-- Add Google Analytics  -->
        <!-- Google Analytics Tracking code -->
     <script>
	    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	    ga('create', 'UA-69281367-1', 'auto');
	    ga('send', 'pageview');

     </script>
    <!-- Fitvids makes video embeds responsive and awesome -->
    <script type="text/javascript" src="/reprinted/assets/js/jquery.fitvids.js"></script>
    <!-- The main JavaScript file for Casper -->
    <script type="text/javascript" src="/reprinted/assets/js/index.js"></script>

</body>
</html>
