<!DOCTYPE html>
<html>
<head>
    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Page Meta -->
    <title>如何实现 iOS 中的 Associated Object</title>
    <meta name="description" content="" />

    <!-- Mobile Meta -->
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- Brand icon -->
    <link rel="shortcut icon" href="/reprinted/assets/images/favicon.ico" >

    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/reprinted/assets/css/screen.css" />
    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400" />
    <link rel="stylesheet" type="text/css" href="/reprinted/assets/css/syntax.css" />

    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/styles/default.min.css">
    <style>.hljs { background: none; }</style>

    <!-- Ghost outputs important style and meta data with this tag -->
        <link rel="canonical" href="/reprinted//retain-cycle3" />
    <meta name="referrer" content="origin" />
    <link rel="next" href="/reprinted/page2/" />

    <meta property="og:site_name" content="" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="如何实现 iOS 中的 Associated Object" />
    <meta property="og:description" content="" />
    <meta property="og:url" content="/reprinted//retain-cycle3" />
    <meta property="og:image" content="/reprinted/assets/images/cover2.jpg" />

    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="如何实现 iOS 中的 Associated Object" />
    <meta name="twitter:description" content="" />
    <meta name="twitter:url" content="/reprinted//retain-cycle3" />
    <meta name="twitter:image:src" content="/reprinted/assets/images/cover2.jpg" />

    <script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "Website",
    "publisher": "",
    "name": "如何实现 iOS 中的 Associated Object",
    "url": "/reprinted//retain-cycle3",
    "image": "/reprinted/assets/images/cover2.jpg",
    "description": ""
}
    </script>

    <meta name="generator" content="Jekyll 3.0.0" />
    <link rel="alternate" type="application/rss+xml" title="" href="/reprinted/feed.xml" />


</head>
<body class="home-template nav-closed">

    <!-- The blog navigation links -->
    <div class="nav">
    <h3 class="nav-title">Menu</h3>
    <a href="#" class="nav-close">
        <span class="hidden">Close</span>
    </a>
    <ul>
        <li class="nav-home " role="presentation"><a href="/reprinted/">Home</a></li>
        <li class="nav-about " role="presentation"><a href="/reprinted/about">About</a></li>
        <li class="nav-ios " role="presentation"><a href="/reprinted/tag/ios">iOS</a></li>
        <li class="nav-objective-c " role="presentation"><a href="/reprinted/tag/objective-c">objective-c</a></li>
        <li class="nav-swift " role="presentation"><a href="/reprinted/tag/swift">Swift</a></li>
        <li class="nav-others " role="presentation"><a href="/reprinted/tag/others">others</a></li>
    </ul>
    <a class="subscribe-button icon-feed" href="/reprinted/feed.xml">Subscribe</a>
</div>
<span class="nav-cover"></span>


    <div class="site-wrapper">

        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- default -->

<!-- The comment above "< default" means - insert everything in this file into -->
    <!-- the [body] of the default.hbs template, which contains our header/footer. -->

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<header class="main-header post-head " style="background-image: url(/reprinted/assets/images/cover2.jpg) ">
    <nav class="main-nav  overlay  clearfix">
        <a class="blog-logo" href="/reprinted/"><img src="/reprinted/assets/images/ghost.png" alt="Blog Logo" /></a>
        
            <a class="menu-button icon-menu" href="#"><span class="word">Menu</span></a>
        
    </nav>
</header>

<main class="content" role="main">

    <article class="post tag-fiction">

        <header class="post-header">
            <h1 class="post-title">如何实现 iOS 中的 Associated Object</h1>
            <section class="post-meta">
            <!-- <a href='/reprinted/'></a> -->

            
                
                    <a href='/reprinted/author/Draveness'>Draveness</a>
                
            
            <time class="post-date" datetime="2016-08-02">02 Aug 2016</time>
                <!-- [[tags prefix=" on "]] -->
                
                on
                
                    
                       <a href='/reprinted/tag/iOS'>iOS</a>
                    
                
                
            </section>
        </header>

        <section class="post-content">

            <blockquote>
  <p>转自：<a href="https://draveness.me/retain-cycle3">如何实现 iOS 中的 Associated Object</a></p>
</blockquote>

<blockquote>
  <p>关注仓库，及时获得更新：<a href="https://github.com/draveness/iOS-Source-Code-Analyze">iOS-Source-Code-Analyze</a></p>

</blockquote>

<p>这一篇文章是对 <a href="[https://github.com/facebook/FBRetainCycleDetector]">FBRetainCycleDetector</a> 中实现的关联对象机制的分析；因为追踪的需要， FBRetainCycleDetector 重新实现了关联对象，本文主要就是对其实现关联对象的方法进行分析。</p>

<p>文章中涉及的类主要就是 <code class="highlighter-rouge">FBAssociationManager</code>：</p>

<blockquote>
  <p>FBAssociationManager is a tracker of object associations. For given object it can return all objects that are being retained by this object with objc_setAssociatedObject &amp; retain policy.</p>
</blockquote>

<p>FBRetainCycleDetector 在对关联对象进行追踪时，修改了底层处理关联对象的两个 C 函数，<code class="highlighter-rouge">objc_setAssociatedObject</code> 和 <code class="highlighter-rouge">objc_removeAssociatedObjects</code>，在这里不会分析它是如何修改底层 C 语言函数实现的，如果想要了解相关的内容，可以阅读下面的文章。</p>

<blockquote>
  <p>关于如何动态修改 C 语言函数实现可以看<a href="[https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/fishhook/动态修改%20C%20语言函数的实现.md]">动态修改 C 语言函数的实现</a>这篇文章，使用的第三方框架是 <a href="[https://github.com/facebook/fishhook]">fishhook</a>。</p>
</blockquote>

<h2 id="fbassociationmanager">FBAssociationManager</h2>

<p>在 <code class="highlighter-rouge">FBAssociationManager</code> 的类方法 <code class="highlighter-rouge">+ hook</code> 调用时，fishhook 会修改 <code class="highlighter-rouge">objc_setAssociatedObject</code> 和 <code class="highlighter-rouge">objc_removeAssociatedObjects</code> 方法：</p>

<pre><code class="language-objectivec">+ (void)hook {
#if _INTERNAL_RCD_ENABLED
	std::lock_guard&lt;std::mutex&gt; l(*FB::AssociationManager::hookMutex);
	rcd_rebind_symbols((struct rcd_rebinding[2]){
		{
			"objc_setAssociatedObject",
			(void *)FB::AssociationManager::fb_objc_setAssociatedObject,
			(void **)&amp;FB::AssociationManager::fb_orig_objc_setAssociatedObject
		},
		{
			"objc_removeAssociatedObjects",
			(void *)FB::AssociationManager::fb_objc_removeAssociatedObjects,
			(void **)&amp;FB::AssociationManager::fb_orig_objc_removeAssociatedObjects
		}}, 2);
	FB::AssociationManager::hookTaken = true;
#endif //_INTERNAL_RCD_ENABLED
}
</code></pre>

<p>将它们的实现替换为 <code class="highlighter-rouge">FB::AssociationManager:: fb_objc_setAssociatedObject</code> 以及 <code class="highlighter-rouge">FB::AssociationManager::fb_objc_removeAssociatedObjects</code> 这两个 Cpp 静态方法。</p>

<p>上面的两个方法实现都位于 <code class="highlighter-rouge">FB::AssociationManager</code> 的命名空间中：</p>

<pre><code class="language-objectivec">namespace FB { namespace AssociationManager {
	using ObjectAssociationSet = std::unordered_set&lt;void *&gt;;
	using AssociationMap = std::unordered_map&lt;id, ObjectAssociationSet *&gt;;

	static auto _associationMap = new AssociationMap();
	static auto _associationMutex = new std::mutex;

	static std::mutex *hookMutex(new std::mutex);
	static bool hookTaken = false;

	...
}
</code></pre>

<p>命名空间中有两个用于存储关联对象的数据结构：</p>

<ul>
  <li><code class="highlighter-rouge">AssociationMap</code> 用于存储从对象到 <code class="highlighter-rouge">ObjectAssociationSet *</code> 指针的映射</li>
  <li><code class="highlighter-rouge">ObjectAssociationSet</code> 用于存储某对象所有关联对象的集合</li>
</ul>

<p>其中还有几个比较重要的成员变量：</p>

<ul>
  <li><code class="highlighter-rouge">_associationMap</code> 就是 <code class="highlighter-rouge">AssociationMap</code> 的实例，是一个用于存储所有关联对象的数据结构</li>
  <li><code class="highlighter-rouge">_associationMutex</code> 用于在修改关联对象时加锁，防止出现线程竞争等问题，导致不可预知的情况发生</li>
  <li><code class="highlighter-rouge">hookMutex</code> 以及 <code class="highlighter-rouge">hookTaken</code> 都是在类方法 <code class="highlighter-rouge">+ hook</code> 调用时使用的，用于保证 hook 只会执行一次并保证线程安全</li>
</ul>

<p>用于追踪关联对象的静态方法 <code class="highlighter-rouge">fb_objc_setAssociatedObject</code> 只会追踪强引用：</p>

<pre><code class="language-objectivec">static void fb_objc_setAssociatedObject(id object, void *key, id value, objc_AssociationPolicy policy) {
	{
		std::lock_guard&lt;std::mutex&gt; l(*_associationMutex);
		if (policy == OBJC_ASSOCIATION_RETAIN ||
			policy == OBJC_ASSOCIATION_RETAIN_NONATOMIC) {
			_threadUnsafeSetStrongAssociation(object, key, value);
		} else {
			// We can change the policy, we need to clear out the key
			_threadUnsafeResetAssociationAtKey(object, key);
		}
	}

	fb_orig_objc_setAssociatedObject(object, key, value, policy);
}
</code></pre>

<p><code class="highlighter-rouge">std::lock_guard&lt;std::mutex&gt; l(*_associationMutex)</code> 对 <code class="highlighter-rouge">fb_objc_setAssociatedObject</code> 过程加锁，防止死锁问题，不过 <code class="highlighter-rouge">_associationMutex</code> 会在作用域之外被释放。</p>

<p>通过输入的 <code class="highlighter-rouge">policy</code> 我们可以判断哪些是强引用对象，然后调用 <code class="highlighter-rouge">_threadUnsafeSetStrongAssociation</code> 追踪它们，如果不是强引用对象，通过 <code class="highlighter-rouge">_threadUnsafeResetAssociationAtKey</code> 将 <code class="highlighter-rouge">key</code> 对应的 <code class="highlighter-rouge">value</code> 删除，保证追踪的正确性：</p>

<pre><code class="language-objectivec">void _threadUnsafeSetStrongAssociation(id object, void *key, id value) {
	if (value) {
		auto i = _associationMap-&gt;find(object);
		ObjectAssociationSet *refs;
		if (i != _associationMap-&gt;end()) {
			refs = i-&gt;second;
		} else {
			refs = new ObjectAssociationSet;
			(*_associationMap)[object] = refs;
		}
		refs-&gt;insert(key);
	} else {
		_threadUnsafeResetAssociationAtKey(object, key);
	}
}
</code></pre>

<p><code class="highlighter-rouge">_threadUnsafeSetStrongAssociation</code> 会以 object 作为键，查找或者创建一个 <code class="highlighter-rouge">ObjectAssociationSet *</code> 集合，将新的 <code class="highlighter-rouge">key</code> 插入到集合中，当然，如果 <code class="highlighter-rouge">value == nil</code> 或者上面 <code class="highlighter-rouge">fb_objc_setAssociatedObject</code> 方法中传入的 <code class="highlighter-rouge">policy</code> 是非 <code class="highlighter-rouge">retain</code> 的就会调用 <code class="highlighter-rouge">_threadUnsafeResetAssociationAtKey </code> 重置 <code class="highlighter-rouge">ObjectAssociationSet</code> 中的关联对象：</p>

<pre><code class="language-objectivec">void _threadUnsafeResetAssociationAtKey(id object, void *key) {
	auto i = _associationMap-&gt;find(object);

	if (i == _associationMap-&gt;end()) {
		return;
	}

	auto *refs = i-&gt;second;
	auto j = refs-&gt;find(key);
	if (j != refs-&gt;end()) {
		refs-&gt;erase(j);
	}
}
</code></pre>

<p>同样在查找到对应的 <code class="highlighter-rouge">ObjectAssociationSet</code> 之后会擦除 <code class="highlighter-rouge">key</code> 对应的值，<code class="highlighter-rouge">_threadUnsafeRemoveAssociations</code> 的实现与这个方法也差不多，相较于 reset 方法移除某一个对象的<strong>所有</strong>关联对象，该方法仅仅移除了某一个 <code class="highlighter-rouge">key</code> 对应的值。</p>

<pre><code class="language-objectivec">void _threadUnsafeRemoveAssociations(id object) {
	if (_associationMap-&gt;size() == 0 ){
		return;
	}

	auto i = _associationMap-&gt;find(object);
	if (i == _associationMap-&gt;end()) {
		return;
	}

	auto *refs = i-&gt;second;
	delete refs;
	_associationMap-&gt;erase(i);
}
</code></pre>

<p>调用 <code class="highlighter-rouge">_threadUnsafeRemoveAssociations</code> 的方法 <code class="highlighter-rouge">fb_objc_removeAssociatedObjects</code> 的实现也很简单，利用了上面的方法，并在执行结束后，使用原 <code class="highlighter-rouge">obj_removeAssociatedObjects</code> 方法对应的函数指针 <code class="highlighter-rouge">fb_orig_objc_removeAssociatedObjects</code> 移除关联对象：</p>

<pre><code class="language-objectivec">static void fb_objc_removeAssociatedObjects(id object) {
	{
		std::lock_guard&lt;std::mutex&gt; l(*_associationMutex);
		_threadUnsafeRemoveAssociations(object);
	}

	fb_orig_objc_removeAssociatedObjects(object);
}
</code></pre>

<h2 id="fbobjectivecgraphelement-获取关联对象">FBObjectiveCGraphElement 获取关联对象</h2>

<p>因为在获取某一个对象持有的所有强引用时，不可避免地需要获取其强引用的关联对象；因此我们也就需要使用 <code class="highlighter-rouge">FBAssociationManager</code> 提供的 <code class="highlighter-rouge">+ associationsForObject:</code> 接口获取所有<strong>强引用</strong>关联对象：</p>

<pre><code class="language-objectivec">- (NSSet *)allRetainedObjects {
	NSArray *retainedObjectsNotWrapped = [FBAssociationManager associationsForObject:_object];
	NSMutableSet *retainedObjects = [NSMutableSet new];

	for (id obj in retainedObjectsNotWrapped) {
		FBObjectiveCGraphElement *element = FBWrapObjectGraphElementWithContext(self, obj, _configuration, @[@"__associated_object"]);
		if (element) {
			[retainedObjects addObject:element];
		}
	}

	return retainedObjects;
}
</code></pre>

<p>这个接口调用我们在上一节中介绍的 <code class="highlighter-rouge">_associationMap</code>，最后得到某一个对象的所有关联对象的强引用：</p>

<pre><code class="language-objectivec">+ (NSArray *)associationsForObject:(id)object {
	return FB::AssociationManager::associations(object);
}

NSArray *associations(id object) {
	std::lock_guard&lt;std::mutex&gt; l(*_associationMutex);
	if (_associationMap-&gt;size() == 0 ){
		return nil;
	}

	auto i = _associationMap-&gt;find(object);
	if (i == _associationMap-&gt;end()) {
		return nil;
	}

	auto *refs = i-&gt;second;

	NSMutableArray *array = [NSMutableArray array];
	for (auto &amp;key: *refs) {
		id value = objc_getAssociatedObject(object, key);
		if (value) {
			[array addObject:value];
		}
	}

	return array;
}
</code></pre>

<p>这部分的代码没什么好解释的，遍历所有的 <code class="highlighter-rouge">key</code>，检测是否真的存在关联对象，然后加入可变数组，最后返回。</p>

<h2 id="总结">总结</h2>

<p>FBRetainCycleDetector 为了追踪某一 <code class="highlighter-rouge">NSObject</code> 对关联对象的引用，重新实现了关联对象模块，不过其实现与 ObjC 运行时中对关联对象的实现其实所差无几，如果对运行时中的关联对象实现原理有兴趣的话，可以看<a href="https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/objc/关联对象%20AssociatedObject%20完全解析.md">关联对象 AssociatedObject 完全解析</a>这篇文章，它介绍了底层运行时中的关联对象的实现。</p>

<p>这是 FBRetainCycleDetector 系列文章中的第三篇，第四篇也是最后一篇文章会介绍 FBRetainCycleDetector 是如何获取 block 持有的强引用的，这也是我觉得整个框架中实现最精彩的一部分。</p>

<blockquote>
  <p>关注仓库，及时获得更新：<a href="https://github.com/draveness/iOS-Source-Code-Analyze">iOS-Source-Code-Analyze</a></p>

</blockquote>



        </section>

        <footer class="post-footer">

            <!-- Everything inside the #author tags pulls data from the author -->
            <!-- #author-->
            
                
                    
                        <figure class="author-image">
                            <a class="img" href="/reprinted/author/Draveness" style="background-image: url(/reprinted/assets/images/draven.png)"><span class="hidden">Draveness's Picture</span></a>
                        </figure>
                    

                    <section class="author">
                        <h4><a href="/reprinted/author/Draveness">Draveness</a></h4>

                        
                            <p>Read <a href="/reprinted/author/Draveness">more posts</a> by this author.</p>
                        
                        <div class="author-meta">
                            <span class="author-location icon-location"> Beijing, China</span>
                            <span class="author-link icon-link"><a href="https://draveness.me/index"> draveness.me/index</a></span>
                        </div>
                    </section>

                    <!-- /author  -->

                    <section class="share">
                        <h4>Share this post</h4>
                        <a class="icon-twitter" href="http://twitter.com/share?text=如何实现 iOS 中的 Associated Object&amp;url=retain-cycle3"
                            onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
                            <span class="hidden">Twitter</span>
                        </a>
                        <a class="icon-facebook" href="https://www.facebook.com/sharer/sharer.php?u=retain-cycle3"
                            onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
                            <span class="hidden">Facebook</span>
                        </a>
                        <a class="icon-google-plus" href="https://plus.google.com/share?url=retain-cycle3"
                           onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
                            <span class="hidden">Google+</span>
                        </a>
                    </section>
                
            
            <!-- Add Disqus Comments -->
            

        </footer>

    </article>

</main>
<aside class="read-next">

    <!-- [[! next_post ]] -->
    
        <a class="read-next-story " style="background-image: url(/reprinted/assets/images/cover2.jpg)" href="/reprinted/object-init">
            <section class="post">
                <h2>对象是如何初始化的（iOS）</h2>
                <p>> 转自：[对象是如何初始化的（iOS）](https://draveness.me/object-init) > 关注仓库，及时获得更新：[iOS-Source-Code-Analyze](https://github.com/draveness/iOS-Source-Code-Analyze) > 在之前，我们已经讨论了非常多的问题了，关于 objc 源代码系列的文章也快结束了，其实关于对象是如何初始化的这篇文章本来是我要写的第一篇文章，但是由于有很多前置内容不得不说，所以留到了这里。 `+ alloc` 和 `- init` 这一对我们在 iOS...</p>
            </section>
        </a>
    
    <!-- [[! /next_post ]] -->
    <!-- [[! prev_post ]] -->
    
        <a class="read-next-story prev " style="background-image: url(/reprinted/assets/images/cover2.jpg)" href="/reprinted/retain-cycle2">
            <section class="post">
                <h2>检测 NSObject 对象持有的强指针</h2>
                <p>转自：检测 NSObject 对象持有的强指针 关注仓库，及时获得更新：iOS-Source-Code-Analyze 在上一篇文章中介绍了 FBRetainCycleDetector 的基本工作原理，这一篇文章中我们开始分析它是如何从每一个对象中获得它持有的强指针的。 如果没有看第一篇文章这里还是最好看一下，了解一下 FBRetainCycleDetector 的工作原理，如何在 iOS 中解决循环引用的问题。 FBRetainCycleDetector 获取对象的强指针是通过 FBObjectiveCObject...</p>
            </section>
        </a>
    
    <!-- [[! /prev_post ]] -->
</aside>

<!-- /post -->


        <!-- The tiny footer at the very bottom -->
        <footer class="site-footer clearfix">
          <section class="copyright"><a href="/reprinted/"></a> &copy; 2018</section>
          <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> using <a href="https://github.com/jekyller/jasper">Jasper</a></section>
        </footer>
    </div>
    <!-- highlight.js -->
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <!-- jQuery needs to come before `` so that jQuery can be used in code injection -->
    <script type="text/javascript" src="//code.jquery.com/jquery-1.12.0.min.js"></script>
    <!-- Ghost outputs important scripts and data with this tag -->
    <!--  -->
    <!-- Add Google Analytics  -->
        <!-- Google Analytics Tracking code -->
     <script>
	    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	    ga('create', 'UA-69281367-1', 'auto');
	    ga('send', 'pageview');

     </script>
    <!-- Fitvids makes video embeds responsive and awesome -->
    <script type="text/javascript" src="/reprinted/assets/js/jquery.fitvids.js"></script>
    <!-- The main JavaScript file for Casper -->
    <script type="text/javascript" src="/reprinted/assets/js/index.js"></script>

</body>
</html>
