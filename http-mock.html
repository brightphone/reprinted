<!DOCTYPE html>
<html>
<head>
    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Page Meta -->
    <title>如何进行 HTTP Mock（iOS）</title>
    <meta name="description" content="" />

    <!-- Mobile Meta -->
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- Brand icon -->
    <link rel="shortcut icon" href="/reprinted/assets/images/favicon.ico" >

    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/reprinted/assets/css/screen.css" />
    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400" />
    <link rel="stylesheet" type="text/css" href="/reprinted/assets/css/syntax.css" />

    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/styles/default.min.css">
    <style>.hljs { background: none; }</style>

    <!-- Ghost outputs important style and meta data with this tag -->
        <link rel="canonical" href="/reprinted//http-mock" />
    <meta name="referrer" content="origin" />
    <link rel="next" href="/reprinted/page2/" />

    <meta property="og:site_name" content="" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="如何进行 HTTP Mock（iOS）" />
    <meta property="og:description" content="" />
    <meta property="og:url" content="/reprinted//http-mock" />
    <meta property="og:image" content="/reprinted/assets/images/cover2.jpg" />

    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="如何进行 HTTP Mock（iOS）" />
    <meta name="twitter:description" content="" />
    <meta name="twitter:url" content="/reprinted//http-mock" />
    <meta name="twitter:image:src" content="/reprinted/assets/images/cover2.jpg" />

    <script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "Website",
    "publisher": "",
    "name": "如何进行 HTTP Mock（iOS）",
    "url": "/reprinted//http-mock",
    "image": "/reprinted/assets/images/cover2.jpg",
    "description": ""
}
    </script>

    <meta name="generator" content="Jekyll 3.0.0" />
    <link rel="alternate" type="application/rss+xml" title="" href="/reprinted/feed.xml" />


</head>
<body class="home-template nav-closed">

    <!-- The blog navigation links -->
    <div class="nav">
    <h3 class="nav-title">Menu</h3>
    <a href="#" class="nav-close">
        <span class="hidden">Close</span>
    </a>
    <ul>
        <li class="nav-home " role="presentation"><a href="/reprinted/">Home</a></li>
        <li class="nav-about " role="presentation"><a href="/reprinted/about">About</a></li>
        <li class="nav-ios " role="presentation"><a href="/reprinted/tag/ios">iOS</a></li>
        <li class="nav-objective-c " role="presentation"><a href="/reprinted/tag/objective-c">objective-c</a></li>
        <li class="nav-swift " role="presentation"><a href="/reprinted/tag/swift">Swift</a></li>
        <li class="nav-others " role="presentation"><a href="/reprinted/tag/others">others</a></li>
    </ul>
    <a class="subscribe-button icon-feed" href="/reprinted/feed.xml">Subscribe</a>
</div>
<span class="nav-cover"></span>


    <div class="site-wrapper">

        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- default -->

<!-- The comment above "< default" means - insert everything in this file into -->
    <!-- the [body] of the default.hbs template, which contains our header/footer. -->

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<header class="main-header post-head " style="background-image: url(/reprinted/assets/images/cover2.jpg) ">
    <nav class="main-nav  overlay  clearfix">
        <a class="blog-logo" href="/reprinted/"><img src="/reprinted/assets/images/ghost.png" alt="Blog Logo" /></a>
        
            <a class="menu-button icon-menu" href="#"><span class="word">Menu</span></a>
        
    </nav>
</header>

<main class="content" role="main">

    <article class="post tag-fiction">

        <header class="post-header">
            <h1 class="post-title">如何进行 HTTP Mock（iOS）</h1>
            <section class="post-meta">
            <!-- <a href='/reprinted/'></a> -->

            
                
                    <a href='/reprinted/author/Draveness'>Draveness</a>
                
            
            <time class="post-date" datetime="2016-08-16">16 Aug 2016</time>
                <!-- [[tags prefix=" on "]] -->
                
                on
                
                    
                       <a href='/reprinted/tag/iOS'>iOS</a>,
                    
                
                    
                       <a href='/reprinted/tag/HTTP'>HTTP</a>
                    
                
                
            </section>
        </header>

        <section class="post-content">

            <blockquote>
  <p>转自：<a href="https://draveness.me/http-mock">如何进行 HTTP Mock（iOS）</a></p>
</blockquote>

<p>这篇文章会对 <a href="[https://github.com/AliSoftware/OHHTTPStubs]">OHHTTPStubs</a> 源代码的分析，其实现原理是建立在 <code class="highlighter-rouge">NSURLProtocol</code> 的基础上的，对这部分内容不了解的读者，可以阅读这篇文章 <a href="https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/contents/OHHTTPStubs/iOS%20开发中使用%20NSURLProtocol%20拦截%20HTTP%20请求.md">iOS 开发中使用 NSURLProtocol 拦截 HTTP 请求</a>了解相关知识，本文中不会介绍拦截 HTTP 请求的原理。</p>

<h3 id="如何使用-ohhttpstubs-mock-网络请求">如何使用 OHHTTPStubs Mock 网络请求</h3>

<p>HTTP Mock 在测试中非常好用，我们可以在不需要后端 API 的情况下，在本地对 HTTP 请求进行拦截，返回想要的 <code class="highlighter-rouge">json</code> 数据，而 OHHTTPStubs 就为我们提供了这样一种解决方案。</p>

<p>在了解其实现之前，先对 OHHTTPStubs 进行简单的介绍，引入头文件这种事情在这里会直接省略，先来看一下程序的源代码：</p>

<pre><code class="language-objectivec">[OHHTTPStubs stubRequestsPassingTest:^BOOL(NSURLRequest * _Nonnull request) {
    return [request.URL.absoluteString isEqualToString:@"https://idont.know"];
} withStubResponse:^OHHTTPStubsResponse * _Nonnull(NSURLRequest * _Nonnull request) {
    NSString *fixture = OHPathForFile(@"example.json", self.class);
    return [OHHTTPStubsResponse responseWithFileAtPath:fixture statusCode:200 headers:@{@"Content-Type":@"application/json"}];
}];

AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];
[manager GET:@"https://idont.know"
  parameters:nil
    progress:nil
     success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {
         NSLog(@"%@", responseObject);
     } failure:nil];
</code></pre>

<p>我们向 <code class="highlighter-rouge">https://idont.know</code> 这个 URL 发送一个 GET 请求，虽然这个 URL 并不存在，但是这里的代码通过 HTTP stub 成功地模拟了 HTTP 响应：</p>

<p><img src="https://img.draveness.me/2016-08-16-OHHTTPStubs-test.png-1000width" alt="OHHTTPStubs-test" /></p>

<h2 id="ohhttpstubs-的实现">OHHTTPStubs 的实现</h2>

<p>在了解了 OHHTTPStubs 的使用之后，我们会对其实现进行分析，它分成四部分进行：</p>

<ul>
  <li><code class="highlighter-rouge">OHHTTPStubsProtocol</code> 拦截 HTTP 请求</li>
  <li><code class="highlighter-rouge">OHHTTPStubs</code> 单例管理 <code class="highlighter-rouge">OHHTTPStubsDescriptor</code> 实例</li>
  <li><code class="highlighter-rouge">OHHTTPStubsResponse</code> 伪造 HTTP 响应</li>
  <li>一些辅助功能</li>
</ul>

<h3 id="ohhttpstubsprotocol-拦截-http-请求">OHHTTPStubsProtocol 拦截 HTTP 请求</h3>

<p>在 OHHTTPStubs 中继承 <code class="highlighter-rouge">NSURLProtocol</code> 的类就是 <code class="highlighter-rouge">OHHTTPStubsProtocol</code>，它在 HTTP 请求发出之前对 request 对象进行过滤以及处理：</p>

<pre><code class="language-objectivec">+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
	return ([OHHTTPStubs.sharedInstance firstStubPassingTestForRequest:request] != nil);
}

- (id)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)response client:(id&lt;NSURLProtocolClient&gt;)client {
	OHHTTPStubsProtocol* proto = [super initWithRequest:request cachedResponse:nil client:client];
	proto.stub = [OHHTTPStubs.sharedInstance firstStubPassingTestForRequest:request];
	return proto;
}

+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
	return request;
}
</code></pre>

<p>判断请求是否会被当前协议对象进行处理是需要 <code class="highlighter-rouge">OHHTTPStubs</code> 的实例方法 <code class="highlighter-rouge">- firstStubPassingTestForRequest:</code> 的执行的，在这里暂时先不对这个方法进行讨论。</p>

<p>接下来就是请求发送的过程 <code class="highlighter-rouge">- startLoading</code> 方法了，该方法的实现实在是太过于复杂，所以这里分块来分析代码：</p>

<pre><code class="language-objectivec">- (void)startLoading {
	NSURLRequest* request = self.request;
	id&lt;NSURLProtocolClient&gt; client = self.client;

	OHHTTPStubsResponse* responseStub = self.stub.responseBlock(request);

	if (OHHTTPStubs.sharedInstance.onStubActivationBlock) {
		OHHTTPStubs.sharedInstance.onStubActivationBlock(request, self.stub, responseStub);
	}

	...
}
</code></pre>

<p>从当前对象中取出 <code class="highlighter-rouge">request</code> 以及 <code class="highlighter-rouge">client</code> 对象，如果 <code class="highlighter-rouge">OHHTTPStubs</code> 的单例中包含 <code class="highlighter-rouge">onStubActivationBlock</code>，就会执行这里的 block，然后调用 <code class="highlighter-rouge">responseBlock</code> 获取一个 <code class="highlighter-rouge">OHHTTPStubsResponse</code> HTTP 响应对象。</p>

<p><code class="highlighter-rouge">OHHTTPStubs</code> 不只提供了 <code class="highlighter-rouge">onStubActivationBlock</code> 这一个钩子，还有以下 block：</p>

<ul>
  <li><code class="highlighter-rouge">+ onStubActivationBlock</code>：stub 被激活时调用</li>
  <li><code class="highlighter-rouge">+ onStubRedirectBlock</code>：发生重定向时</li>
  <li><code class="highlighter-rouge">+ afterStubFinishBlock</code>：在 stub 结束时调用</li>
</ul>

<p>如果响应对象的生成没有遇到任何问题，就会进入处理 Cookie、重定向、发送响应和模拟数据流的过程了。</p>

<ol>
  <li>首先是对 Cookie 的处理</li>
</ol>

<pre><code class="language-objectivec">NSHTTPURLResponse* urlResponse = [[NSHTTPURLResponse alloc] initWithURL:request.URL
															 statusCode:responseStub.statusCode
															HTTPVersion:@"HTTP/1.1"
														   headerFields:responseStub.httpHeaders];

if (request.HTTPShouldHandleCookies &amp;&amp; request.URL) {
	NSArray* cookies = [NSHTTPCookie cookiesWithResponseHeaderFields:responseStub.httpHeaders forURL:request.URL];
	if (cookies) {
		[NSHTTPCookieStorage.sharedHTTPCookieStorage setCookies:cookies forURL:request.URL mainDocumentURL:request.mainDocumentURL];
	}
}
</code></pre>

<ol>
  <li>如果 HTTP 状态码在 300-400 之间，就会处理重定向的问题，调用 <code class="highlighter-rouge">onStubRedirectBlock</code> 进行需要的回调</li>
</ol>

<pre><code class="language-objectivec">NSString* redirectLocation = (responseStub.httpHeaders)[@"Location"];
NSURL* redirectLocationURL = redirectLocation ? [NSURL URLWithString:redirectLocation] : nil;

if (((responseStub.statusCode &gt; 300) &amp;&amp; (responseStub.statusCode &lt; 400)) &amp;&amp; redirectLocationURL) {
	NSURLRequest* redirectRequest = [NSURLRequest requestWithURL:redirectLocationURL];
	[self executeOnClientRunLoopAfterDelay:responseStub.requestTime block:^{
		if (!self.stopped) {
			[client URLProtocol:self wasRedirectedToRequest:redirectRequest redirectResponse:urlResponse];
			if (OHHTTPStubs.sharedInstance.onStubRedirectBlock) {
				OHHTTPStubs.sharedInstance.onStubRedirectBlock(request, redirectRequest, self.stub, responseStub);
			}
		}
	}];
}
</code></pre>

<ol>
  <li>最后这里有一些复杂，我们根据 <code class="highlighter-rouge">stub</code> 中存储的 <code class="highlighter-rouge">responseTime</code> 来模拟响应的一个延迟时间，然后使用 <code class="highlighter-rouge">- streamDataForClient:withStubResponse:completion:</code> 来模拟数据以 <code class="highlighter-rouge">NSData</code> 的形式分块发送回 <code class="highlighter-rouge">client</code> 的过程，最后调用 <code class="highlighter-rouge">afterStubFinishBlock</code>。</li>
</ol>

<pre><code class="language-objectivec">[self executeOnClientRunLoopAfterDelay:responseStub.requestTime block:^{
	if (!self.stopped) {
		[client URLProtocol:self didReceiveResponse:urlResponse cacheStoragePolicy:NSURLCacheStorageNotAllowed];
		if(responseStub.inputStream.streamStatus == NSStreamStatusNotOpen) {
			[responseStub.inputStream open];
		}
		[self streamDataForClient:client
				 withStubResponse:responseStub
					   completion:^(NSError * error) {
			 [responseStub.inputStream close];
			 NSError *blockError = nil;
			 if (error==nil) {
				 [client URLProtocolDidFinishLoading:self];
			 } else {
				 [client URLProtocol:self didFailWithError:responseStub.error];
				 blockError = responseStub.error;
			 }
			 if (OHHTTPStubs.sharedInstance.afterStubFinishBlock) {
				 OHHTTPStubs.sharedInstance.afterStubFinishBlock(request, self.stub, responseStub, blockError);
			 }
		 }];
	}
}];
</code></pre>

<p>当然如果在生成 <code class="highlighter-rouge">responseStub</code> 的时候发生了错误，也会进行类似的操作，在延迟一定时间（模拟网络延迟）后执行 block 并传入各种参数：</p>

<pre><code class="language-objectivec">[self executeOnClientRunLoopAfterDelay:responseStub.responseTime block:^{
	if (!self.stopped) {
		[client URLProtocol:self didFailWithError:responseStub.error];
		if (OHHTTPStubs.sharedInstance.afterStubFinishBlock) {
			OHHTTPStubs.sharedInstance.afterStubFinishBlock(request, self.stub, responseStub, responseStub.error);
		}
	}
}];
</code></pre>

<h4 id="模拟数据流">模拟数据流</h4>

<p>因为在客户端接收数据时，所有的 <code class="highlighter-rouge">NSData</code> 并不是一次就涌入客户端的，而是分块加载打包解码的，尤其是在我们执行下载操作时，有时几 MB 的文件不可能同时到达服务端，而 <code class="highlighter-rouge">- startLoading</code> 中调用的 <code class="highlighter-rouge">- streamDataForClient:withStubResponse:completion:</code> 方法就是为了模拟数据流，分块向服务端发送数据，不过这部分的处理涉及到一个私有的结构体 <code class="highlighter-rouge">OHHTTPStubsStreamTimingInfo</code>：</p>

<pre><code class="language-objectivec">typedef struct {
	NSTimeInterval slotTime;
	double chunkSizePerSlot;
	double cumulativeChunkSize;
} OHHTTPStubsStreamTimingInfo;
</code></pre>

<p>这个结构体包含了关于发送数据流的信息：</p>

<ul>
  <li><code class="highlighter-rouge">slotTime</code>：两次发送 <code class="highlighter-rouge">NSData</code> 的间隔时间</li>
  <li><code class="highlighter-rouge">chunkSizePerSlot</code>：每块数据流大小</li>
  <li><code class="highlighter-rouge">cumulativeChunkSize</code>：已发送的数据流大小</li>
</ul>

<p>模拟数据流的过程需要两个方法的支持，其中一个方法做一些预加载工作：</p>

<pre><code class="language-objectivec">- (void)streamDataForClient:(id&lt;NSURLProtocolClient&gt;)client
		   withStubResponse:(OHHTTPStubsResponse*)stubResponse
				 completion:(void(^)(NSError * error))completion {
	if ((stubResponse.dataSize&gt;0) &amp;&amp; stubResponse.inputStream.hasBytesAvailable &amp;&amp; (!self.stopped)) {
		OHHTTPStubsStreamTimingInfo timingInfo = {
			.slotTime = kSlotTime,
			.cumulativeChunkSize = 0
		};

		if(stubResponse.responseTime &lt; 0) {
			timingInfo.chunkSizePerSlot = (fabs(stubResponse.responseTime) * 1000) * timingInfo.slotTime;
		} else if (stubResponse.responseTime &lt; kSlotTime) {
			timingInfo.chunkSizePerSlot = stubResponse.dataSize;
			timingInfo.slotTime = stubResponse.responseTime;
		} else {
			timingInfo.chunkSizePerSlot = ((stubResponse.dataSize/stubResponse.responseTime) * timingInfo.slotTime);
		}

		[self streamDataForClient:client
					   fromStream:stubResponse.inputStream
					   timingInfo:timingInfo
					   completion:completion];
	} else {
		if (completion) completion(nil);
	}
}
</code></pre>

<p>该方法将生成的 <code class="highlighter-rouge">OHHTTPStubsStreamTimingInfo</code> 信息传入下一个实例方法 <code class="highlighter-rouge">- streamDataForClient:fromStream:timingInfo:completion:</code>：</p>

<pre><code class="language-objectivec">- (void)streamDataForClient:(id&lt;NSURLProtocolClient&gt;)client fromStream:(NSInputStream*)inputStream timingInfo:(OHHTTPStubsStreamTimingInfo)timingInfo completion:(void(^)(NSError * error))completion {
	if (inputStream.hasBytesAvailable &amp;&amp; (!self.stopped)) {
		double cumulativeChunkSizeAfterRead = timingInfo.cumulativeChunkSize + timingInfo.chunkSizePerSlot;
		NSUInteger chunkSizeToRead = floor(cumulativeChunkSizeAfterRead) - floor(timingInfo.cumulativeChunkSize);
		timingInfo.cumulativeChunkSize = cumulativeChunkSizeAfterRead;

		if (chunkSizeToRead == 0) {
			[self executeOnClientRunLoopAfterDelay:timingInfo.slotTime block:^{
				[self streamDataForClient:client fromStream:inputStream
							   timingInfo:timingInfo completion:completion];
			}];
		} else {
			uint8_t* buffer = (uint8_t*)malloc(sizeof(uint8_t)*chunkSizeToRead);
			NSInteger bytesRead = [inputStream read:buffer maxLength:chunkSizeToRead];
			if (bytesRead &gt; 0) {
				NSData * data = [NSData dataWithBytes:buffer length:bytesRead];
				[self executeOnClientRunLoopAfterDelay:((double)bytesRead / (double)chunkSizeToRead) * timingInfo.slotTime block:^{
					[client URLProtocol:self didLoadData:data];
					[self streamDataForClient:client fromStream:inputStream
								   timingInfo:timingInfo completion:completion];
				}];
			} else {
				if (completion) completion(inputStream.streamError);
			}
			free(buffer);
		}
	} else {
		if (completion) completion(nil);
	}
}
</code></pre>

<ul>
  <li>上述方法会先计算 <code class="highlighter-rouge">chunkSizeToRead</code>，也就是接下来要传递给 <code class="highlighter-rouge">client</code> 的数据长度</li>
  <li>从 <code class="highlighter-rouge">NSInputStream</code> 中读取对应长度的数据</li>
  <li>通过 <code class="highlighter-rouge">- executeOnClientRunLoopAfterDelay:block:</code> 模拟数据传输的延时</li>
  <li>使用 <code class="highlighter-rouge">- URLProtocol:didLoadData:</code> 代理方法将数据传回 <code class="highlighter-rouge">client</code></li>
</ul>

<p>OHHTTPStubs 通过上面的两个方法很好的模拟了 HTTP 响应由于网络造成的延迟以及数据分块到达客户端的特点。</p>

<h3 id="ohhttpstubs-以及-ohhttpstubsdescriptor-对-stub-的管理">OHHTTPStubs 以及 OHHTTPStubsDescriptor 对 stub 的管理</h3>

<p><code class="highlighter-rouge">OHHTTPStubs</code> 遵循单例模式，其主要作用就是提供便利的 API 并持有一个 <code class="highlighter-rouge">OHHTTPStubsDescriptor</code> 数组，对 stub 进行管理。</p>

<p><code class="highlighter-rouge">OHHTTPStubs</code> 提供的类方法 <code class="highlighter-rouge">+ stubRequestsPassingTest:withStubResponse:</code> 会添加一个 <code class="highlighter-rouge">OHHTTPStubsDescriptor </code> 的实例到 <code class="highlighter-rouge">OHHTTPStubsDescriptor</code> 数组中：</p>

<pre><code class="language-objectivec">+ (id&lt;OHHTTPStubsDescriptor&gt;)stubRequestsPassingTest:(OHHTTPStubsTestBlock)testBlock
									withStubResponse:(OHHTTPStubsResponseBlock)responseBlock {
	OHHTTPStubsDescriptor* stub = [OHHTTPStubsDescriptor stubDescriptorWithTestBlock:testBlock
																	   responseBlock:responseBlock];
	[OHHTTPStubs.sharedInstance addStub:stub];
	return stub;
}
</code></pre>

<p>该类主要有两种方法，一种方法用于管理持有的 HTTP stub，比如说：</p>

<ul>
  <li><code class="highlighter-rouge">+ (BOOL)removeStub:(id&lt;OHHTTPStubsDescriptor&gt;)stubDesc</code></li>
  <li><code class="highlighter-rouge">+ (void)removeAllStubs</code></li>
  <li><code class="highlighter-rouge">- (void)addStub:(OHHTTPStubsDescriptor*)stubDesc</code></li>
  <li><code class="highlighter-rouge">- (BOOL)removeStub:(id&lt;OHHTTPStubsDescriptor&gt;)stubDesc</code></li>
  <li><code class="highlighter-rouge">- (void)removeAllStubs</code></li>
</ul>

<p>这些方法都是用来操作单例持有的数组的，而另一种方法用来设置相应事件发生时的回调：</p>

<ul>
  <li><code class="highlighter-rouge">+ (void)onStubActivation:( nullable void(^)(NSURLRequest* request, id&lt;OHHTTPStubsDescriptor&gt; stub, OHHTTPStubsResponse* responseStub) )block</code></li>
  <li><code class="highlighter-rouge">+ (void)onStubRedirectResponse:( nullable void(^)(NSURLRequest* request, NSURLRequest* redirectRequest, id&lt;OHHTTPStubsDescriptor&gt; stub, OHHTTPStubsResponse* responseStub) )block</code></li>
  <li><code class="highlighter-rouge">+ (void)afterStubFinish:( nullable void(^)(NSURLRequest* request, id&lt;OHHTTPStubsDescriptor&gt; stub, OHHTTPStubsResponse* responseStub, NSError* error) )block</code></li>
</ul>

<p>类中最重要的实例方法就是 <code class="highlighter-rouge">- firstStubPassingTestForRequest:</code>，它遍历自己持有的全部 stub，通过 <code class="highlighter-rouge">testBlock</code> 的调用返回第一个符合条件的 stub：</p>

<pre><code class="language-objectivec">- (OHHTTPStubsDescriptor*)firstStubPassingTestForRequest:(NSURLRequest*)request {
	OHHTTPStubsDescriptor* foundStub = nil;
	@synchronized(_stubDescriptors) {
		for(OHHTTPStubsDescriptor* stub in _stubDescriptors.reverseObjectEnumerator) {
			if (stub.testBlock(request)) {
				foundStub = stub;
				break;
			}
		}
	}
	return foundStub;
}
</code></pre>

<p>相比之下 <code class="highlighter-rouge">OHHTTPStubsDescriptor</code> 仅仅作为一个保存信息的类，其职能相对单一、实现相对简单：</p>

<pre><code class="language-objectivec">@interface OHHTTPStubsDescriptor : NSObject &lt;OHHTTPStubsDescriptor&gt;
@property(atomic, copy) OHHTTPStubsTestBlock testBlock;
@property(atomic, copy) OHHTTPStubsResponseBlock responseBlock;
@end

@implementation OHHTTPStubsDescriptor

+ (instancetype)stubDescriptorWithTestBlock:(OHHTTPStubsTestBlock)testBlock
							  responseBlock:(OHHTTPStubsResponseBlock)responseBlock {
	OHHTTPStubsDescriptor* stub = [OHHTTPStubsDescriptor new];
	stub.testBlock = testBlock;
	stub.responseBlock = responseBlock;
	return stub;
}

@end
</code></pre>

<p>两个属性以及一个方法构成了 <code class="highlighter-rouge">OHHTTPStubsDescriptor</code> 类的全部实现。</p>

<h3 id="ohhttpstubsresponse-伪造-http-响应">OHHTTPStubsResponse 伪造 HTTP 响应</h3>

<p><code class="highlighter-rouge">OHHTTPStubsResponse</code> 类为请求提供了相应所需要的各种参数，HTTP 状态码、请求时间以及数据的输入流也就是用于模拟网络请求的 <code class="highlighter-rouge">inputStream</code>。</p>

<p>指定构造器 <code class="highlighter-rouge">- initWithFileURL:statusCode:headers:</code> 完成了对这些参数的配置：</p>

<pre><code class="language-objectivec">- (instancetype)initWithInputStream:(NSInputStream*)inputStream dataSize:(unsigned long long)dataSize statusCode:(int)statusCode headers:(nullable NSDictionary*)httpHeaders {
	if (self = [super init]) {
		_inputStream = inputStream;
		_dataSize = dataSize;
		_statusCode = statusCode;
		NSMutableDictionary * headers = [NSMutableDictionary dictionaryWithDictionary:httpHeaders];
		static NSString *const ContentLengthHeader = @"Content-Length";
		if (!headers[ContentLengthHeader]) {
			headers[ContentLengthHeader] = [NSString stringWithFormat:@"%llu",_dataSize];
		}
		_httpHeaders = [NSDictionary dictionaryWithDictionary:headers];
	}
	return self;
}
</code></pre>

<p>同时，该类也提供了非常多的便利构造器以及类方法帮助我们实例化 <code class="highlighter-rouge">OHHTTPStubsResponse</code>，整个类中的所有构造方法大都会调用上述构造器；只是会传入不同的参数：</p>

<pre><code class="language-objectivec">- (instancetype)initWithFileURL:(NSURL *)fileURL statusCode:(int)statusCode headers:(nullable NSDictionary *)httpHeaders {
	NSNumber *fileSize;
	NSError *error;
	const BOOL success __unused = [fileURL getResourceValue:&amp;fileSize forKey:NSURLFileSizeKey error:&amp;error];

	return [self initWithInputStream:[NSInputStream inputStreamWithURL:fileURL] dataSize:[fileSize unsignedLongLongValue] statusCode:statusCode headers:httpHeaders];
}
</code></pre>

<p>比如 <code class="highlighter-rouge">- initWithFileURL:statusCode:headers:</code> 方法就会从文件中读取数据，然后构造一个数据输入流。</p>

<h3 id="其他内容">其他内容</h3>

<p>使用 <code class="highlighter-rouge">NSURLProtocol</code> 拦截 HTTP 请求时会有一个非常严重的问题，如果发出的是 POST 请求，请求的 body 会在到达 OHHTTPStubs 时被重置为空，也就是我们无法直接在 <code class="highlighter-rouge">testBlock</code> 中获取其 <code class="highlighter-rouge">HTTPBody</code>；所以，我们只能通过通过方法调剂在设置 <code class="highlighter-rouge">HTTPBody</code> 时，进行备份：</p>

<pre><code class="language-objectivec">typedef void(*OHHHTTPStubsSetterIMP)(id, SEL, id);
static OHHHTTPStubsSetterIMP orig_setHTTPBody;

static void OHHTTPStubs_setHTTPBody(id self, SEL _cmd, NSData* HTTPBody) {
	if (HTTPBody) {
		[NSURLProtocol setProperty:HTTPBody forKey:OHHTTPStubs_HTTPBodyKey inRequest:self];
	}
	orig_setHTTPBody(self, _cmd, HTTPBody);
}
@interface NSMutableURLRequest (HTTPBodyTesting) @end

@implementation NSMutableURLRequest (HTTPBodyTesting)

+ (void)load {
	orig_setHTTPBody = (OHHHTTPStubsSetterIMP)OHHTTPStubsReplaceMethod(@selector(setHTTPBody:), (IMP)OHHTTPStubs_setHTTPBody, [NSMutableURLRequest class], NO);
}

@end
</code></pre>

<p>除了对于 <code class="highlighter-rouge">HTTPBody</code> 的备份之外，OHHTTPStubs 还提供了一些用于从文件中获取数据的 C 函数：</p>

<pre><code class="language-objectivec">NSString* __nullable OHPathForFile(NSString* fileName, Class inBundleForClass);
NSString* __nullable OHPathForFileInBundle(NSString* fileName, NSBundle* bundle);
NSString* __nullable OHPathForFileInDocumentsDir(NSString* fileName);
NSBundle* __nullable OHResourceBundle(NSString* bundleBasename, Class inBundleForClass);
</code></pre>

<p>这些 C 语言函数能够帮助我们构造 HTTP 响应。</p>

<h2 id="总结">总结</h2>

<p>如果阅读过上一篇文章中的内容，理解这里的实现原理也不是什么太大的问题。在需要使用到 HTTP mock 进行测试时，使用 OHHTTPStubs 还是很方便的，当然现在也有很多其他的 HTTP stub 框架，不过实现基本上都是基于 <code class="highlighter-rouge">NSURLProtocol</code> 的。</p>

<blockquote>
  <p>Github Repo：<a href="https://github.com/draveness/iOS-Source-Code-Analyze">iOS-Source-Code-Analyze</a></p>

</blockquote>

<blockquote>

  <p>Source: http://draveness.me/http-mock</p>
</blockquote>


        </section>

        <footer class="post-footer">

            <!-- Everything inside the #author tags pulls data from the author -->
            <!-- #author-->
            
                
                    
                        <figure class="author-image">
                            <a class="img" href="/reprinted/author/Draveness" style="background-image: url(/reprinted/assets/images/draven.png)"><span class="hidden">Draveness's Picture</span></a>
                        </figure>
                    

                    <section class="author">
                        <h4><a href="/reprinted/author/Draveness">Draveness</a></h4>

                        
                            <p>Read <a href="/reprinted/author/Draveness">more posts</a> by this author.</p>
                        
                        <div class="author-meta">
                            <span class="author-location icon-location"> Beijing, China</span>
                            <span class="author-link icon-link"><a href="https://draveness.me/index"> draveness.me/index</a></span>
                        </div>
                    </section>

                    <!-- /author  -->

                    <section class="share">
                        <h4>Share this post</h4>
                        <a class="icon-twitter" href="http://twitter.com/share?text=如何进行 HTTP Mock（iOS）&amp;url=http-mock"
                            onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
                            <span class="hidden">Twitter</span>
                        </a>
                        <a class="icon-facebook" href="https://www.facebook.com/sharer/sharer.php?u=http-mock"
                            onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
                            <span class="hidden">Facebook</span>
                        </a>
                        <a class="icon-google-plus" href="https://plus.google.com/share?url=http-mock"
                           onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
                            <span class="hidden">Google+</span>
                        </a>
                    </section>
                
            
            <!-- Add Disqus Comments -->
            

        </footer>

    </article>

</main>
<aside class="read-next">

    <!-- [[! next_post ]] -->
    
        <a class="read-next-story " style="background-image: url(/reprinted/assets/images/cover2.jpg)" href="/reprinted/asdk-rendering">
            <section class="post">
                <h2>使用 ASDK 性能调优 - 提升 iOS 界面的渲染性能</h2>
                <p>> 转自：[使用 ASDK 性能调优 - 提升 iOS 界面的渲染性能](https://draveness.me/asdk-rendering) > 这一系列的文章会从几个方面对 [ASDK](http://asyncdisplaykit.org) 在性能调优方面策略的实现进行分析，帮助读者理解 ASDK 如何做到使复杂的 UI...</p>
            </section>
        </a>
    
    <!-- [[! /next_post ]] -->
    <!-- [[! prev_post ]] -->
    
        <a class="read-next-story prev " style="background-image: url(/reprinted/assets/images/cover2.jpg)" href="/reprinted/intercept">
            <section class="post">
                <h2>iOS 开发中使用 NSURLProtocol 拦截 HTTP 请求</h2>
                <p>转自：iOS 开发中使用 NSURLProtocol 拦截 HTTP 请求 这篇文章会提供一种在 Cocoa 层拦截所有 HTTP 请求的方法，其实标题已经说明了拦截 HTTP 请求需要的了解的就是 NSURLProtocol。 由于文章的内容较长，会分成两部分，这篇文章介绍...</p>
            </section>
        </a>
    
    <!-- [[! /prev_post ]] -->
</aside>

<!-- /post -->


        <!-- The tiny footer at the very bottom -->
        <footer class="site-footer clearfix">
          <section class="copyright"><a href="/reprinted/"></a> &copy; 2018</section>
          <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> using <a href="https://github.com/jekyller/jasper">Jasper</a></section>
        </footer>
    </div>
    <!-- highlight.js -->
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <!-- jQuery needs to come before `` so that jQuery can be used in code injection -->
    <script type="text/javascript" src="//code.jquery.com/jquery-1.12.0.min.js"></script>
    <!-- Ghost outputs important scripts and data with this tag -->
    <!--  -->
    <!-- Add Google Analytics  -->
        <!-- Google Analytics Tracking code -->
     <script>
	    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	    ga('create', 'UA-69281367-1', 'auto');
	    ga('send', 'pageview');

     </script>
    <!-- Fitvids makes video embeds responsive and awesome -->
    <script type="text/javascript" src="/reprinted/assets/js/jquery.fitvids.js"></script>
    <!-- The main JavaScript file for Casper -->
    <script type="text/javascript" src="/reprinted/assets/js/index.js"></script>

</body>
</html>
