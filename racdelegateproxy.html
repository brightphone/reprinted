<!DOCTYPE html>
<html>
<head>
    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Page Meta -->
    <title>从代理到 RACSignal</title>
    <meta name="description" content="" />

    <!-- Mobile Meta -->
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- Brand icon -->
    <link rel="shortcut icon" href="/reprinted/assets/images/favicon.ico" >

    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/reprinted/assets/css/screen.css" />
    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400" />
    <link rel="stylesheet" type="text/css" href="/reprinted/assets/css/syntax.css" />

    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/styles/default.min.css">
    <style>.hljs { background: none; }</style>

    <!-- Ghost outputs important style and meta data with this tag -->
        <link rel="canonical" href="/reprinted//racdelegateproxy" />
    <meta name="referrer" content="origin" />
    <link rel="next" href="/reprinted/page2/" />

    <meta property="og:site_name" content="" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="从代理到 RACSignal" />
    <meta property="og:description" content="" />
    <meta property="og:url" content="/reprinted//racdelegateproxy" />
    <meta property="og:image" content="/reprinted/assets/images/cover2.jpg" />

    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="从代理到 RACSignal" />
    <meta name="twitter:description" content="" />
    <meta name="twitter:url" content="/reprinted//racdelegateproxy" />
    <meta name="twitter:image:src" content="/reprinted/assets/images/cover2.jpg" />

    <script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "Website",
    "publisher": "",
    "name": "从代理到 RACSignal",
    "url": "/reprinted//racdelegateproxy",
    "image": "/reprinted/assets/images/cover2.jpg",
    "description": ""
}
    </script>

    <meta name="generator" content="Jekyll 3.0.0" />
    <link rel="alternate" type="application/rss+xml" title="" href="/reprinted/feed.xml" />


</head>
<body class="home-template nav-closed">

    <!-- The blog navigation links -->
    <div class="nav">
    <h3 class="nav-title">Menu</h3>
    <a href="#" class="nav-close">
        <span class="hidden">Close</span>
    </a>
    <ul>
        <li class="nav-home " role="presentation"><a href="/reprinted/">Home</a></li>
        <li class="nav-about " role="presentation"><a href="/reprinted/about">About</a></li>
        <li class="nav-ios " role="presentation"><a href="/reprinted/tag/ios">iOS</a></li>
        <li class="nav-objective-c " role="presentation"><a href="/reprinted/tag/objective-c">objective-c</a></li>
        <li class="nav-swift " role="presentation"><a href="/reprinted/tag/swift">Swift</a></li>
        <li class="nav-others " role="presentation"><a href="/reprinted/tag/others">others</a></li>
    </ul>
    <a class="subscribe-button icon-feed" href="/reprinted/feed.xml">Subscribe</a>
</div>
<span class="nav-cover"></span>


    <div class="site-wrapper">

        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- default -->

<!-- The comment above "< default" means - insert everything in this file into -->
    <!-- the [body] of the default.hbs template, which contains our header/footer. -->

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<header class="main-header post-head " style="background-image: url(/reprinted/assets/images/cover2.jpg) ">
    <nav class="main-nav  overlay  clearfix">
        <a class="blog-logo" href="/reprinted/"><img src="/reprinted/assets/images/ghost.png" alt="Blog Logo" /></a>
        
            <a class="menu-button icon-menu" href="#"><span class="word">Menu</span></a>
        
    </nav>
</header>

<main class="content" role="main">

    <article class="post tag-fiction">

        <header class="post-header">
            <h1 class="post-title">从代理到 RACSignal</h1>
            <section class="post-meta">
            <!-- <a href='/reprinted/'></a> -->

            
                
                    <a href='/reprinted/author/Draveness'>Draveness</a>
                
            
            <time class="post-date" datetime="2017-02-25">25 Feb 2017</time>
                <!-- [[tags prefix=" on "]] -->
                
                on
                
                    
                       <a href='/reprinted/tag/iOS'>iOS</a>,
                    
                
                    
                       <a href='/reprinted/tag/RAC'>RAC</a>
                    
                
                
            </section>
        </header>

        <section class="post-content">

            <blockquote>
  <p>转自：<a href="https://draveness.me/racdelegateproxy">从代理到 RACSignal</a></p>
</blockquote>

<p>ReactiveCocoa 将 Cocoa 中的 Target-Action、KVO、通知中心以及代理等设计模式都桥接到了 RAC 的世界中，我们在随后的几篇文章中会介绍 RAC 如何做到了上面的这些事情，而本篇文章会介绍 ReactiveCocoa 是如何把<strong>代理</strong>转换为信号的。</p>

<p><img src="https://img.draveness.me/2017-02-25-Delegate-To-RACSignal.png-1000width" alt="Delegate-To-RACSigna" /></p>

<h2 id="racdelegateproxy">RACDelegateProxy</h2>

<p>从代理转换成信号所需要的核心类就是 <code class="highlighter-rouge">RACDelegateProxy</code>，这是一个设计的非常巧妙的类；虽然在类的头文件中，它被标记为私有类，但是我们仍然可以使用 <code class="highlighter-rouge">-initWithProtocol:</code> 方法直接初始化该类的实例。</p>

<pre><code class="language-objectivec">- (instancetype)initWithProtocol:(Protocol *)protocol {
	self = [super init];
	class_addProtocol(self.class, protocol);
	_protocol = protocol;
	return self;
}
</code></pre>

<p>从初始化方法中，我们可以看出 <code class="highlighter-rouge">RACDelegateProxy</code> 是一个包含实例变量 <code class="highlighter-rouge">_protocol</code> 的类：</p>

<p><img src="https://img.draveness.me/2017-02-25-RACDelegateProxy.png-1000width" alt="RACDelegateProxy" /></p>

<p>在整个 <code class="highlighter-rouge">RACDelegateProxy</code> 类的实现中，你都不太能看出与这个实例变量 <code class="highlighter-rouge">_protocol</code> 的关系；稍微对 iOS 有了解的人可能都知道，在 Cocoa 中有一个非常特别的根类 <code class="highlighter-rouge">NSProxy</code>，而从它的名字我们也可以推断出来，<code class="highlighter-rouge">NSProxy</code> 一般用于实现代理（主要是对消息进行转发），但是 ReactiveCocoa 中这个 <code class="highlighter-rouge">delegate</code> 的代理 <code class="highlighter-rouge">RACDelegateProxy</code> 并没有继承这个 <code class="highlighter-rouge">NSProxy</code> 根类：</p>

<pre><code class="language-objectivec">@interface RACDelegateProxy : NSObject

@end
</code></pre>

<p>那么 <code class="highlighter-rouge">RACDelegateProxy</code> 是如何作为 Cocoa 中组件的代理，并为原生组件添加 <code class="highlighter-rouge">RACSignal</code> 的支持呢？我们以 <code class="highlighter-rouge">UITableView</code> 为例来展示 <code class="highlighter-rouge">RACDelegateProxy</code> 是如何与 UIKit 组件互动的，我们需要实现的是以下功能：</p>

<p><img src="https://img.draveness.me/2017-02-25-RACDelegateProxy-UITableView.gif" alt="RACDelegateProxy-UITableVie" /></p>

<p>在点击所有的 <code class="highlighter-rouge">UITableViewCell</code> 时都会自动取消点击状态，通常情况下，我们可以直接在代理方法 <code class="highlighter-rouge">-tableView:didSelectRowAtIndexPath:</code> 中执行 <code class="highlighter-rouge">-deselectRowAtIndexPath:animated:</code> 方法：</p>

<pre><code class="language-objectivec">- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath {
    [tableView deselectRowAtIndexPath:indexPath animated:YES];
}
</code></pre>

<p>使用信号的话相比而言就比较麻烦了：</p>

<pre><code class="language-objectivec">RACDelegateProxy *proxy = [[RACDelegateProxy alloc] initWithProtocol:@protocol(UITableViewDelegate)];
objc_setAssociatedObject(self, _cmd, proxy, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
proxy.rac_proxiedDelegate = self;
[[proxy rac_signalForSelector:@selector(tableView:didSelectRowAtIndexPath:)]
 subscribeNext:^(RACTuple *value) {
     [value.first deselectRowAtIndexPath:value.second animated:YES];
 }];
self.tableView.delegate = (id&lt;UITableViewDelegate&gt;)proxy;
</code></pre>

<ol>
  <li>初始化 <code class="highlighter-rouge">RACDelegateProxy</code> 实例，传入 <code class="highlighter-rouge">UITableViewDelegate</code> 协议，并将实例存入视图控制器以<strong>确保实例不会被意外释放</strong>造成崩溃；</li>
  <li>设置代理的 <code class="highlighter-rouge">rac_proxiedDelegate</code> 属性为视图控制器；</li>
  <li>使用 <code class="highlighter-rouge">-rac_signalForSelector:</code> 方法生成一个 <code class="highlighter-rouge">RACSignal</code>，在 <code class="highlighter-rouge">-tableView:didSelectRowAtIndexPath:</code> 方法调用时将方法的参数打包成 <code class="highlighter-rouge">RACTuple</code> 向信号中发送新的 <code class="highlighter-rouge">next</code> 消息；</li>
  <li>重新设置 <code class="highlighter-rouge">UITableView</code> 的代理；</li>
</ol>

<p>在 <code class="highlighter-rouge">UITableViewDelgate</code> 中的代理方法执行时，实际上会被 <code class="highlighter-rouge">RACDelegateProxy</code> 拦截，并根据情况决定是处理还是转发：</p>

<p><img src="https://img.draveness.me/2017-02-25-UITableViewDelegate-With-RACDelegateProxy.png-1000width" alt="UITableViewDelegate-With-RACDelegateProxy" /></p>

<p>如果 <code class="highlighter-rouge">RACDelegateProxy</code> 实现了该代理方法就会交给它处理，如：<code class="highlighter-rouge">-tableView:didSelectRowAtIndexPath:</code>；否则，当前方法就会被转发到原 <code class="highlighter-rouge">delegate</code> 上，在这里就是 <code class="highlighter-rouge">UIViewController</code> 对象。</p>

<p><code class="highlighter-rouge">RACDelegateProxy</code> 中有两个值得特别注意的问题，一是 <code class="highlighter-rouge">RACDelegateProxy</code> 是如何进行消息转发的，有事如何将自己无法实现的消息交由原代理处理，第二是 <code class="highlighter-rouge">RACDelegateProxy</code> 如何通过方法 <code class="highlighter-rouge">-rac_signalForSelector:</code> 在原方法调用时以 <code class="highlighter-rouge">RACTuple</code> 的方式发送到 <code class="highlighter-rouge">RACSignal</code> 上。</p>

<h2 id="消息转发的实现">消息转发的实现</h2>

<p>首先，我们来看 <code class="highlighter-rouge">RACDelegateProxy</code> 是如何在无法响应方法时，将方法转发给原有的代理的；<code class="highlighter-rouge">RACDelegateProxy</code> 通过覆写几个方法来实现，最关键的就是 <code class="highlighter-rouge">-forwardInvocation:</code> 方法：</p>

<pre><code class="language-objectivec">- (void)forwardInvocation:(NSInvocation *)invocation {
	[invocation invokeWithTarget:self.rac_proxiedDelegate];
}
</code></pre>

<p>当然，作为消息转发流程的一部分 <code class="highlighter-rouge">-methodSignatureForSelector:</code> 方法也需要在 <code class="highlighter-rouge">RACDelegateProxy</code> 对象中实现：</p>

<pre><code class="language-objectivec">- (NSMethodSignature *)methodSignatureForSelector:(SEL)selector {
	struct objc_method_description methodDescription = protocol_getMethodDescription(_protocol, selector, NO, YES);
	if (methodDescription.name == NULL) {
		methodDescription = protocol_getMethodDescription(_protocol, selector, YES, YES);
		if (methodDescription.name == NULL) return [super methodSignatureForSelector:selector];
	}
	return [NSMethodSignature signatureWithObjCTypes:methodDescription.types];
}
</code></pre>

<p>我们会从协议的方法中尝试获取其中的可选方法和必须实现的方法，最终获取方法的签名 <code class="highlighter-rouge">NSMethodSignature</code> 对象。</p>

<p>整个方法决议和消息转发的过程如下图所示，在整个方法决议和消息转发的过程中 Objective-C 运行时会再次提供执行该方法的机会。</p>

<p><img src="https://img.draveness.me/2017-02-25-Message-Forwarding.png-1000width" alt="Message-Forwarding" /></p>

<p>例子中的代理方法最后也被 <code class="highlighter-rouge">-forwardInvocation:</code> 方法成功的转发到了 <code class="highlighter-rouge">UITableView</code> 的原代理上。</p>

<h2 id="从代理到信号">从代理到信号</h2>

<p>在 <code class="highlighter-rouge">RACDelegateProxy</code> 中的另一个非常神奇的方法就是将某一个代理方法转换成信号的 <code class="highlighter-rouge">-signalForSelector:</code>：</p>

<pre><code class="language-objectivec">- (RACSignal *)signalForSelector:(SEL)selector {
	return [self rac_signalForSelector:selector fromProtocol:_protocol];
}

- (RACSignal *)rac_signalForSelector:(SEL)selector fromProtocol:(Protocol *)protocol {
	return NSObjectRACSignalForSelector(self, selector, protocol);
}
</code></pre>

<p>该方法会在传入的协议方法被调用时，将协议方法中的所有参数以 <code class="highlighter-rouge">RACTuple</code> 的形式发送到返回的信号上，使用者可以通过订阅这个信号来获取所有的参数；而方法 <code class="highlighter-rouge">NSObjectRACSignalForSelector</code> 的实现还是比较复杂的。</p>

<pre><code class="language-objectivec">static RACSignal *NSObjectRACSignalForSelector(NSObject *self, SEL selector, Protocol *protocol) {
	SEL aliasSelector = RACAliasForSelector(selector);

    RACSubject *subject = objc_getAssociatedObject(self, aliasSelector);
    if (subject != nil) return subject;

    Class class = RACSwizzleClass(self);
    subject = [RACSubject subject];
    objc_setAssociatedObject(self, aliasSelector, subject, OBJC_ASSOCIATION_RETAIN);

    Method targetMethod = class_getInstanceMethod(class, selector);
    if (targetMethod == NULL) {
        const char *typeEncoding;
        if (protocol == NULL) {
            typeEncoding = RACSignatureForUndefinedSelector(selector);
        } else {
            struct objc_method_description methodDescription = protocol_getMethodDescription(protocol, selector, NO, YES);
            if (methodDescription.name == NULL) {
                methodDescription = protocol_getMethodDescription(protocol, selector, YES, YES);
            }
            typeEncoding = methodDescription.types;
        }
        class_addMethod(class, selector, _objc_msgForward, typeEncoding);
    } else if (method_getImplementation(targetMethod) != _objc_msgForward) {
        const char *typeEncoding = method_getTypeEncoding(targetMethod);

        class_addMethod(class, aliasSelector, method_getImplementation(targetMethod), typeEncoding);
        class_replaceMethod(class, selector, _objc_msgForward, method_getTypeEncoding(targetMethod));
    }
    return subject;
}
</code></pre>

<p>这个 C 函数总共做了两件非常重要的事情，第一个是将传入的选择子对应的实现变为 <code class="highlighter-rouge">_objc_msgForward</code>，也就是在调用该方法时，会直接进入消息转发流程，第二是用 <code class="highlighter-rouge">RACSwizzleClass</code> 调剂当前类的一些方法。</p>

<p><img src="https://img.draveness.me/2017-02-25-NSObjectRACSignalForSelector.png-1000width" alt="NSObjectRACSignalForSelecto" /></p>

<h3 id="从-selector-到-_objc_msgforward">从 selector 到 _objc_msgForward</h3>

<p>我们具体看一下这部分代码是如何实现的，在修改选择子对应的实现之前，我们会先做一些准备工作：</p>

<pre><code class="language-objectivec">SEL aliasSelector = RACAliasForSelector(selector);

RACSubject *subject = objc_getAssociatedObject(self, aliasSelector);
if (subject != nil) return subject;

Class class = RACSwizzleClass(self);

subject = [RACSubject subject];
objc_setAssociatedObject(self, aliasSelector, subject, OBJC_ASSOCIATION_RETAIN);

Method targetMethod = class_getInstanceMethod(class, selector);
</code></pre>

<ol>
  <li>获取选择子的别名，在这里我们通过为选择子加前缀 <code class="highlighter-rouge">rac_alias_</code> 来实现；</li>
  <li>尝试以 <code class="highlighter-rouge">rac_alias_selector</code> 为键获取一个热信号 <code class="highlighter-rouge">RACSubject</code>；</li>
  <li>使用 <code class="highlighter-rouge">RACSwizzleClass</code> 调剂当前类的一些方法（我们会在下一节中介绍）；</li>
  <li>从当前类中获取目标方法的结构体 <code class="highlighter-rouge">targetMethod</code>；</li>
</ol>

<p>在进行了以上的准备工作之后，我们就开始修改选择子对应的实现了，整个的修改过程会分为三种情况：</p>

<p><img src="https://img.draveness.me/2017-02-25-Swizzle-objc_msgForward.png-1000width" alt="Swizzle-objc_msgForward" /></p>

<p>下面会按照这三种情况依次介绍在不同情况下，如何将对应选择子的实现改为 <code class="highlighter-rouge">_objc_msgForward</code> 完成消息转发的。</p>

<h4 id="targetmethod--null--protocol--null">targetMethod == NULL &amp;&amp; protocol == NULL</h4>

<p>在找不到选择子对应的方法并且没有传入协议时，这时执行的代码最为简单：</p>

<pre><code class="language-objectivec">typeEncoding = RACSignatureForUndefinedSelector(selector);
class_addMethod(class, selector, _objc_msgForward, typeEncoding);
</code></pre>

<p>我们会通过 <code class="highlighter-rouge">RACSignatureForUndefinedSelector</code> 生成一个当前方法默认的类型编码。</p>

<blockquote>
  <p>对类型编码不了解的可以阅读苹果的官方文档 <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html">Type Encodings · Apple Developer</a>，其中详细解释了类型编码是什么，它在整个 Objective-C 运行时有什么作用。</p>
</blockquote>

<pre><code class="language-objectivec">static const char *RACSignatureForUndefinedSelector(SEL selector) {
	const char *name = sel_getName(selector);
	NSMutableString *signature = [NSMutableString stringWithString:@"v@:"];

	while ((name = strchr(name, ':')) != NULL) {
		[signature appendString:@"@"];
		name++;
	}

	return signature.UTF8String;
}
</code></pre>

<p>该方法在生成类型编码时，会按照 <code class="highlighter-rouge">:</code> 的个数来为 <code class="highlighter-rouge">v@:</code> 这个类型编码添加 <code class="highlighter-rouge">@</code> 字符；简单说明一下它的意思，ReactiveCocoa 默认所有的方法的返回值类型都为空 <code class="highlighter-rouge">void</code>，都会传入 <code class="highlighter-rouge">self</code> 以及当前方法的选择子 <code class="highlighter-rouge">SEL</code>，它们的类型编码可以在下图中找到，分别是 <code class="highlighter-rouge">v@:</code>；而 <code class="highlighter-rouge">@</code> 代表 <code class="highlighter-rouge">id</code> 类型，也就是我们默认代理方法中的所有参数都是 <code class="highlighter-rouge">NSObject</code> 类型的。</p>

<p><img src="https://img.draveness.me/2017-02-25-TypeEncoding.png-1000width" alt="TypeEncoding" /></p>

<p>生成了类型编码之后，由于我们并没有在当前类中找到该选择子对应的方法，所以会使用 <code class="highlighter-rouge">class_addMethod</code> 为当前类提供一个方法的实现，直接将当前选择子的实现改为 <code class="highlighter-rouge">_objc_msgForward</code>。</p>

<p><img src="https://img.draveness.me/2017-02-25-Selector-To-ObjC-Message-Forward.png-1000width" alt="Selector-To-ObjC-Message-Forward" /></p>

<h4 id="targetmethod--null--protocol--null-1">targetMethod == NULL &amp;&amp; protocol != NULL</h4>

<p>当类中不存在当前选择子对应的方法 <code class="highlighter-rouge">targetMethod</code>，但是向当前函数中传入了协议时，我们会尝试从协议中获取方法描述：</p>

<pre><code class="language-objectivec">struct objc_method_description methodDescription = protocol_getMethodDescription(protocol, selector, NO, YES);

if (methodDescription.name == NULL) {
    methodDescription = protocol_getMethodDescription(protocol, selector, YES, YES);
}
typeEncoding = methodDescription.types;
class_addMethod(class, selector, _objc_msgForward, typeEncoding);
</code></pre>

<p>这里会使用 <code class="highlighter-rouge">protocol_getMethodDescription</code> 两次从协议中获取可选和必须实现的方法的描述，并从结构体中拿出类型编码，最后为类添加这个之前不存在的方法：</p>

<p><img src="https://img.draveness.me/2017-02-25-Selector-To-ObjC-Message-Forward.png-1000width" alt="Selector-To-ObjC-Message-Forward" /></p>

<p>在这种情况下，其最后的结果与上一种的完全相同，因为它们都是对不存在该方法，只需要获得方法的类型编码并将实现添加为 <code class="highlighter-rouge">_objc_msgForward</code>，交给消息转发流程进行处理即可。</p>

<h4 id="targetmethod--null">targetMethod != NULL</h4>

<p>在目标方法的实现不为空并且它的实现并不是 <code class="highlighter-rouge">_objc_msgForward</code> 时，我们就会进入以下流程修改原有方法的实现：</p>

<pre><code class="language-objectivec">const char *typeEncoding = method_getTypeEncoding(targetMethod);

class_addMethod(class, aliasSelector, method_getImplementation(targetMethod), typeEncoding);
class_replaceMethod(class, selector, _objc_msgForward, method_getTypeEncoding(targetMethod));
</code></pre>

<p>同样，我们需要获得目标方法的方法签名、添加 <code class="highlighter-rouge">aliasSelector</code> 这个新方法，最后在修改原方法的实现到 <code class="highlighter-rouge">_objc_msgForward</code>。</p>

<p><img src="https://img.draveness.me/2017-02-25-Selector-To-ObjC-Message-Forward-With-RACSelector.png-1000width" alt="Selector-To-ObjC-Message-Forward-With-RACSelecto" /></p>

<p>上图展示了在目标方法不为空并且其实现不为 <code class="highlighter-rouge">_objc_msgForward</code> 时，<code class="highlighter-rouge">NSObjectRACSignalForSelector</code> 是如何修改原方法实现的。</p>

<h3 id="调剂类的方法">调剂类的方法</h3>

<p><code class="highlighter-rouge">NSObjectRACSignalForSelector</code> 在修改原选择子方法实现的之前就已经修改了当前类很多方法的实现：</p>

<ul>
  <li><code class="highlighter-rouge">-methodSignatureForSelector:</code></li>
  <li><code class="highlighter-rouge">-class</code></li>
  <li><code class="highlighter-rouge">-respondsToSelector</code></li>
  <li><code class="highlighter-rouge">-forwardInvocation:</code></li>
</ul>

<p>整个调剂方法的过程 <code class="highlighter-rouge">RACSwizzleClass</code> 还是比较复杂的，我们可以分三部分看下面的代码：</p>

<pre><code class="language-objectivec">static Class RACSwizzleClass(NSObject *self) {
	Class statedClass = self.class;
	Class baseClass = object_getClass(self);

	NSString *className = NSStringFromClass(baseClass);
	const char *subclassName = [className stringByAppendingString:RACSubclassSuffix].UTF8String;
	Class subclass = objc_getClass(subclassName);

	if (subclass == nil) {
		subclass = objc_allocateClassPair(baseClass, subclassName, 0);
		if (subclass == nil) return nil;

		RACSwizzleForwardInvocation(subclass);
		RACSwizzleRespondsToSelector(subclass);
		RACSwizzleGetClass(subclass, statedClass);
		RACSwizzleGetClass(object_getClass(subclass), statedClass);
		RACSwizzleMethodSignatureForSelector(subclass);

		objc_registerClassPair(subclass);
	}
	object_setClass(self, subclass);
	return subclass;
}
</code></pre>

<ol>
  <li>从当前类 <code class="highlighter-rouge">RACDelegateProxy</code> 衍生出一个子类 <code class="highlighter-rouge">RACDelegateProxy_RACSelectorSignal</code>；</li>
  <li>调用各种 <code class="highlighter-rouge">RACSwizzleXXX</code> 方法修改当前子类的一些表现；</li>
  <li>将 <code class="highlighter-rouge">RACDelegateProxy</code> 对象的类设置成自己，这样就会在查找方法时，找到 <code class="highlighter-rouge">RACDelegateProxy_RACSelectorSignal</code> 中的实现；</li>
</ol>

<p>在修改的几个方法中最重要的就是 <code class="highlighter-rouge">-forwardInvocation:</code>：</p>

<pre><code class="language-objectivec">static void RACSwizzleForwardInvocation(Class class) {
	SEL forwardInvocationSEL = @selector(forwardInvocation:);
	Method forwardInvocationMethod = class_getInstanceMethod(class, forwardInvocationSEL);

	void (*originalForwardInvocation)(id, SEL, NSInvocation *) = NULL;
	if (forwardInvocationMethod != NULL) {
		originalForwardInvocation = (__typeof__(originalForwardInvocation))method_getImplementation(forwardInvocationMethod);
	}

	id newForwardInvocation = ^(id self, NSInvocation *invocation) {
		BOOL matched = RACForwardInvocation(self, invocation);
		if (matched) return;

		if (originalForwardInvocation == NULL) {
			[self doesNotRecognizeSelector:invocation.selector];
		} else {
			originalForwardInvocation(self, forwardInvocationSEL, invocation);
		}
	};

	class_replaceMethod(class, forwardInvocationSEL, imp_implementationWithBlock(newForwardInvocation), "v@:@");
}
</code></pre>

<p>这个方法中大部分的内容都是平淡无奇的，在新的 <code class="highlighter-rouge">-forwardInvocation:</code> 方法中，执行的 <code class="highlighter-rouge">RACForwardInvocation</code> 是实现整个消息转发的关键内容：</p>

<pre><code class="language-objectivec">static BOOL RACForwardInvocation(id self, NSInvocation *invocation) {
	SEL aliasSelector = RACAliasForSelector(invocation.selector);
	RACSubject *subject = objc_getAssociatedObject(self, aliasSelector);

	Class class = object_getClass(invocation.target);
	BOOL respondsToAlias = [class instancesRespondToSelector:aliasSelector];
	if (respondsToAlias) {
		invocation.selector = aliasSelector;
		[invocation invoke];
	}

	if (subject == nil) return respondsToAlias;

	[subject sendNext:invocation.rac_argumentsTuple];
	return YES;
}
</code></pre>

<p>在 <code class="highlighter-rouge">-rac_signalForSelector:</code> 方法返回的 <code class="highlighter-rouge">RACSignal</code> 上接收到的参数信号，就是从这个方法发送过去的，新的实现 <code class="highlighter-rouge">RACForwardInvocation</code> 改变了原有的 <code class="highlighter-rouge">selector</code> 到 <code class="highlighter-rouge">aliasSelector</code>，然后使用 <code class="highlighter-rouge">-invoke</code> 完成该调用，而所有的参数会以 <code class="highlighter-rouge">RACTuple</code> 的方式发送到信号上。</p>

<p>像其他的方法 <code class="highlighter-rouge">-respondToSelector:</code> 等等，它们的实现就没有这么复杂并且重要了：</p>

<pre><code class="language-objectivec">id newRespondsToSelector = ^ BOOL (id self, SEL selector) {
    Method method = rac_getImmediateInstanceMethod(class, selector);

    if (method != NULL &amp;&amp; method_getImplementation(method) == _objc_msgForward) {
        SEL aliasSelector = RACAliasForSelector(selector);
        if (objc_getAssociatedObject(self, aliasSelector) != nil) return YES;
    }

    return originalRespondsToSelector(self, respondsToSelectorSEL, selector);
};
</code></pre>

<p><code class="highlighter-rouge">rac_getImmediateInstanceMethod</code> 从当前类获得方法的列表，并从中找到与当前 <code class="highlighter-rouge">selector</code> 同名的方法 <code class="highlighter-rouge">aliasSelector</code>，然后根据不同情况判断方法是否存在。</p>

<p>对 <code class="highlighter-rouge">class</code> 的修改，是为了让对象对自己的身份『说谎』，因为我们子类化了 <code class="highlighter-rouge">RACDelegateProxy</code>，并且重新设置了对象的类，将所有的方法都转发到了这个子类上，如果不修改 <code class="highlighter-rouge">class</code> 方法，那么当开发者使用它自省时就会得到错误的类，而这是我们不希望看到的。</p>

<pre><code class="language-objectivec">static void RACSwizzleGetClass(Class class, Class statedClass) {
	SEL selector = @selector(class);
	Method method = class_getInstanceMethod(class, selector);
	IMP newIMP = imp_implementationWithBlock(^(id self) {
		return statedClass;
	});
	class_replaceMethod(class, selector, newIMP, method_getTypeEncoding(method));
}
</code></pre>

<p>在最后我们会对获得方法签名的 <code class="highlighter-rouge">-methodSignatureForSelector:</code> 方法进行修改：</p>

<pre><code class="language-objectivec">IMP newIMP = imp_implementationWithBlock(^(id self, SEL selector) {
    Class actualClass = object_getClass(self);
    Method method = class_getInstanceMethod(actualClass, selector);
    if (method == NULL) {
        struct objc_super target = {
            .super_class = class_getSuperclass(class),
            .receiver = self,
        };
        NSMethodSignature * (*messageSend)(struct objc_super *, SEL, SEL) = (__typeof__(messageSend))objc_msgSendSuper;
        return messageSend(&amp;target, @selector(methodSignatureForSelector:), selector);
    }

    char const *encoding = method_getTypeEncoding(method);
    return [NSMethodSignature signatureWithObjCTypes:encoding];
});
</code></pre>

<p>在方法不存在时，通过 <code class="highlighter-rouge">objc_msgSendSuper</code> 调用父类的 <code class="highlighter-rouge">-methodSignatureForSelector:</code> 方法获取方法签名。</p>

<h2 id="方法调用的过程">方法调用的过程</h2>

<p>在一般情况下，Objective-C 中某一消息被发送到一个对象时，它会先获取当前对象对应的类，然后从类的选择子表查找该方法对应的实现并执行。</p>

<p><img src="https://img.draveness.me/2017-02-25-Selector-To-IMP.png-1000width" alt="Selector-To-IMP" /></p>

<p>与正常的方法实现查找以及执行过程的简单不同，如果我们对某一个方法调用了 <code class="highlighter-rouge">-rac_signalForSelector:</code> 方法，那么对于同一个对象对应的类的所有方法，它们的执行过程会变得非常复杂：</p>

<p><img src="https://img.draveness.me/2017-02-25-After-Call-RACSignalForSelector.png-1000width" alt="After-Call-RACSignalForSelecto" /></p>

<ol>
  <li>由于当前对象对应的类已经被改成了 <code class="highlighter-rouge">Subclass</code>，即 <code class="highlighter-rouge">Class_RACSelectorSignal</code>，所以会在子类中查找方法的实现；</li>
  <li>方法对应的实现已经被改成了 <code class="highlighter-rouge">-forwardInvocation:</code>，会直接进入消息转发流程中处理；</li>
  <li>根据传入的选择子获取同名选择子 <code class="highlighter-rouge">rac_alias_selector</code>；</li>
  <li>拿到当前 <code class="highlighter-rouge">NSInvocation</code> 对象中 <code class="highlighter-rouge">target</code> 的类，判断是否可以响应该选择子；</li>
  <li>将 <code class="highlighter-rouge">NSInvocation</code> 对象中的选择子改为 <code class="highlighter-rouge">rac_alias_selector</code> 并执行其实现；</li>
  <li>从 <code class="highlighter-rouge">NSInvocation</code> 对象中获取参数并打包成 <code class="highlighter-rouge">RACTuple</code>，以 <code class="highlighter-rouge">next</code> 消息的形式发送到持有的 <code class="highlighter-rouge">RACSubject</code> 热信号上；</li>
</ol>

<p>这时所有的订阅者才会在该方法被调用时收到消息，完成相应的任务。</p>

<h2 id="总结">总结</h2>

<p>ReactiveCocoa 使用了一种非常神奇的办法把原有的代理模式成功的桥接到 <code class="highlighter-rouge">RACSignal</code> 的世界中，并为我们提供了 <code class="highlighter-rouge">RACDelegateProxy</code> 这一接口，能够帮助我们以信号的形式监听所有的代理方法，可以用 block 的形式去代替原有的方法，为我们减少一些工作量。</p>

<h2 id="references">References</h2>

<ul>
  <li><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html">Type Encodings · Apple Developer</a></li>
</ul>

<blockquote>
  <p>Github Repo：<a href="https://github.com/draveness/iOS-Source-Code-Analyze">iOS-Source-Code-Analyze</a></p>

</blockquote>

<blockquote>

  <p>Source: http://draveness.me/racdelegateproxy</p>
</blockquote>


        </section>

        <footer class="post-footer">

            <!-- Everything inside the #author tags pulls data from the author -->
            <!-- #author-->
            
                
                    
                        <figure class="author-image">
                            <a class="img" href="/reprinted/author/Draveness" style="background-image: url(/reprinted/assets/images/draven.png)"><span class="hidden">Draveness's Picture</span></a>
                        </figure>
                    

                    <section class="author">
                        <h4><a href="/reprinted/author/Draveness">Draveness</a></h4>

                        
                            <p>Read <a href="/reprinted/author/Draveness">more posts</a> by this author.</p>
                        
                        <div class="author-meta">
                            <span class="author-location icon-location"> Beijing, China</span>
                            <span class="author-link icon-link"><a href="https://draveness.me/index"> draveness.me/index</a></span>
                        </div>
                    </section>

                    <!-- /author  -->

                    <section class="share">
                        <h4>Share this post</h4>
                        <a class="icon-twitter" href="http://twitter.com/share?text=从代理到 RACSignal&amp;url=racdelegateproxy"
                            onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
                            <span class="hidden">Twitter</span>
                        </a>
                        <a class="icon-facebook" href="https://www.facebook.com/sharer/sharer.php?u=racdelegateproxy"
                            onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
                            <span class="hidden">Facebook</span>
                        </a>
                        <a class="icon-google-plus" href="https://plus.google.com/share?url=racdelegateproxy"
                           onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
                            <span class="hidden">Google+</span>
                        </a>
                    </section>
                
            
            <!-- Add Disqus Comments -->
            

        </footer>

    </article>

</main>
<aside class="read-next">

    <!-- [[! next_post ]] -->
    
        <a class="read-next-story " style="background-image: url(/reprinted/assets/images/cover2.jpg)" href="/reprinted/kvocontroller">
            <section class="post">
                <h2>如何优雅地使用 KVO</h2>
                <p>> 转自：[如何优雅地使用 KVO](https://draveness.me/kvocontroller) KVO 作为 iOS 中一种强大并且有效的机制，为 iOS 开发者们提供了很多的便利；我们可以使用 KVO 来检测对象属性的变化、快速做出响应，这能够为我们在开发强交互、响应式应用以及实现视图和模型的双向绑定时提供大量的帮助。 但是在大多数情况下，除非遇到不用 KVO 无法解决的问题，笔者都会尽量避免它的使用，这并不是因为 KVO...</p>
            </section>
        </a>
    
    <!-- [[! /next_post ]] -->
    <!-- [[! prev_post ]] -->
    
        <a class="read-next-story prev " style="background-image: url(/reprinted/assets/images/cover2.jpg)" href="/reprinted/racscheduler">
            <section class="post">
                <h2>理解 RACScheduler 的实现</h2>
                <p>转自：理解 RACScheduler 的实现 RACScheduler 是一个线性执行队列，ReactiveCocoa 中的信号可以在 RACScheduler 上执行任务、发送结果；它的实现并不复杂，由多个简单的方法和类组成整个 RACScheduler 模块，是整个 ReactiveCocoa 中非常易于理解的部分。 RACScheduler 简介 RACScheduler...</p>
            </section>
        </a>
    
    <!-- [[! /prev_post ]] -->
</aside>

<!-- /post -->


        <!-- The tiny footer at the very bottom -->
        <footer class="site-footer clearfix">
          <section class="copyright"><a href="/reprinted/"></a> &copy; 2018</section>
          <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> using <a href="https://github.com/jekyller/jasper">Jasper</a></section>
        </footer>
    </div>
    <!-- highlight.js -->
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <!-- jQuery needs to come before `` so that jQuery can be used in code injection -->
    <script type="text/javascript" src="//code.jquery.com/jquery-1.12.0.min.js"></script>
    <!-- Ghost outputs important scripts and data with this tag -->
    <!--  -->
    <!-- Add Google Analytics  -->
        <!-- Google Analytics Tracking code -->
     <script>
	    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	    ga('create', 'UA-69281367-1', 'auto');
	    ga('send', 'pageview');

     </script>
    <!-- Fitvids makes video embeds responsive and awesome -->
    <script type="text/javascript" src="/reprinted/assets/js/jquery.fitvids.js"></script>
    <!-- The main JavaScript file for Casper -->
    <script type="text/javascript" src="/reprinted/assets/js/index.js"></script>

</body>
</html>
