<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>brightphone.github.io/reprinted/</title>
   
   <link></link>
   <description></description>
   <language>en-uk</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>深入解析 ObjC 中方法的结构</title>
	  <link>/reprinted//method-struct</link>
	  <author></author>
	  <pubDate>2016-04-23T05:26:37+00:00</pubDate>
	  <guid>/reprinted//method-struct</guid>
	  <description><![CDATA[
	     <p>Blog: <a href="http://draveness.me">Draveness</a></p>

<blockquote>
  <p>关注仓库，及时获得更新：<a href="https://github.com/draveness/iOS-Source-Code-Analyze">iOS-Source-Code-Analyze</a></p>
</blockquote>

<blockquote>
  <p>因为 ObjC 的 runtime 只能在 Mac OS 下才能编译，所以文章中的代码都是在 Mac OS，也就是 <code class="highlighter-rouge">x86_64</code> 架构下运行的，对于在 arm64 中运行的代码会特别说明。</p>
</blockquote>

<p>在上一篇分析 <code class="highlighter-rouge">isa</code> 的文章<a href="https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/objc/从%20NSObject%20的初始化了解%20isa.md">从 NSObject 的初始化了解 isa</a>中曾经说到过实例方法被调用时，会通过其持有 <code class="highlighter-rouge">isa</code> 指针寻找对应的类，然后在其中的 <code class="highlighter-rouge">class_data_bits_t</code> 中查找对应的方法，在这一篇文章中会介绍方法在 ObjC 中是如何存储方法的。</p>

<p>这篇文章的首先会根据 ObjC 源代码来分析方法在内存中的存储结构，然后在 lldb 调试器中一步一步验证分析的正确性。</p>

<h2 id="方法在内存中的位置">方法在内存中的位置</h2>

<p>先来了解一下 ObjC 中类的结构图：</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-23-objc-method-class.png" alt="objc-method-class" /></p>

<ul>
  <li><code class="highlighter-rouge">isa</code> 是指向元类的指针，不了解元类的可以看 <a href="http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html">Classes and Metaclasses</a></li>
  <li><code class="highlighter-rouge">super_class</code> 指向当前类的父类</li>
  <li><code class="highlighter-rouge">cache</code> 用于缓存指针和 <code class="highlighter-rouge">vtable</code>，加速方法的调用</li>
  <li><code class="highlighter-rouge">bits</code> 就是存储类的方法、属性、遵循的协议等信息的地方</li>
</ul>

<h3 id="class_data_bits_t-结构体"><code class="highlighter-rouge">class_data_bits_t</code> 结构体</h3>

<p>这一小结会分析类结构体中的 <code class="highlighter-rouge">class_data_bits_t bits</code>。</p>

<p>下面就是 ObjC 中 <code class="highlighter-rouge">class_data_bits_t</code> 的结构体，其中只含有一个 64 位的 <code class="highlighter-rouge">bits</code> 用于存储与类有关的信息：</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-23-objc-method-class-data-bits-t.png" alt="objc-method-class-data-bits-t" /></p>

<p>在 <code class="highlighter-rouge">objc_class</code> 结构体中的注释写到 <code class="highlighter-rouge">class_data_bits_t</code> 相当于 <code class="highlighter-rouge">class_rw_t</code> 指针加上 rr/alloc 的标志。</p>

<pre><code class="language-objectivec">class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags
</code></pre>

<p>它为我们提供了便捷方法用于返回其中的 <code class="highlighter-rouge">class_rw_t *</code> 指针：</p>

<pre><code class="language-objectivec">class_rw_t* data() {
   return (class_rw_t *)(bits &amp; FAST_DATA_MASK);
}
</code></pre>

<p>将 <code class="highlighter-rouge">bits</code> 与 <code class="highlighter-rouge">FAST_DATA_MASK</code> 进行位运算，只取其中的 <code class="highlighter-rouge">[3, 47]</code> 位转换成 <code class="highlighter-rouge">class_rw_t *</code> 返回。</p>

<blockquote>
  <p>在 x86_64 架构上，Mac OS <strong>只使用了其中的 47 位来为对象分配地址</strong>。而且由于地址要按字节在内存中按字节对齐，所以掩码的后三位都是 0。</p>
</blockquote>

<p>因为 <code class="highlighter-rouge">class_rw_t *</code> 指针只存于第 <code class="highlighter-rouge">[3, 47]</code> 位，所以可以使用最后三位来存储关于当前类的其他信息：</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-23-objc-method-class_data_bits_t.png" alt="objc-method-class_data_bits_t" /></p>

<pre><code class="language-objectivec">#define FAST_IS_SWIFT           (1UL&lt;&lt;0)
#define FAST_HAS_DEFAULT_RR     (1UL&lt;&lt;1)
#define FAST_REQUIRES_RAW_ISA   (1UL&lt;&lt;2)
#define FAST_DATA_MASK          0x00007ffffffffff8UL
</code></pre>

<ul>
  <li><code class="highlighter-rouge">isSwift()</code>
    <ul>
      <li><code class="highlighter-rouge">FAST_IS_SWIFT</code> 用于判断 Swift 类</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">hasDefaultRR()</code>
    <ul>
      <li><code class="highlighter-rouge">FAST_HAS_DEFAULT_RR</code> 当前类或者父类含有默认的 <code class="highlighter-rouge">retain/release/autorelease/retainCount/_tryRetain/_isDeallocating/retainWeakReference/allowsWeakReference</code> 方法</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">requiresRawIsa()</code>
    <ul>
      <li><code class="highlighter-rouge">FAST_REQUIRES_RAW_ISA</code> 当前类的实例需要 raw <code class="highlighter-rouge">isa</code></li>
    </ul>
  </li>
</ul>

<p>执行 <code class="highlighter-rouge">class_data_bits_t</code> 结构体中的 <code class="highlighter-rouge">data()</code> 方法或者调用 <code class="highlighter-rouge">objc_class</code> 中的 <code class="highlighter-rouge">data()</code> 方法会返回同一个 <code class="highlighter-rouge">class_rw_t *</code> 指针，因为 <code class="highlighter-rouge">objc_class</code> 中的方法只是对 <code class="highlighter-rouge">class_data_bits_t</code> 中对应方法的封装。</p>

<pre><code class="language-objectivec">// objc_class 中的 data() 方法
class_data_bits_t bits;

class_rw_t *data() {
   return bits.data();
}

// class_data_bits_t 中的 data() 方法
uintptr_t bits;

class_rw_t* data() {
   return (class_rw_t *)(bits &amp; FAST_DATA_MASK);
}
</code></pre>

<h3 id="class_rw_t-和-class_ro_t"><code class="highlighter-rouge">class_rw_t</code> 和 <code class="highlighter-rouge">class_ro_t</code></h3>

<p>ObjC 类中的属性、方法还有遵循的协议等信息都保存在 <code class="highlighter-rouge">class_rw_t</code> 中：</p>

<pre><code class="language-objectivec">struct class_rw_t {
    uint32_t flags;
    uint32_t version;

    const class_ro_t *ro;

    method_array_t methods;
    property_array_t properties;
    protocol_array_t protocols;

    Class firstSubclass;
    Class nextSiblingClass;
};
</code></pre>

<p>其中还有一个指向常量的指针 <code class="highlighter-rouge">ro</code>，其中存储了<strong>当前类在编译期就已经确定的属性、方法以及遵循的协议</strong>。</p>

<pre><code class="language-objectivec">struct class_ro_t {
    uint32_t flags;
    uint32_t instanceStart;
    uint32_t instanceSize;
    uint32_t reserved;

    const uint8_t * ivarLayout;

    const char * name;
    method_list_t * baseMethodList;
    protocol_list_t * baseProtocols;
    const ivar_list_t * ivars;

    const uint8_t * weakIvarLayout;
    property_list_t *baseProperties;
};
</code></pre>

<p><strong>在编译期间</strong>类的结构中的 <code class="highlighter-rouge">class_data_bits_t *data</code> 指向的是一个 <code class="highlighter-rouge">class_ro_t *</code> 指针：</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-23-objc-method-before-realize.png" alt="objc-method-before-realize" /></p>

<p>然后在加载 <em>ObjC 运行时</em>的过程中在 <code class="highlighter-rouge">realizeClass</code> 方法中：</p>

<ol>
  <li>从 <code class="highlighter-rouge">class_data_bits_t</code> 调用 <code class="highlighter-rouge">data</code> 方法，将结果从 <code class="highlighter-rouge">class_rw_t</code> 强制转换为 <code class="highlighter-rouge">class_ro_t</code> 指针</li>
  <li>初始化一个 <code class="highlighter-rouge">class_rw_t</code> 结构体</li>
  <li>设置结构体 <code class="highlighter-rouge">ro</code> 的值以及 <code class="highlighter-rouge">flag</code></li>
  <li>最后设置正确的 <code class="highlighter-rouge">data</code>。</li>
</ol>

<pre><code class="language-objectivec">const class_ro_t *ro = (const class_ro_t *)cls-&gt;data();
class_rw_t *rw = (class_rw_t *)calloc(sizeof(class_rw_t), 1);
rw-&gt;ro = ro;
rw-&gt;flags = RW_REALIZED|RW_REALIZING;
cls-&gt;setData(rw);
</code></pre>

<p>下图是 <code class="highlighter-rouge">realizeClass</code> 方法执行过后的类所占用内存的布局，你可以与上面调用方法前的内存布局对比以下，看有哪些更改：</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-23-objc-method-after-realize-class.png" alt="objc-method-after-realize-class" /></p>

<p>但是，在这段代码运行之后 <code class="highlighter-rouge">class_rw_t</code> 中的方法，属性以及协议列表均为空。这时需要 <code class="highlighter-rouge">realizeClass</code> 调用 <code class="highlighter-rouge">methodizeClass</code> 方法来<strong>将类自己实现的方法（包括分类）、属性和遵循的协议加载到 <code class="highlighter-rouge">methods</code>、 <code class="highlighter-rouge">properties</code> 和 <code class="highlighter-rouge">protocols</code> 列表中</strong>。</p>

<h2 id="xxobject">XXObject</h2>

<p>下面，我们将分析一个类 <code class="highlighter-rouge">XXObject</code> 在运行时初始化过程中内存的更改，这是 <code class="highlighter-rouge">XXObject</code> 的接口与实现：</p>

<pre><code class="language-objectivec">// XXObject.h 文件
#import &lt;Foundation/Foundation.h&gt;

@interface XXObject : NSObject

- (void)hello;

@end

// XXObject.m 文件

#import "XXObject.h"

@implementation XXObject

- (void)hello {
    NSLog(@"Hello");
}

@end
</code></pre>

<blockquote>
  <p>这段代码是运行在 Mac OS X 10.11.3 (x86_64)版本中，而不是运行在 iPhone 模拟器或者真机上的，如果你在 iPhone 或者真机上运行，可能有一定差别。</p>
</blockquote>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-23-objc-method-target.png" alt="objc-method-target" /></p>

<p>这是主程序的代码：</p>

<pre><code class="language-objectivec">#import &lt;Foundation/Foundation.h&gt;
#import "XXObject.h"

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        Class cls = [XXObject class];
        NSLog(@"%p", cls);
    }
    return 0;
}
</code></pre>

<h3 id="编译后内存中类的结构">编译后内存中类的结构</h3>

<p>因为<strong>类在内存中的位置是编译期就确定的</strong>，先运行一次代码获取 <code class="highlighter-rouge">XXObject</code> 在内存中的地址。</p>

<pre><code class="language-objectivec">0x100001168
</code></pre>

<p>接下来，在整个 ObjC 运行时初始化之前，也就是 <code class="highlighter-rouge">_objc_init</code> 方法中加入一个断点：</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-23-objc-method-after-compile.png" alt="objc-method-after-compile" /></p>

<p>然后在 lldb 中输入以下命令：</p>

<pre><code class="language-objectivec">(lldb) p (objc_class *)0x100001168
(objc_class *) $0 = 0x0000000100001168
(lldb) p (class_data_bits_t *)0x100001188
(class_data_bits_t *) $1 = 0x0000000100001188
(lldb) p $1-&gt;data()
warning: could not load any Objective-C class information. This will significantly reduce the quality of type information available.
(class_rw_t *) $2 = 0x00000001000010e8
(lldb) p (class_ro_t *)$2 // 将 class_rw_t 强制转化为 class_ro_t
(class_ro_t *) $3 = 0x00000001000010e8
(lldb) p *$3
(class_ro_t) $4 = {
  flags = 128
  instanceStart = 8
  instanceSize = 8
  reserved = 0
  ivarLayout = 0x0000000000000000 &lt;no value available&gt;
  name = 0x0000000100000f7a "XXObject"
  baseMethodList = 0x00000001000010c8
  baseProtocols = 0x0000000000000000
  ivars = 0x0000000000000000
  weakIvarLayout = 0x0000000000000000 &lt;no value available&gt;
  baseProperties = 0x0000000000000000
}
</code></pre>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-23-objc-method-lldb-print-before-realize.png" alt="objc-method-lldb-print-before-realize" /></p>

<p>现在我们获取了类经过编译器处理后的只读属性 <code class="highlighter-rouge">class_ro_t</code>：</p>

<pre><code class="language-objectivec">(class_ro_t) $4 = {
  flags = 128
  instanceStart = 8
  instanceSize = 8
  reserved = 0
  ivarLayout = 0x0000000000000000 &lt;no value available&gt;
  name = 0x0000000100000f7a "XXObject"
  baseMethodList = 0x00000001000010c8
  baseProtocols = 0x0000000000000000
  ivars = 0x0000000000000000
  weakIvarLayout = 0x0000000000000000 &lt;no value available&gt;
  baseProperties = 0x0000000000000000
}
</code></pre>

<p>可以看到这里面只有 <code class="highlighter-rouge">baseMethodList</code> 和 <code class="highlighter-rouge">name</code> 是有值的，其它的 <code class="highlighter-rouge">ivarLayout</code>、 <code class="highlighter-rouge">baseProtocols</code>、 <code class="highlighter-rouge">ivars</code>、<code class="highlighter-rouge">weakIvarLayout</code> 和 <code class="highlighter-rouge">baseProperties</code> 都指向了空指针，因为类中没有实例变量，协议以及属性。所以这里的结构体符合我们的预期。</p>

<p>通过下面的命令查看 <code class="highlighter-rouge">baseMethodList</code> 中的内容：</p>

<pre><code class="language-objectivec">(lldb) p $4.baseMethodList
(method_list_t *) $5 = 0x00000001000010c8
(lldb) p $5-&gt;get(0)
(method_t) $6 = {
  name = "hello"
  types = 0x0000000100000fa4 "v16@0:8"
  imp = 0x0000000100000e90 (method`-[XXObject hello] at XXObject.m:13)
}
(lldb) p $5-&gt;get(1)
Assertion failed: (i &lt; count), function get, file /Users/apple/Desktop/objc-runtime/runtime/objc-runtime-new.h, line 110.
error: Execution was interrupted, reason: signal SIGABRT.
The process has been returned to the state before expression evaluation.
(lldb)
</code></pre>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-23-objc-method-lldb-print-method-list.png" alt="objc-method-lldb-print-method-list" /></p>

<p>使用 <code class="highlighter-rouge">$5-&gt;get(0)</code> 时，成功获取到了 <code class="highlighter-rouge">-[XXObject hello]</code> 方法的结构体 <code class="highlighter-rouge">method_t</code>。而尝试获取下一个方法时，断言提示我们当前类只有一个方法。</p>

<h3 id="realizeclass">realizeClass</h3>

<p>这篇文章中不会对 <code class="highlighter-rouge">realizeClass</code> 进行详细的分析，该方法的主要作用是对类进行第一次初始化，其中包括：</p>

<ul>
  <li>分配可读写数据空间</li>
  <li>返回真正的类结构</li>
</ul>

<pre><code class="language-objectivec">static Class realizeClass(Class cls)
</code></pre>

<p>上面就是这个方法的签名，我们需要在这个方法中打一个条件断点，来判断当前类是否为 <code class="highlighter-rouge">XXObject</code>：</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-23-objc-method-lldb-breakpoint.png" alt="objc-method-lldb-breakpoint" /></p>

<p>这里直接判断两个指针是否相等，而不使用 <code class="highlighter-rouge">[NSStringFromClass(cls) isEqualToString:@"XXObject"]</code> 是因为在这个时间点，这些方法都不能调用，在 ObjC 中没有这些方法，所以只能通过判断类指针是否相等的方式来确认当前类是 <code class="highlighter-rouge">XXObject</code>。</p>

<blockquote>
  <p>直接与指针比较是因为类在内存中的位置是编译期确定的，只要代码不改变，类在内存中的位置就会不变（已经说过很多遍了）。</p>
</blockquote>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-23-objc-method-breakpoint-before-set-rw.png" alt="objc-method-breakpoint-before-set-r" /></p>

<p>这个断点就设置在这里，因为 <code class="highlighter-rouge">XXObject</code> 是一个正常的类，所以会走 <code class="highlighter-rouge">else</code> 分支分配可写的类数据。</p>

<blockquote>
  <p>运行代码时，因为每次都会判断当前类指针是不是指向的 <code class="highlighter-rouge">XXObject</code>，所以会等一会才会进入断点。</p>
</blockquote>

<p>在这时打印类结构体中的 <code class="highlighter-rouge">data</code> 的值，发现其中的布局依旧是这样的：</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-23-objc-method-before-realize.png" alt="objc-method-before-realize" /></p>

<p>在运行完这段代码之后:</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-23-objc-method-after-realize-breakpoint.png" alt="objc-method-after-realize-breakpoint" /></p>

<p>我们再来打印类的结构:</p>

<pre><code class="language-objectivec">(lldb) p (objc_class *)cls // 打印类指针
(objc_class *) $262 = 0x0000000100001168
(lldb) p (class_data_bits_t *)0x0000000100001188 // 在类指针上加 32 的 offset 打印 class_data_bits_t 指针
(class_data_bits_t *) $263 = 0x0000000100001188
(lldb) p *$263 // 访问 class_data_bits_t 指针的内容
(class_data_bits_t) $264 = (bits = 4302315312)
(lldb) p $264.data() // 获取 class_rw_t
(class_rw_t *) $265 = 0x0000000100701f30
(lldb) p *$265 // 访问 class_rw_t 指针的内容，发现它的 ro 已经设置好了
(class_rw_t) $266 = {
  flags = 2148007936
  version = 0
  ro = 0x00000001000010e8
  methods = {
    list_array_tt&lt;method_t, method_list_t&gt; = {
       = {
        list = 0x0000000000000000
        arrayAndFlag = 0
      }
    }
  }
  properties = {
    list_array_tt&lt;property_t, property_list_t&gt; = {
       = {
        list = 0x0000000000000000
        arrayAndFlag = 0
      }
    }
  }
  protocols = {
    list_array_tt&lt;unsigned long, protocol_list_t&gt; = {
       = {
        list = 0x0000000000000000
        arrayAndFlag = 0
      }
    }
  }
  firstSubclass = nil
  nextSiblingClass = nil
  demangledName = 0x0000000000000000 &lt;no value available&gt;
}
(lldb) p $266.ro // 获取 class_ro_t 指针
(const class_ro_t *) $267 = 0x00000001000010e8
(lldb) p *$267 // 访问 class_ro_t 指针的内容
(const class_ro_t) $268 = {
  flags = 128
  instanceStart = 8
  instanceSize = 8
  reserved = 0
  ivarLayout = 0x0000000000000000 &lt;no value available&gt;
  name = 0x0000000100000f7a "XXObject"
  baseMethodList = 0x00000001000010c8
  baseProtocols = 0x0000000000000000
  ivars = 0x0000000000000000
  weakIvarLayout = 0x0000000000000000 &lt;no value available&gt;
  baseProperties = 0x0000000000000000
}
(lldb) p $268.baseMethodList // 获取基本方法列表
(method_list_t *const) $269 = 0x00000001000010c8
(lldb) p $269-&gt;get(0) // 访问第一个方法
(method_t) $270 = {
  name = "hello"
  types = 0x0000000100000fa4 "v16@0:8"
  imp = 0x0000000100000e90 (method`-[XXObject hello] at XXObject.m:13)
}
(lldb) p $269-&gt;get(1) // 尝试访问第二个方法，越界
error: Execution was interrupted, reason: signal SIGABRT.
The process has been returned to the state before expression evaluation.
Assertion failed: (i &lt; count), function get, file /Users/apple/Desktop/objc-runtime/runtime/objc-runtime-new.h, line 110.
(lldb)
</code></pre>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-23-objc-method-print-class-struct-after-realize.png" alt="objc-method-print-class-struct-after-realize" /></p>

<blockquote>
  <p>最后一个操作实在是截取不到了</p>
</blockquote>

<pre><code class="language-objectivec">const class_ro_t *ro = (const class_ro_t *)cls-&gt;data();
class_rw_t *rw = (class_rw_t *)calloc(sizeof(class_rw_t), 1);
rw-&gt;ro = ro;
rw-&gt;flags = RW_REALIZED|RW_REALIZING;
cls-&gt;setData(rw);
</code></pre>

<p>在上述的代码运行之后，类的只读指针 <code class="highlighter-rouge">class_ro_t</code> 以及可读写指针 <code class="highlighter-rouge">class_rw_t</code> 都被正确的设置了。但是到这里，其 <code class="highlighter-rouge">class_rw_t</code> 部分的方法等成员都指针均为空，这些会在 <code class="highlighter-rouge">methodizeClass</code> 中进行设置：</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-23-objc-method-after-methodizeClass.png" alt="objc-method-after-methodizeClass" /></p>

<p>在这里调用了 <code class="highlighter-rouge">method_array_t</code> 的 <code class="highlighter-rouge">attachLists</code> 方法，将 <code class="highlighter-rouge">baseMethods</code> 中的方法添加到 <code class="highlighter-rouge">methods</code> 数组之后。我们访问 <code class="highlighter-rouge">methods</code> 才会获取当前类的实例方法。</p>

<h2 id="方法的结构">方法的结构</h2>

<p>说了这么多，到现在我们可以简单看一下方法的结构，与类和对象一样，方法在内存中也是一个结构体。</p>

<pre><code class="language-objectivec">struct method_t {
    SEL name;
    const char *types;
    IMP imp;
};
</code></pre>

<p>其中包含方法名，类型还有方法的实现指针 <code class="highlighter-rouge">IMP</code>：</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-23-obj-method-struct.png" alt="obj-method-struct" /></p>

<p>上面的 <code class="highlighter-rouge">-[XXObject hello]</code> 方法的结构体是这样的：</p>

<pre><code class="language-objectivec">name = "hello"
types = 0x0000000100000fa4 "v16@0:8"
imp = 0x0000000100000e90 (method`-[XXObject hello] at XXObject.m:13
</code></pre>

<p>方法的名字在这里没有什么好说的。其中，方法的类型是一个非常奇怪的字符串 <code class="highlighter-rouge">"v16@0:8"</code> 这在 ObjC 中叫做<em>类型编码</em>(Type Encoding)，你可以看这篇<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html">官方文档</a>了解与类型编码相关的信息。</p>

<p>对于方法的实现，lldb 为我们标注了方法在文件中实现的位置。</p>

<h2 id="小结">小结</h2>

<p>在分析方法在内存中的位置时，笔者最开始一直在尝试寻找<strong>只读</strong>结构体 <code class="highlighter-rouge">class_ro_t</code> 中的 <code class="highlighter-rouge">baseMethods</code> 第一次设置的位置（了解类的方法是如何被加载的）。尝试从 <code class="highlighter-rouge">methodizeClass</code> 方法一直向上找，直到 <code class="highlighter-rouge">_obj_init</code> 方法也没有找到设置只读区域的 <code class="highlighter-rouge">baseMethods</code> 的方法。</p>

<p>而且在 runtime 初始化之后，<code class="highlighter-rouge">realizeClass</code> 之前，从 <code class="highlighter-rouge">class_data_bits_t</code> 结构体中获取的 <code class="highlighter-rouge">class_rw_t</code> 一直都是错误的，这个问题在最开始非常让我困惑，直到后来在 <code class="highlighter-rouge">realizeClass</code> 中发现原来在这时并不是 <code class="highlighter-rouge">class_rw_t</code> 结构体，而是<code class="highlighter-rouge">class_ro_t</code>，才明白错误的原因。</p>

<p>后来突然想到类的一些方法、属性和协议实在编译期决定的（<code class="highlighter-rouge">baseMethods</code> 等成员以及类在内存中的位置都是编译期决定的），才感觉到豁然开朗。</p>

<ol>
  <li>类在内存中的位置是在编译期间决定的，在之后修改代码，也不会改变内存中的位置。</li>
  <li>类的方法、属性以及协议在编译期间存放到了“错误”的位置，直到 <code class="highlighter-rouge">realizeClass</code> 执行之后，才放到了 <code class="highlighter-rouge">class_rw_t</code> 指向的只读区域 <code class="highlighter-rouge">class_ro_t</code>，这样我们即可以在运行时为 <code class="highlighter-rouge">class_rw_t</code> 添加方法，也不会影响类的只读结构。</li>
  <li>在 <code class="highlighter-rouge">class_ro_t</code> 中的属性在运行期间就不能改变了，再添加方法时，会修改 <code class="highlighter-rouge">class_rw_t</code> 中的 <code class="highlighter-rouge">methods</code> 列表，而不是 <code class="highlighter-rouge">class_ro_t</code> 中的 <code class="highlighter-rouge">baseMethods</code>，对于方法的添加会在之后的文章中分析。</li>
</ol>

<h2 id="参考资料">参考资料</h2>

<ul>
  <li><a href="http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html">Classes and Metaclasses</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Tagged_pointer">Tagged Pointer</a></li>
  <li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html">类型编码</a></li>
  <li><a href="http://nshipster.cn/type-encodings/">Type Encodings</a></li>
</ul>

<blockquote>
  <p>关注仓库，及时获得更新：<a href="https://github.com/draveness/iOS-Source-Code-Analyze">iOS-Source-Code-Analyze</a></p>
</blockquote>


	  ]]></description>
	</item>

	<item>
	  <title>从 NSObject 的初始化了解 isa</title>
	  <link>/reprinted//isa</link>
	  <author></author>
	  <pubDate>2016-04-21T15:39:27+00:00</pubDate>
	  <guid>/reprinted//isa</guid>
	  <description><![CDATA[
	     <p>Blog: <a href="http://draveness.me">Draveness</a></p>

<iframe src="http://ghbtns.com/github-btn.html?user=draveness&amp;type=follow&amp;size=large" height="30" width="240" frameborder="0" scrolling="0" style="width:240px; height: 30px;" allowtransparency="true"></iframe>

<p>关注仓库，及时获得更新：<a href="https://github.com/draveness/iOS-Source-Code-Analyze">iOS-Source-Code-Analyze</a></p>

<blockquote>
  <p>因为 ObjC 的 runtime 只能在 Mac OS 下才能编译，所以文章中的代码都是在 Mac OS，也就是 <code class="highlighter-rouge">x86_64</code> 架构下运行的，对于在 arm64 中运行的代码会特别说明。</p>
</blockquote>

<p>如果你曾经对 ObjC 底层的实现有一定的了解，你应该会知道 <strong>Objective-C 对象都是 C 语言结构体</strong>，所有的对象都包含一个类型为  <code class="highlighter-rouge">isa</code> 的指针，那么你可能确实对 ObjC 的底层有所知，不过现在的 ObjC 对象的结构已经不是这样了。代替 <code class="highlighter-rouge">isa</code> 指针的是结构体 <code class="highlighter-rouge">isa_t</code>, 这个结构体中”包含”了当前对象指向的类的信息，这篇文章中会介绍一些关于这个变化的知识。</p>

<pre><code class="language-objectivec">struct objc_object {
    isa_t isa;
};
</code></pre>

<p>当 ObjC 为为一个对象分配内存，初始化实例变量后，在这些对象的实例变量的结构体中的第一个就是 <code class="highlighter-rouge">isa</code>。</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-21-NSObject + NSObject Copy + @Draveness.png" alt="NSObject" /></p>

<blockquote>
  <p>所有继承自 <code class="highlighter-rouge">NSObject</code> 的类实例化后的对象都会包含一个类型为 <code class="highlighter-rouge">isa_t</code> 的结构体。</p>
</blockquote>

<p>从上图中可以看出，不只是<strong>实例</strong>会包含一个 <code class="highlighter-rouge">isa</code> 结构体，所有的<strong>类</strong>也有这么一个 <code class="highlighter-rouge">isa</code>。在 ObjC 中 Class 的定义也是一个名为 <code class="highlighter-rouge">objc_class</code> 的结构体，如下：</p>

<pre><code class="language-objectivec">struct objc_class : objc_object {
    isa_t isa;
    Class superclass;
    cache_t cache;
    class_data_bits_t bits;
};
</code></pre>

<blockquote>
  <p>由于 <code class="highlighter-rouge">objc_class</code> 结构体是继承自 <code class="highlighter-rouge">objc_object</code> 的，所以在这里显式地写出了 <code class="highlighter-rouge">isa_t isa</code> 这个成员变量。</p>
</blockquote>

<h2 id="isa-指针的作用与元类"><code class="highlighter-rouge">isa</code> 指针的作用与元类</h2>

<p>到这里，我们就明白了：<strong>Objective-C 中类也是一个对象</strong>。</p>

<p>这个 <code class="highlighter-rouge">isa</code> 包含了什么呢？回答这个问题之前，要引入了另一个概念 <em>元类(meta class)</em>，我们先了解一些关于元类的信息。</p>

<p>因为在 Objective-C 中，对象的方法并<strong>没有存储于对象的结构体中</strong>（如果每一个对象都保存了自己能执行的方法，那么对内存的占用有极大的影响）。</p>

<p>当<strong>实例方法</strong>被调用时，它要通过自己持有的 <code class="highlighter-rouge">isa</code> 来查找对应的类，然后在这里的 <code class="highlighter-rouge">class_data_bits_t</code> 结构体中查找对应方法的实现。同时，每一个 <code class="highlighter-rouge">objc_class</code> 也有一个<strong>指向自己的父类的指针</strong> <code class="highlighter-rouge">super_class</code> 用来查找继承的方法。</p>

<blockquote>
  <p>关于如何在 <code class="highlighter-rouge">class_data_bits_t</code> 中查找对应方法会在之后的文章中讲到。这里只需要知道，它会在这个结构体中查找到对应方法的实现就可以了。</p>
</blockquote>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-21-Slice 1.png" alt="Slice 1" /></p>

<p>但是，这样就有一个问题，类方法的实现又是如何查找并且调用的呢？这时，就需要引入<em>元类</em>来保证无论是类还是对象都能<strong>通过相同的机制查找方法的实现</strong>。</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-21-objc-isa-meta-class.png" alt="objc-isa-meta-class" /></p>

<p>让每一个类的 <code class="highlighter-rouge">isa</code> 指向对应的元类，这样就达到了使类方法和实例方法的调用机制相同的目的：</p>

<ul>
  <li>实例方法调用时，通过对象的 <code class="highlighter-rouge">isa</code> 在类中获取方法的实现</li>
  <li>类方法调用时，通过类的 <code class="highlighter-rouge">isa</code> 在元类中获取方法的实现</li>
</ul>

<p>下面这张图介绍了对象，类与元类之间的关系，笔者认为已经觉得足够清晰了，所以不在赘述。</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-21-14611715787360.jpg" alt="" /></p>

<blockquote>
  <p>图片来自 <a href="http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html">objc_explain_Classes_and_metaclasses</a></p>
</blockquote>

<p>有关与介绍类与元类之间的关系的文章实在是太多了，因为这篇文章主要介绍 <code class="highlighter-rouge">isa</code>，在这一小节只是对其作用以及元类的概念进行介绍。如果想要了解更多关于类与元类的信息，可以看 <a href="http://www.cocoawithlove.com/2010/01/what-is-meta-class-in-objective-c.html">What is a meta-class in Objective-C?</a></p>

<h2 id="结构体-isa_t">结构体 <code class="highlighter-rouge">isa_t</code></h2>

<p>其实 <code class="highlighter-rouge">isa_t</code> 是一个定义得非常”奇怪”的结构体，在 ObjC 源代码中可以看到这样的定义：</p>

<pre><code class="language-objectivec">#define ISA_MASK        0x00007ffffffffff8ULL
#define ISA_MAGIC_MASK  0x001f800000000001ULL
#define ISA_MAGIC_VALUE 0x001d800000000001ULL
#define RC_ONE   (1ULL&lt;&lt;56)
#define RC_HALF  (1ULL&lt;&lt;7)

union isa_t {
    isa_t() { }
    isa_t(uintptr_t value) : bits(value) { }

    Class cls;
    uintptr_t bits;

    struct {
        uintptr_t indexed           : 1;
        uintptr_t has_assoc         : 1;
        uintptr_t has_cxx_dtor      : 1;
        uintptr_t shiftcls          : 44;
        uintptr_t magic             : 6;
        uintptr_t weakly_referenced : 1;
        uintptr_t deallocating      : 1;
        uintptr_t has_sidetable_rc  : 1;
        uintptr_t extra_rc          : 8;
    };
};
</code></pre>

<blockquote>
  <p>这是在 <code class="highlighter-rouge">__x86_64__</code> 上的实现，对于 iPhone5s 等架构为 <code class="highlighter-rouge">__arm64__</code> 的设备上，具体结构体的实现和位数可能有些差别，不过这些字段都是存在的，可以看这里的 <a href="#arm64">arm64 上结构体的实现</a></p>
</blockquote>

<p><strong>在本篇文章中, 我们会以 <code class="highlighter-rouge">__x86_64__</code> 为例进行分析，而不会对两种架构下由于不同的内存布局方式导致的差异进行分析</strong>。在我看来，这个细节不会影响对 <code class="highlighter-rouge">isa</code> 指针的理解，不过还是要知道的。</p>

<p>笔者对这个 <code class="highlighter-rouge">isa_t</code> 的实现声明顺序有一些更改，更方便分析和理解。</p>

<pre><code class="language-objectivec">union isa_t {
    ...
};
</code></pre>

<p><code class="highlighter-rouge">isa_t</code> 是一个 <code class="highlighter-rouge">union</code> 类型的结构体，对 <code class="highlighter-rouge">union</code> 不熟悉的读者可以看这个 stackoverflow 上的<a href="http://stackoverflow.com/questions/252552/why-do-we-need-c-unions">回答</a>. 也就是说其中的 <code class="highlighter-rouge">isa_t</code>、<code class="highlighter-rouge">cls</code>、 <code class="highlighter-rouge">bits</code> 还有结构体共用同一块地址空间。而 <code class="highlighter-rouge">isa</code> 总共会占据 64 位的内存空间（决定于其中的结构体）</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-21-objc-isa-isat.png" alt="objc-isa-isat" /></p>

<pre><code class="language-objectivec">struct {
   uintptr_t indexed           : 1;
   uintptr_t has_assoc         : 1;
   uintptr_t has_cxx_dtor      : 1;
   uintptr_t shiftcls          : 44;
   uintptr_t magic             : 6;
   uintptr_t weakly_referenced : 1;
   uintptr_t deallocating      : 1;
   uintptr_t has_sidetable_rc  : 1;
   uintptr_t extra_rc          : 8;
};
</code></pre>

<h2 id="isa-的初始化"><code class="highlighter-rouge">isa</code> 的初始化</h2>

<p>我们可以通过 <code class="highlighter-rouge">isa</code> 初始化的方法 <code class="highlighter-rouge">initIsa</code> 来初步了解这 64 位的 bits 的作用：</p>

<pre><code class="language-objectivec">inline void
objc_object::initInstanceIsa(Class cls, bool hasCxxDtor)
{
    initIsa(cls, true, hasCxxDtor);
}

inline void
objc_object::initIsa(Class cls, bool indexed, bool hasCxxDtor)
{
    if (!indexed) {
        isa.cls = cls;
    } else {
        isa.bits = ISA_MAGIC_VALUE;
        isa.has_cxx_dtor = hasCxxDtor;
        isa.shiftcls = (uintptr_t)cls &gt;&gt; 3;
    }
}
</code></pre>

<h3 id="indexed-和-magic"><code class="highlighter-rouge">indexed</code> 和 <code class="highlighter-rouge">magic</code></h3>

<p>当我们对一个 ObjC 对象分配内存时，其方法调用栈中包含了上述的两个方法，这里关注的重点是 <code class="highlighter-rouge">initIsa</code> 方法，由于在 <code class="highlighter-rouge">initInstanceIsa</code> 方法中传入了 <code class="highlighter-rouge">indexed = true</code>，所以，我们简化一下这个方法的实现：</p>

<pre><code class="language-objectivec">inline void objc_object::initIsa(Class cls, bool indexed, bool hasCxxDtor)
{
    isa.bits = ISA_MAGIC_VALUE;
    isa.has_cxx_dtor = hasCxxDtor;
    isa.shiftcls = (uintptr_t)cls &gt;&gt; 3;
}
</code></pre>

<p>对整个 <code class="highlighter-rouge">isa</code> 的值 <code class="highlighter-rouge">bits</code> 进行设置，传入 <code class="highlighter-rouge">ISA_MAGIC_VALUE</code>：</p>

<pre><code class="language-objectivec">#define ISA_MAGIC_VALUE 0x001d800000000001ULL
</code></pre>

<p>我们可以把它转换成二进制的数据，然后看一下哪些属性对应的位被这行代码初始化了（标记为红色）：</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-21-objc-isa-isat-bits.png" alt="objc-isa-isat-bits" /></p>

<p>从图中了解到，在使用 <code class="highlighter-rouge">ISA_MAGIC_VALUE</code> 设置 <code class="highlighter-rouge">isa_t</code> 结构体之后，实际上只是设置了 <code class="highlighter-rouge">indexed</code> 以及 <code class="highlighter-rouge">magic</code> 这两部分的值。</p>

<ul>
  <li>其中 <code class="highlighter-rouge">indexed</code> 表示 <code class="highlighter-rouge">isa_t</code> 的类型
    <ul>
      <li>
        <p>0 表示 <code class="highlighter-rouge">raw isa</code>，也就是没有结构体的部分，访问对象的 <code class="highlighter-rouge">isa</code> 会直接返回一个指向 <code class="highlighter-rouge">cls</code> 的指针，也就是在 iPhone 迁移到 64 位系统之前时 isa 的类型。</p>

        <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  union isa_t {
      isa_t() { }
      isa_t(uintptr_t value) : bits(value) { }

      Class cls;
      uintptr_t bits;
  };
</code></pre></div>        </div>
      </li>
      <li>
        <p>1 表示当前 <code class="highlighter-rouge">isa</code> 不是指针，但是其中也有 <code class="highlighter-rouge">cls</code> 的信息，只是其中<strong>关于类的指针都是保存在 <code class="highlighter-rouge">shiftcls</code> 中</strong>。</p>

        <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  union isa_t {
      isa_t() { }
      isa_t(uintptr_t value) : bits(value) { }

      Class cls;
      uintptr_t bits;

      struct {
          uintptr_t indexed           : 1;
          uintptr_t has_assoc         : 1;
          uintptr_t has_cxx_dtor      : 1;
          uintptr_t shiftcls          : 44;
          uintptr_t magic             : 6;
          uintptr_t weakly_referenced : 1;
          uintptr_t deallocating      : 1;
          uintptr_t has_sidetable_rc  : 1;
          uintptr_t extra_rc          : 8;
      };
  };
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">magic</code> 的值为 <code class="highlighter-rouge">0x3b</code> 用于调试器判断当前对象是真的对象还是没有初始化的空间</li>
</ul>

<h3 id="has_cxx_dtor"><code class="highlighter-rouge">has_cxx_dtor</code></h3>

<p>在设置 <code class="highlighter-rouge">indexed</code> 和 <code class="highlighter-rouge">magic</code> 值之后，会设置 <code class="highlighter-rouge">isa</code> 的 <code class="highlighter-rouge">has_cxx_dtor</code>，这一位表示当前对象有 C++ 或者 ObjC 的析构器(destructor)，如果没有析构器就会快速释放内存。</p>

<pre><code class="language-objectivec">isa.has_cxx_dtor = hasCxxDtor;
</code></pre>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-21-objc-isa-isat-bits-has-css-dtor.png" alt="objc-isa-isat-bits-has-css-dto" /></p>

<h3 id="shiftcls"><code class="highlighter-rouge">shiftcls</code></h3>

<p>在为 <code class="highlighter-rouge">indexed</code>、 <code class="highlighter-rouge">magic</code> 和 <code class="highlighter-rouge">has_cxx_dtor</code> 设置之后，我们就要将当前对象对应的类指针存入 <code class="highlighter-rouge">isa</code> 结构体中了。</p>

<pre><code class="language-objectivec">isa.shiftcls = (uintptr_t)cls &gt;&gt; 3;
</code></pre>

<blockquote>
  <p><strong>将当前地址右移三位的主要原因是用于将 Class 指针中无用的后三位清楚减小内存的消耗，因为类的指针要按照字节（8 bits）对齐内存，其指针后三位都是没有意义的 0</strong>。</p>

  <p>绝大多数机器的架构都是 <a href="https://en.wikipedia.org/wiki/Byte_addressing">byte-addressable</a> 的，但是对象的内存地址必须对齐到字节的倍数，这样可以提高代码运行的性能，在 iPhone5s 中虚拟地址为 33 位，所以用于对齐的最后三位比特为 <code class="highlighter-rouge">000</code>，我们只会用其中的 30 位来表示对象的地址。</p>
</blockquote>

<p>而 ObjC 中的类指针的地址后三位也为 0，在 <code class="highlighter-rouge">_class_createInstanceFromZone</code> 方法中打印了调用这个方法传入的类指针：</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-21-objc-isa-print-cls.png" alt="objc-isa-print-cls" /></p>

<p>可以看到，这里打印出来的<strong>所有类指针十六进制地址的最后一位都为 8 或者 0</strong>。也就是说，类指针的后三位都为 0，所以，我们在上面存储 <code class="highlighter-rouge">Class</code> 指针时右移三位是没有问题的。</p>

<pre><code class="language-objectivec">isa.shiftcls = (uintptr_t)cls &gt;&gt; 3;
</code></pre>

<p>如果再尝试打印对象指针的话，会发现所有对象内存地址的<strong>后四位</strong>都是 0，说明 ObjC 在初始化内存时是以 16 个字节对齐的, 分配的内存地址后四位都是 0。</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-21-objc-isa-print-object.png" alt="objc-isa-print-object" /></p>

<blockquote>
  <p>使用整个指针大小的内存来存储 <code class="highlighter-rouge">isa</code> 指针有些浪费，尤其在 64 位的 CPU 上。在 <code class="highlighter-rouge">ARM64</code> 运行的 iOS 只使用了 33 位作为指针(与结构体中的 33 位无关，Mac OS 上为 47 位)，而剩下的 31 位用于其它目的。类的指针也同样根据字节对齐了，每一个类指针的地址都能够被 8 整除，也就是使最后 3 bits 为 0，为 <code class="highlighter-rouge">isa</code> 留下 34 位用于性能的优化。</p>

  <p>Using an entire pointer-sized piece of memory for the isa pointer is a bit wasteful, especially on 64-bit CPUs which don’t use all 64 bits of a pointer. ARM64 running iOS currently uses only 33 bits of a pointer, leaving 31 bits for other purposes. Class pointers are also aligned, meaning that a class pointer is guaranteed to be divisible by 8, which frees up another three bits, leaving 34 bits of the isa available for other uses. Apple’s ARM64 runtime takes advantage of this for some great performance improvements.
from <a href="https://www.mikeash.com/pyblog/friday-qa-2013-09-27-arm64-and-you.html">ARM64 and You</a></p>
</blockquote>

<p>我尝试运行了下面的代码将 <code class="highlighter-rouge">NSObject</code> 的类指针和对象的 <code class="highlighter-rouge">isa</code> 打印出来，具体分析一下</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-21-objc-isa-print-class-object.png" alt="objc-isa-print-class-object" /></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>object_pointer: 0000000001011101100000000000000100000000001110101110000011111001 // 补全至 64 位
class_pointer:                                 100000000001110101110000011111000
</code></pre></div></div>

<blockquote>
  <p>编译器对直接访问 <code class="highlighter-rouge">isa</code> 的操作会有警告，因为直接访问 <code class="highlighter-rouge">isa</code> 已经不会返回类指针了，这种行为已经被启用了，取而代之的是使用 <a href="#ISA()">ISA()</a> 方法来获取类指针。</p>
</blockquote>

<p>代码中的 <code class="highlighter-rouge">object</code> 对象的 <code class="highlighter-rouge">isa</code> 结构体中的内容是这样的：</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-21-objc-isa-isat-class-highlight-bits.png" alt="objc-isa-isat-class-highlight-bits" /></p>

<p>其中红色的为<strong>类指针</strong>，与上面打印出的 <code class="highlighter-rouge">[NSObject class]</code> 指针右移三位的结果完全相同。这也就验证了我们之前对于初始化 <code class="highlighter-rouge">isa</code> 时对 <code class="highlighter-rouge">initIsa</code> 方法的分析是正确的。它设置了 <code class="highlighter-rouge">indexed</code>、<code class="highlighter-rouge">magic</code> 以及 <code class="highlighter-rouge">shiftcls</code>。</p>

<h3 id="isa-方法"><a id="ISA()"></a>ISA() 方法</h3>

<p>因为我们使用结构体取代了原有的 isa 指针，所以要提供一个方法 <code class="highlighter-rouge">ISA()</code> 来返回类指针。</p>

<p>其中 <code class="highlighter-rouge">ISA_MASK</code> 是宏定义，这里通过掩码的方式获取类指针：</p>

<pre><code class="language-objectivec">#define ISA_MASK 0x00007ffffffffff8ULL
inline Class
objc_object::ISA()
{
    return (Class)(isa.bits &amp; ISA_MASK);
}
</code></pre>

<h3 id="其它-bits">其它 bits</h3>

<p>在 <code class="highlighter-rouge">isa_t</code> 中，我们还有一些没有介绍的其它 bits，在这个小结就简单介绍下这些 bits 的作用</p>

<ul>
  <li><code class="highlighter-rouge">has_assoc</code>
    <ul>
      <li>对象含有或者曾经含有关联引用，没有关联引用的可以更快地释放内存</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">weakly_referenced</code>
    <ul>
      <li>对象被指向或者曾经指向一个 ARC 的弱变量，没有弱引用的对象可以更快释放</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">deallocating</code>
    <ul>
      <li>对象正在释放内存</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">has_sidetable_rc</code>
    <ul>
      <li>对象的引用计数太大了，存不下</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">extra_rc</code>
    <ul>
      <li>对象的引用计数超过 1，会存在这个这个里面，如果引用计数为 10，<code class="highlighter-rouge">extra_rc</code> 的值就为 9</li>
    </ul>
  </li>
</ul>

<pre><code class="language-objectivec">struct {
   uintptr_t indexed           : 1;
   uintptr_t has_assoc         : 1;
   uintptr_t has_cxx_dtor      : 1;
   uintptr_t shiftcls          : 44;
   uintptr_t magic             : 6;
   uintptr_t weakly_referenced : 1;
   uintptr_t deallocating      : 1;
   uintptr_t has_sidetable_rc  : 1;
   uintptr_t extra_rc          : 8;
};
</code></pre>

<h3 id="arm64-架构中的-isa_t-结构体"><a id="arm64"></a>arm64 架构中的 <code class="highlighter-rouge">isa_t</code> 结构体</h3>

<pre><code class="language-objectivec">#define ISA_MASK        0x0000000ffffffff8ULL
#define ISA_MAGIC_MASK  0x000003f000000001ULL
#define ISA_MAGIC_VALUE 0x000001a000000001ULL
#define RC_ONE   (1ULL&lt;&lt;45)
#define RC_HALF  (1ULL&lt;&lt;18)
union isa_t {
    isa_t() { }
    isa_t(uintptr_t value) : bits(value) { }

    Class cls;
    uintptr_t bits;

    struct {
       uintptr_t indexed           : 1;
       uintptr_t has_assoc         : 1;
       uintptr_t has_cxx_dtor      : 1;
       uintptr_t shiftcls          : 33;
       uintptr_t magic             : 6;
       uintptr_t weakly_referenced : 1;
       uintptr_t deallocating      : 1;
       uintptr_t has_sidetable_rc  : 1;
       uintptr_t extra_rc          : 19;
    };
};
</code></pre>

<h2 id="参考资料">参考资料</h2>

<ul>
  <li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtHowMessagingWorks.html">Objective-C Runtime Programming Guide</a></li>
  <li><a href="http://www.cocoawithlove.com/2010/01/what-is-meta-class-in-objective-c.html">What is a meta-class in Objective-C?</a></li>
  <li><a href="http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html">objc_explain_Classes_and_metaclasses</a></li>
  <li><a href="http://stackoverflow.com/questions/18997362/storing-things-in-isa">Storing things in isa</a></li>
  <li><a href="http://stackoverflow.com/questions/252552/why-do-we-need-c-unions">Why do we need C Unions?</a></li>
  <li><a href="http://www.sealiesoftware.com/blog/archive/2013/09/24/objc_explain_Non-pointer_isa.html">objc_explain_Non-pointer_isa</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Tagged_pointer">Tagged Pointer</a></li>
  <li><a href="https://www.mikeash.com/pyblog/friday-qa-2013-09-27-arm64-and-you.html">ARM64 and You</a></li>
  <li><a href="http://blog.xcodev.com/posts/tagged-pointer-and-64-bit/">64位与Tagged Pointer</a></li>
</ul>

<iframe src="http://ghbtns.com/github-btn.html?user=draveness&amp;type=follow&amp;size=large" height="30" width="240" frameborder="0" scrolling="0" style="width:240px; height: 30px;" allowtransparency="true"></iframe>

<p>关注仓库，及时获得更新：<a href="https://github.com/draveness/iOS-Source-Code-Analyze">iOS-Source-Code-Analyze</a></p>

<p>转载请注明  Blog: <a href="http://draveness.me">Draveness</a></p>


	  ]]></description>
	</item>

	<item>
	  <title>验证 HTTPS 请求的证书（五）</title>
	  <link>/reprinted//afnetworking5</link>
	  <author></author>
	  <pubDate>2016-04-16T04:40:52+00:00</pubDate>
	  <guid>/reprinted//afnetworking5</guid>
	  <description><![CDATA[
	     <p>Blog: <a href="http://draveness.me">Draveness</a></p>

<iframe src="http://ghbtns.com/github-btn.html?user=draveness&amp;type=follow&amp;size=large" height="30" width="240" frameborder="0" scrolling="0" style="width:240px; height: 30px;" allowtransparency="true"></iframe>

<p>关注仓库，及时获得更新：<a href="https://github.com/draveness/iOS-Source-Code-Analyze">iOS-Source-Code-Analyze</a></p>

<p>自 iOS9 发布之后，由于新特性 <a href="https://developer.apple.com/library/ios/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html">App Transport Security</a> 的引入，在默认行为下是不能发送 HTTP 请求的。很多网站都在转用 HTTPS，而 <code class="highlighter-rouge">AFNetworking</code> 中的 <code class="highlighter-rouge">AFSecurityPolicy</code> 就是为了阻止中间人攻击，以及其它漏洞的工具。</p>

<p><code class="highlighter-rouge">AFSecurityPolicy</code> 主要作用就是验证 HTTPS 请求的证书是否有效，如果 app 中有一些敏感信息或者涉及交易信息，一定要使用 HTTPS 来保证交易或者用户信息的安全。</p>

<h2 id="afsslpinningmode">AFSSLPinningMode</h2>

<p>使用 <code class="highlighter-rouge">AFSecurityPolicy</code> 时，总共有三种验证服务器是否被信任的方式：</p>

<pre><code class="language-objectivec">typedef NS_ENUM(NSUInteger, AFSSLPinningMode) {
    AFSSLPinningModeNone,
    AFSSLPinningModePublicKey,
    AFSSLPinningModeCertificate,
};
</code></pre>

<ul>
  <li><code class="highlighter-rouge">AFSSLPinningModeNone</code> 是默认的认证方式，只会在系统的信任的证书列表中对服务端返回的证书进行验证</li>
  <li><code class="highlighter-rouge">AFSSLPinningModeCertificate</code> 需要客户端预先保存服务端的证书</li>
  <li><code class="highlighter-rouge">AFSSLPinningModeCertificate</code> 也需要预先保存服务端发送的证书，但是这里只会验证证书中的公钥是否正确</li>
</ul>

<h2 id="初始化以及设置">初始化以及设置</h2>

<p>在使用 <code class="highlighter-rouge">AFSecurityPolicy</code> 验证服务端是否受到信任之前，要对其进行初始化，使用初始化方法时，主要目的是设置<strong>验证服务器是否受信任的方式</strong>。</p>

<pre><code class="language-objectivec">+ (instancetype)policyWithPinningMode:(AFSSLPinningMode)pinningMode {
    return [self policyWithPinningMode:pinningMode withPinnedCertificates:[self defaultPinnedCertificates]];
}

+ (instancetype)policyWithPinningMode:(AFSSLPinningMode)pinningMode withPinnedCertificates:(NSSet *)pinnedCertificates {
    AFSecurityPolicy *securityPolicy = [[self alloc] init];
    securityPolicy.SSLPinningMode = pinningMode;

    [securityPolicy setPinnedCertificates:pinnedCertificates];

    return securityPolicy;
}
</code></pre>

<p>这里没有什么地方值得解释的。不过在调用 <code class="highlighter-rouge">pinnedCertificate</code> 的 setter 方法时，会从全部的证书中<strong>取出公钥</strong>保存到 <code class="highlighter-rouge">pinnedPublicKeys</code> 属性中。</p>

<pre><code class="language-objectivec">- (void)setPinnedCertificates:(NSSet *)pinnedCertificates {
    _pinnedCertificates = pinnedCertificates;

    if (self.pinnedCertificates) {
        NSMutableSet *mutablePinnedPublicKeys = [NSMutableSet setWithCapacity:[self.pinnedCertificates count]];
        for (NSData *certificate in self.pinnedCertificates) {
            id publicKey = AFPublicKeyForCertificate(certificate);
            if (!publicKey) {
                continue;
            }
            [mutablePinnedPublicKeys addObject:publicKey];
        }
        self.pinnedPublicKeys = [NSSet setWithSet:mutablePinnedPublicKeys];
    } else {
        self.pinnedPublicKeys = nil;
    }
}
</code></pre>

<p>在这里调用了 <code class="highlighter-rouge">AFPublicKeyForCertificate</code> 对证书进行操作，返回一个公钥。</p>

<h2 id="操作-sectrustref">操作 SecTrustRef</h2>

<p>对 <code class="highlighter-rouge">serverTrust</code> 的操作的函数基本上都是 C 的 API，都定义在 <code class="highlighter-rouge">Security</code> 模块中，先来分析一下在上一节中 <code class="highlighter-rouge">AFPublicKeyForCertificate</code> 的实现</p>

<pre><code class="language-objectivec">static id AFPublicKeyForCertificate(NSData *certificate) {
    id allowedPublicKey = nil;
    SecCertificateRef allowedCertificate;
    SecCertificateRef allowedCertificates[1];
    CFArrayRef tempCertificates = nil;
    SecPolicyRef policy = nil;
    SecTrustRef allowedTrust = nil;
    SecTrustResultType result;

    allowedCertificate = SecCertificateCreateWithData(NULL, (__bridge CFDataRef)certificate);
    __Require_Quiet(allowedCertificate != NULL, _out);

    allowedCertificates[0] = allowedCertificate;
    tempCertificates = CFArrayCreate(NULL, (const void **)allowedCertificates, 1, NULL);

    policy = SecPolicyCreateBasicX509();
    __Require_noErr_Quiet(SecTrustCreateWithCertificates(tempCertificates, policy, &amp;allowedTrust), _out);
    __Require_noErr_Quiet(SecTrustEvaluate(allowedTrust, &amp;result), _out);

    allowedPublicKey = (__bridge_transfer id)SecTrustCopyPublicKey(allowedTrust);

_out:
    if (allowedTrust) {
        CFRelease(allowedTrust);
    }

    if (policy) {
        CFRelease(policy);
    }

    if (tempCertificates) {
        CFRelease(tempCertificates);
    }

    if (allowedCertificate) {
        CFRelease(allowedCertificate);
    }

    return allowedPublicKey;
}
</code></pre>

<ol>
  <li>
    <p>初始化一坨临时变量</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> id allowedPublicKey = nil;
 SecCertificateRef allowedCertificate;
 SecCertificateRef allowedCertificates[1];
 CFArrayRef tempCertificates = nil;
 SecPolicyRef policy = nil;
 SecTrustRef allowedTrust = nil;
 SecTrustResultType result;
</code></pre></div>    </div>
  </li>
  <li>
    <p>使用 <code class="highlighter-rouge">SecCertificateCreateWithData</code> 通过 DER 表示的数据生成一个 <code class="highlighter-rouge">SecCertificateRef</code>，然后判断返回值是否为 <code class="highlighter-rouge">NULL</code></p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> allowedCertificate = SecCertificateCreateWithData(NULL, (__bridge CFDataRef)certificate);
 __Require_Quiet(allowedCertificate != NULL, _out);
</code></pre></div>    </div>

    <ul>
      <li>
        <p>这里使用了一个非常神奇的宏 <code class="highlighter-rouge">__Require_Quiet</code>，它会判断 <code class="highlighter-rouge">allowedCertificate != NULL</code> 是否成立，如果 <code class="highlighter-rouge">allowedCertificate</code> 为空就会跳到 <code class="highlighter-rouge">_out</code> 标签处继续执行</p>

        <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  #ifndef __Require_Quiet
      #define __Require_Quiet(assertion, exceptionLabel)                            \
        do                                                                          \
        {                                                                           \
            if ( __builtin_expect(!(assertion), 0) )                                \
            {                                                                       \
                goto exceptionLabel;                                                \
            }                                                                       \
        } while ( 0 )
  #endif
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>
    <p>通过上面的 <code class="highlighter-rouge">allowedCertificate</code> 创建一个 <code class="highlighter-rouge">CFArray</code></p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> allowedCertificates[0] = allowedCertificate;
 tempCertificates = CFArrayCreate(NULL, (const void **)allowedCertificates, 1, NULL);
</code></pre></div>    </div>

    <ul>
      <li>下面的 <code class="highlighter-rouge">SecTrustCreateWithCertificates</code> 只会接收数组作为参数。</li>
    </ul>
  </li>
  <li>
    <p>创建一个默认的符合 X509 标准的 <code class="highlighter-rouge">SecPolicyRef</code>，通过默认的 <code class="highlighter-rouge">SecPolicyRef</code> 和证书创建一个 <code class="highlighter-rouge">SecTrustRef</code> 用于信任评估，对该对象进行信任评估，确认生成的 <code class="highlighter-rouge">SecTrustRef</code> 是值得信任的。</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> policy = SecPolicyCreateBasicX509();
 __Require_noErr_Quiet(SecTrustCreateWithCertificates(tempCertificates, policy, &amp;allowedTrust), _out);
 __Require_noErr_Quiet(SecTrustEvaluate(allowedTrust, &amp;result), _out);
</code></pre></div>    </div>

    <ul>
      <li>这里使用的 <code class="highlighter-rouge">__Require_noErr_Quiet</code> 和上面的宏差不多，只是会根据返回值判断是否存在错误。</li>
    </ul>
  </li>
  <li>
    <p>获取公钥</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> allowedPublicKey = (__bridge_transfer id)SecTrustCopyPublicKey(allowedTrust);
</code></pre></div>    </div>

    <ul>
      <li>这里的 <code class="highlighter-rouge">__bridge_transfer</code> 会将结果桥接成 <code class="highlighter-rouge">NSObject</code> 对象，然后将 <code class="highlighter-rouge">SecTrustCopyPublicKey</code> 返回的指针释放。</li>
    </ul>
  </li>
  <li>
    <p>释放各种 C 语言指针</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> if (allowedTrust) {
     CFRelease(allowedTrust);
 }

 if (policy) {
     CFRelease(policy);
 }

 if (tempCertificates) {
     CFRelease(tempCertificates);
 }

 if (allowedCertificate) {
     CFRelease(allowedCertificate);
 }
</code></pre></div>    </div>
  </li>
</ol>

<blockquote>
  <p>每一个 <code class="highlighter-rouge">SecTrustRef</code> 的对象都是包含多个 <code class="highlighter-rouge">SecCertificateRef</code> 和 <code class="highlighter-rouge">SecPolicyRef</code>。其中 <code class="highlighter-rouge">SecCertificateRef</code> 可以使用 DER 进行表示，并且其中存储着公钥信息。</p>
</blockquote>

<p>对它的操作还有 <code class="highlighter-rouge">AFCertificateTrustChainForServerTrust</code> 和 <code class="highlighter-rouge">AFPublicKeyTrustChainForServerTrust</code> 但是它们几乎调用了相同的 API。</p>

<pre><code class="language-objectivec">static NSArray * AFCertificateTrustChainForServerTrust(SecTrustRef serverTrust) {
    CFIndex certificateCount = SecTrustGetCertificateCount(serverTrust);
    NSMutableArray *trustChain = [NSMutableArray arrayWithCapacity:(NSUInteger)certificateCount];

    for (CFIndex i = 0; i &lt; certificateCount; i++) {
        SecCertificateRef certificate = SecTrustGetCertificateAtIndex(serverTrust, i);
        [trustChain addObject:(__bridge_transfer NSData *)SecCertificateCopyData(certificate)];
    }

    return [NSArray arrayWithArray:trustChain];
}
</code></pre>

<ul>
  <li><code class="highlighter-rouge">SecTrustGetCertificateAtIndex</code> 获取 <code class="highlighter-rouge">SecTrustRef</code> 中的证书</li>
  <li><code class="highlighter-rouge">SecCertificateCopyData</code> 从证书中或者 DER 表示的数据</li>
</ul>

<h2 id="验证服务端是否受信">验证服务端是否受信</h2>

<p>验证服务端是否守信是通过 <code class="highlighter-rouge">- [AFSecurityPolicy evaluateServerTrust:forDomain:]</code> 方法进行的。</p>

<pre><code class="language-objectivec">- (BOOL)evaluateServerTrust:(SecTrustRef)serverTrust
                  forDomain:(NSString *)domain
{

	#1: 不能隐式地信任自己签发的证书

	#2: 设置 policy

	#3: 验证证书是否有效

	#4: 根据 SSLPinningMode 对服务端进行验证

    return NO;
}
</code></pre>

<ol>
  <li>
    <p>不能隐式地信任自己签发的证书</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> if (domain &amp;&amp; self.allowInvalidCertificates &amp;&amp; self.validatesDomainName &amp;&amp; (self.SSLPinningMode == AFSSLPinningModeNone || [self.pinnedCertificates count] == 0)) {
     NSLog(@"In order to validate a domain name for self signed certificates, you MUST use pinning.");
     return NO;
 }
</code></pre></div>    </div>

    <blockquote>
      <p>Do not implicitly trust self-signed certificates as anchors (kSecTrustOptionImplicitAnchors).
Instead, add your own (self-signed) CA certificate to the list of trusted anchors.</p>
    </blockquote>

    <ul>
      <li>所以如果没有提供证书或者不验证证书，并且还设置 <code class="highlighter-rouge">allowInvalidCertificates</code> 为<strong>真</strong>，满足上面的所有条件，说明这次的验证是不安全的，会直接返回 <code class="highlighter-rouge">NO</code></li>
    </ul>
  </li>
  <li>
    <p>设置 policy</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> NSMutableArray *policies = [NSMutableArray array];
 if (self.validatesDomainName) {
     [policies addObject:(__bridge_transfer id)SecPolicyCreateSSL(true, (__bridge CFStringRef)domain)];
 } else {
     [policies addObject:(__bridge_transfer id)SecPolicyCreateBasicX509()];
 }
</code></pre></div>    </div>

    <ul>
      <li>如果要验证域名的话，就以域名为参数创建一个 <code class="highlighter-rouge">SecPolicyRef</code>，否则会创建一个符合 X509 标准的默认 <code class="highlighter-rouge">SecPolicyRef</code> 对象</li>
    </ul>
  </li>
  <li>
    <p>验证证书的有效性</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> if (self.SSLPinningMode == AFSSLPinningModeNone) {
     return self.allowInvalidCertificates || AFServerTrustIsValid(serverTrust);
 } else if (!AFServerTrustIsValid(serverTrust) &amp;&amp; !self.allowInvalidCertificates) {
     return NO;
 }
</code></pre></div>    </div>

    <ul>
      <li>如果<strong>只根据信任列表中的证书</strong>进行验证，即 <code class="highlighter-rouge">self.SSLPinningMode == AFSSLPinningModeNone</code>。如果允许无效的证书的就会直接返回 <code class="highlighter-rouge">YES</code>。不允许就会对服务端信任进行验证。</li>
      <li>如果服务器信任无效，并且不允许无效证书，就会返回 <code class="highlighter-rouge">NO</code></li>
    </ul>
  </li>
  <li>
    <p>根据 <code class="highlighter-rouge">SSLPinningMode</code> 对服务器信任进行验证</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> switch (self.SSLPinningMode) {
     case AFSSLPinningModeNone:
     default:
         return NO;
     case AFSSLPinningModeCertificate: {
         ...
     }
     case AFSSLPinningModePublicKey: {
         ...
     }
 }
</code></pre></div>    </div>

    <ul>
      <li><code class="highlighter-rouge">AFSSLPinningModeNone</code> 直接返回 <code class="highlighter-rouge">NO</code></li>
      <li>
        <p><code class="highlighter-rouge">AFSSLPinningModeCertificate</code></p>

        <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  NSMutableArray *pinnedCertificates = [NSMutableArray array];
  for (NSData *certificateData in self.pinnedCertificates) {
      [pinnedCertificates addObject:(__bridge_transfer id)SecCertificateCreateWithData(NULL, (__bridge CFDataRef)certificateData)];
  }
  SecTrustSetAnchorCertificates(serverTrust, (__bridge CFArrayRef)pinnedCertificates);

  if (!AFServerTrustIsValid(serverTrust)) {
      return NO;
  }

  // obtain the chain after being validated, which *should* contain the pinned certificate in the last position (if it's the Root CA)
  NSArray *serverCertificates = AFCertificateTrustChainForServerTrust(serverTrust);

  for (NSData *trustChainCertificate in [serverCertificates reverseObjectEnumerator]) {
      if ([self.pinnedCertificates containsObject:trustChainCertificate]) {
          return YES;
      }
  }

  return NO;
</code></pre></div>        </div>

        <ol>
          <li>从 <code class="highlighter-rouge">self.pinnedCertificates</code> 中获取 DER 表示的数据</li>
          <li>使用 <code class="highlighter-rouge">SecTrustSetAnchorCertificates</code> 为服务器信任设置证书</li>
          <li>判断服务器信任的有效性</li>
          <li>使用 <code class="highlighter-rouge">AFCertificateTrustChainForServerTrust</code> 获取服务器信任中的全部 DER 表示的证书</li>
          <li>如果 <code class="highlighter-rouge">pinnedCertificates</code> 中有相同的证书，就会返回 <code class="highlighter-rouge">YES</code></li>
        </ol>
      </li>
      <li>
        <p><code class="highlighter-rouge">AFSSLPinningModePublicKey</code></p>

        <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  NSUInteger trustedPublicKeyCount = 0;
  NSArray *publicKeys = AFPublicKeyTrustChainForServerTrust(serverTrust);

  for (id trustChainPublicKey in publicKeys) {
      for (id pinnedPublicKey in self.pinnedPublicKeys) {
          if (AFSecKeyIsEqualToKey((__bridge SecKeyRef)trustChainPublicKey, (__bridge SecKeyRef)pinnedPublicKey)) {
              trustedPublicKeyCount += 1;
          }
      }
  }
  return trustedPublicKeyCount &gt; 0;
</code></pre></div>        </div>

        <ul>
          <li>这部分的实现和上面的差不多，区别有两点
            <ol>
              <li>会从服务器信任中获取公钥</li>
              <li><code class="highlighter-rouge">pinnedPublicKeys</code> 中的公钥与服务器信任中的公钥相同的数量大于 0，就会返回真</li>
            </ol>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<h2 id="与-afurlsessionmanager-协作">与 AFURLSessionManager 协作</h2>

<p>在代理协议 <code class="highlighter-rouge">- URLSession:didReceiveChallenge:completionHandler:</code> 或者 <code class="highlighter-rouge">- URLSession:task:didReceiveChallenge:completionHandler:</code> 代理方法被调用时会运行这段代码</p>

<pre><code class="language-objectivec">if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) {
    if ([self.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) {
        disposition = NSURLSessionAuthChallengeUseCredential;
        credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust];
    } else {
        disposition = NSURLSessionAuthChallengeRejectProtectionSpace;
    }
} else {
    disposition = NSURLSessionAuthChallengePerformDefaultHandling;
}
</code></pre>

<p><code class="highlighter-rouge">NSURLAuthenticationChallenge</code> 表示一个认证的挑战，提供了关于这次认证的全部信息。它有一个非常重要的属性 <code class="highlighter-rouge">protectionSpace</code>，这里保存了需要认证的保护空间, 每一个 <code class="highlighter-rouge">NSURLProtectionSpace</code> 对象都保存了主机地址，端口和认证方法等重要信息。</p>

<p>在上面的方法中，如果保护空间中的认证方法为 <code class="highlighter-rouge">NSURLAuthenticationMethodServerTrust</code>，那么就会使用在上一小节中提到的方法 <code class="highlighter-rouge">- [AFSecurityPolicy evaluateServerTrust:forDomain:]</code> 对保护空间中的 <code class="highlighter-rouge">serverTrust</code> 以及域名 <code class="highlighter-rouge">host</code> 进行认证</p>

<p>根据认证的结果，会在 <code class="highlighter-rouge">completionHandler</code> 中传入不同的 <code class="highlighter-rouge">disposition</code> 和 <code class="highlighter-rouge">credential</code> 参数。</p>

<h2 id="小结">小结</h2>

<ul>
  <li><code class="highlighter-rouge">AFSecurityPolicy</code> 同样也作为一个即插即用的模块，在 AFNetworking 中作为验证 HTTPS 证书是否有效的模块存在，在 iOS 对 HTTPS 日渐重视的今天，在我看来，使用 HTTPS 会成为今后 API 开发的标配。</li>
</ul>

<h2 id="相关文章">相关文章</h2>

<p>关于其他 AFNetworking 源代码分析的其他文章：</p>

<ul>
  <li><a href="http://draveness.me/afnetworking1">AFNetworking 概述（一）</a></li>
  <li><a href="http://draveness.me/afnetworking2">AFNetworking 的核心 AFURLSessionManager（二）</a></li>
  <li><a href="http://draveness.me/afnetworking3">处理请求和响应 AFURLSerialization（三）</a></li>
  <li><a href="http://draveness.me/afnetworking4">AFNetworkReachabilityManager 监控网络状态（四）</a></li>
  <li><a href="http://draveness.me/afnetworking5">验证 HTTPS 请求的证书（五）</a></li>
</ul>

<iframe src="http://ghbtns.com/github-btn.html?user=draveness&amp;type=follow&amp;size=large" height="30" width="240" frameborder="0" scrolling="0" style="width:240px; height: 30px;" allowtransparency="true"></iframe>

<p>Blog: <a href="http://draveness.me">Draveness</a></p>


	  ]]></description>
	</item>

	<item>
	  <title>AFNetworkReachabilityManager 监控网络状态（四）</title>
	  <link>/reprinted//afnetworking4</link>
	  <author></author>
	  <pubDate>2016-04-13T14:58:12+00:00</pubDate>
	  <guid>/reprinted//afnetworking4</guid>
	  <description><![CDATA[
	     <p>Blog: <a href="http://draveness.me">Draveness</a></p>

<iframe src="http://ghbtns.com/github-btn.html?user=draveness&amp;type=follow&amp;size=large" height="30" width="240" frameborder="0" scrolling="0" style="width:240px; height: 30px;" allowtransparency="true"></iframe>

<p>关注仓库，及时获得更新：<a href="https://github.com/draveness/iOS-Source-Code-Analyze">iOS-Source-Code-Analyze</a></p>

<p><code class="highlighter-rouge">AFNetworkReachabilityManager</code> 是对 <code class="highlighter-rouge">SystemConfiguration</code> 模块的封装，苹果的文档中也有一个类似的项目 <a href="https://developer.apple.com/library/ios/samplecode/reachability/">Reachability</a> 这里对网络状态的监控跟苹果官方的实现几乎是完全相同的。</p>

<p>同样在 github 上有一个类似的项目叫做 <a href="https://github.com/tonymillion/Reachability">Reachability</a> 不过这个项目<strong>由于命名的原因可能会在审核时被拒绝</strong>。</p>

<p>无论是 <code class="highlighter-rouge">AFNetworkReachabilityManager</code>，苹果官方的项目或者说 github 上的 Reachability，它们的实现都是类似的，而在这里我们会以 <code class="highlighter-rouge">AFNetworking</code> 中的 <code class="highlighter-rouge">AFNetworkReachabilityManager</code> 为例来说明在 iOS 开发中，我们是怎样监控网络状态的。</p>

<h2 id="afnetworkreachabilitymanager-的使用和实现">AFNetworkReachabilityManager 的使用和实现</h2>

<p><code class="highlighter-rouge">AFNetworkReachabilityManager</code> 的使用还是非常简单的，只需要三个步骤，就基本可以完成对网络状态的监控。</p>

<ol>
  <li><a href="#init">初始化 <code class="highlighter-rouge">AFNetworkReachabilityManager</code></a></li>
  <li><a href="#monitor">调用 <code class="highlighter-rouge">startMonitoring</code> 方法开始对网络状态进行监控</a></li>
  <li><a href="#block">设置 <code class="highlighter-rouge">networkReachabilityStatusBlock</code> 在每次网络状态改变时, 调用这个 block</a></li>
</ol>

<h3 id="初始化-afnetworkreachabilitymanager"><a id="init"></a>初始化 AFNetworkReachabilityManager</h3>

<p>在初始化方法中，使用 <code class="highlighter-rouge">SCNetworkReachabilityCreateWithAddress</code> 或者 <code class="highlighter-rouge">SCNetworkReachabilityCreateWithName</code> 生成一个 <code class="highlighter-rouge">SCNetworkReachabilityRef</code> 的引用。</p>

<pre><code class="language-objectivec">+ (instancetype)managerForDomain:(NSString *)domain {
    SCNetworkReachabilityRef reachability = SCNetworkReachabilityCreateWithName(kCFAllocatorDefault, [domain UTF8String]);

    AFNetworkReachabilityManager *manager = [[self alloc] initWithReachability:reachability];

    return manager;
}

+ (instancetype)managerForAddress:(const void *)address {
    SCNetworkReachabilityRef reachability = SCNetworkReachabilityCreateWithAddress(kCFAllocatorDefault, (const struct sockaddr *)address);
    AFNetworkReachabilityManager *manager = [[self alloc] initWithReachability:reachability];

    return manager;
}
</code></pre>

<ol>
  <li>这两个方法会通过一个<strong>域名</strong>或者一个 <code class="highlighter-rouge">sockaddr_in</code> 的指针生成一个 <code class="highlighter-rouge">SCNetworkReachabilityRef</code></li>
  <li>调用 <code class="highlighter-rouge">- [AFNetworkReachabilityManager initWithReachability:]</code> 将生成的 <code class="highlighter-rouge">SCNetworkReachabilityRef</code> 引用传给 <code class="highlighter-rouge">networkReachability</code></li>
  <li>设置一个默认的 <code class="highlighter-rouge">networkReachabilityStatus</code></li>
</ol>

<pre><code class="language-objectivec">- (instancetype)initWithReachability:(SCNetworkReachabilityRef)reachability {
    self = [super init];
    if (!self) {
        return nil;
    }

    self.networkReachability = CFBridgingRelease(reachability);
    self.networkReachabilityStatus = AFNetworkReachabilityStatusUnknown;

    return self;
}
</code></pre>

<blockquote>
  <p>当调用 <code class="highlighter-rouge">CFBridgingRelease(reachability)</code> 后，会把 <code class="highlighter-rouge">reachability</code> 桥接成一个 NSObject 对象赋值给 <code class="highlighter-rouge">self.networkReachability</code>，然后释放原来的 CoreFoundation 对象。</p>
</blockquote>

<h3 id="监控网络状态"><a id="monitor"></a>监控网络状态</h3>

<p>在初始化 <code class="highlighter-rouge">AFNetworkReachabilityManager</code> 后，会调用 <code class="highlighter-rouge">startMonitoring</code> 方法开始监控网络状态。</p>

<pre><code class="language-objectivec">- (void)startMonitoring {
    [self stopMonitoring];

    if (!self.networkReachability) {
        return;
    }

    __weak __typeof(self)weakSelf = self;
    AFNetworkReachabilityStatusBlock callback = ^(AFNetworkReachabilityStatus status) {
        __strong __typeof(weakSelf)strongSelf = weakSelf;

        strongSelf.networkReachabilityStatus = status;
        if (strongSelf.networkReachabilityStatusBlock) {
            strongSelf.networkReachabilityStatusBlock(status);
        }

    };

    id networkReachability = self.networkReachability;
    SCNetworkReachabilityContext context = {0, (__bridge void *)callback, AFNetworkReachabilityRetainCallback, AFNetworkReachabilityReleaseCallback, NULL};
    SCNetworkReachabilitySetCallback((__bridge SCNetworkReachabilityRef)networkReachability, AFNetworkReachabilityCallback, &amp;context);
    SCNetworkReachabilityScheduleWithRunLoop((__bridge SCNetworkReachabilityRef)networkReachability, CFRunLoopGetMain(), kCFRunLoopCommonModes);

    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0),^{
        SCNetworkReachabilityFlags flags;
        if (SCNetworkReachabilityGetFlags((__bridge SCNetworkReachabilityRef)networkReachability, &amp;flags)) {
            AFPostReachabilityStatusChange(flags, callback);
        }
    });
}
</code></pre>

<ol>
  <li>
    <p>先调用 <code class="highlighter-rouge">- stopMonitoring</code> 方法，如果之前设置过对网络状态的监听，使用 <code class="highlighter-rouge">SCNetworkReachabilityUnscheduleFromRunLoop</code> 方法取消之前在 Main Runloop 中的监听</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> - (void)stopMonitoring {
     if (!self.networkReachability) {
         return;
     }

     SCNetworkReachabilityUnscheduleFromRunLoop((__bridge SCNetworkReachabilityRef)self.networkReachability, CFRunLoopGetMain(), kCFRunLoopCommonModes);
 }
</code></pre></div>    </div>
  </li>
  <li>
    <p>创建一个在每次网络状态改变时的回调</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> __weak __typeof(self)weakSelf = self;
 AFNetworkReachabilityStatusBlock callback = ^(AFNetworkReachabilityStatus status) {
     __strong __typeof(weakSelf)strongSelf = weakSelf;

     strongSelf.networkReachabilityStatus = status;
     if (strongSelf.networkReachabilityStatusBlock) {
         strongSelf.networkReachabilityStatusBlock(status);
     }

 };
</code></pre></div>    </div>

    <ul>
      <li>每次回调被调用时
        <ul>
          <li>重新设置 <code class="highlighter-rouge">networkReachabilityStatus</code> 属性</li>
          <li>调用 <code class="highlighter-rouge">networkReachabilityStatusBlock</code></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>创建一个 <code class="highlighter-rouge">SCNetworkReachabilityContext</code></p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> typedef struct {
     CFIndex		version;
     void *		__nullable info;
     const void	* __nonnull (* __nullable retain)(const void *info);
     void		(* __nullable release)(const void *info);
     CFStringRef	__nonnull (* __nullable copyDescription)(const void *info);
 } SCNetworkReachabilityContext;

 SCNetworkReachabilityContext context = {
     0,
     (__bridge void *)callback,
     AFNetworkReachabilityRetainCallback,
     AFNetworkReachabilityReleaseCallback,
     NULL
 };
</code></pre></div>    </div>

    <ul>
      <li>其中的 <code class="highlighter-rouge">callback</code> 就是上一步中的创建的 block 对象</li>
      <li>这里的 <code class="highlighter-rouge">AFNetworkReachabilityRetainCallback</code> 和 <code class="highlighter-rouge">AFNetworkReachabilityReleaseCallback</code> 都是非常简单的 block，在回调被调用时，只是使用 <code class="highlighter-rouge">Block_copy</code> 和 <code class="highlighter-rouge">Block_release</code> 这样的宏</li>
      <li>
        <p>传入的 <code class="highlighter-rouge">info</code> 会以参数的形式在 <code class="highlighter-rouge">AFNetworkReachabilityCallback</code> 执行时传入</p>

        <p>static const void * AFNetworkReachabilityRetainCallback(const void *info) {
      return Block_copy(info);
  }</p>

        <p>static void AFNetworkReachabilityReleaseCallback(const void *info) {
      if (info) {
          Block_release(info);
      }
  }</p>
      </li>
    </ul>
  </li>
  <li>
    <p>当目标的网络状态改变时，会调用传入的回调</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> SCNetworkReachabilitySetCallback(
     (__bridge SCNetworkReachabilityRef)networkReachability,
     AFNetworkReachabilityCallback,
     &amp;context
 );
</code></pre></div>    </div>
  </li>
  <li>
    <p>在 Main Runloop 中对应的模式开始监控网络状态</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> SCNetworkReachabilityScheduleWithRunLoop(
     (__bridge SCNetworkReachabilityRef)networkReachability,
     CFRunLoopGetMain(),
     kCFRunLoopCommonModes
 );
</code></pre></div>    </div>
  </li>
  <li>
    <p>获取当前的网络状态，调用 callback</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0),^{
     SCNetworkReachabilityFlags flags;
     if (SCNetworkReachabilityGetFlags((__bridge SCNetworkReachabilityRef)networkReachability, &amp;flags)) {
         AFPostReachabilityStatusChange(flags, callback);
     }
 });
</code></pre></div>    </div>
  </li>
</ol>

<p>在下一节中会介绍上面所提到的一些 C 函数以及各种回调。</p>

<h3 id="设置-networkreachabilitystatusblock-以及回调"><a id="block"></a>设置 networkReachabilityStatusBlock 以及回调</h3>

<p>在 Main Runloop 中对网络状态进行监控之后，在每次网络状态改变，就会调用 <code class="highlighter-rouge">AFNetworkReachabilityCallback</code> 函数：</p>

<pre><code class="language-objectivec">static void AFNetworkReachabilityCallback(SCNetworkReachabilityRef __unused target, SCNetworkReachabilityFlags flags, void *info) {
    AFPostReachabilityStatusChange(flags, (__bridge AFNetworkReachabilityStatusBlock)info);
}
</code></pre>

<p>这里会从 <code class="highlighter-rouge">info</code> 中取出之前存在 <code class="highlighter-rouge">context</code> 中的 <code class="highlighter-rouge">AFNetworkReachabilityStatusBlock</code>。</p>

<pre><code class="language-objectivec">__weak __typeof(self)weakSelf = self;
AFNetworkReachabilityStatusBlock callback = ^(AFNetworkReachabilityStatus status) {
    __strong __typeof(weakSelf)strongSelf = weakSelf;

    strongSelf.networkReachabilityStatus = status;
    if (strongSelf.networkReachabilityStatusBlock) {
        strongSelf.networkReachabilityStatusBlock(status);
    }

};
</code></pre>

<p>取出这个 block 之后，传入 <code class="highlighter-rouge">AFPostReachabilityStatusChange</code> 函数：</p>

<pre><code class="language-objectivec">static void AFPostReachabilityStatusChange(SCNetworkReachabilityFlags flags, AFNetworkReachabilityStatusBlock block) {
    AFNetworkReachabilityStatus status = AFNetworkReachabilityStatusForFlags(flags);
    dispatch_async(dispatch_get_main_queue(), ^{
        if (block) {
            block(status);
        }
        NSNotificationCenter *notificationCenter = [NSNotificationCenter defaultCenter];
        NSDictionary *userInfo = @{ AFNetworkingReachabilityNotificationStatusItem: @(status) };
        [notificationCenter postNotificationName:AFNetworkingReachabilityDidChangeNotification object:nil userInfo:userInfo];
    });
}
</code></pre>

<ol>
  <li>调用 <code class="highlighter-rouge">AFNetworkReachabilityStatusForFlags</code> 获取当前的网络可达性状态</li>
  <li><strong>在主线程中异步执行</strong>上面传入的 <code class="highlighter-rouge">callback</code> block（设置 <code class="highlighter-rouge">self</code> 的网络状态，调用 <code class="highlighter-rouge">networkReachabilityStatusBlock</code>）</li>
  <li>发送 <code class="highlighter-rouge">AFNetworkingReachabilityDidChangeNotification</code> 通知.</li>
</ol>

<pre><code class="language-objectivec">static AFNetworkReachabilityStatus AFNetworkReachabilityStatusForFlags(SCNetworkReachabilityFlags flags) {
    BOOL isReachable = ((flags &amp; kSCNetworkReachabilityFlagsReachable) != 0);
    BOOL needsConnection = ((flags &amp; kSCNetworkReachabilityFlagsConnectionRequired) != 0);
    BOOL canConnectionAutomatically = (((flags &amp; kSCNetworkReachabilityFlagsConnectionOnDemand ) != 0) || ((flags &amp; kSCNetworkReachabilityFlagsConnectionOnTraffic) != 0));
    BOOL canConnectWithoutUserInteraction = (canConnectionAutomatically &amp;&amp; (flags &amp; kSCNetworkReachabilityFlagsInterventionRequired) == 0);
    BOOL isNetworkReachable = (isReachable &amp;&amp; (!needsConnection || canConnectWithoutUserInteraction));

    AFNetworkReachabilityStatus status = AFNetworkReachabilityStatusUnknown;
    if (isNetworkReachable == NO) {
        status = AFNetworkReachabilityStatusNotReachable;
    }
#if	TARGET_OS_IPHONE
    else if ((flags &amp; kSCNetworkReachabilityFlagsIsWWAN) != 0) {
        status = AFNetworkReachabilityStatusReachableViaWWAN;
    }
#endif
    else {
        status = AFNetworkReachabilityStatusReachableViaWiFi;
    }

    return status;
}
</code></pre>

<p>因为 <code class="highlighter-rouge">flags</code> 是一个 <code class="highlighter-rouge">SCNetworkReachabilityFlags</code>，它的不同位代表了不同的网络可达性状态，通过 <code class="highlighter-rouge">flags</code> 的位操作，获取当前的状态信息 <code class="highlighter-rouge">AFNetworkReachabilityStatus</code>。</p>

<pre><code class="language-objectivec">typedef CF_OPTIONS(uint32_t, SCNetworkReachabilityFlags) {
	kSCNetworkReachabilityFlagsTransientConnection	= 1&lt;&lt;0,
	kSCNetworkReachabilityFlagsReachable		= 1&lt;&lt;1,
	kSCNetworkReachabilityFlagsConnectionRequired	= 1&lt;&lt;2,
	kSCNetworkReachabilityFlagsConnectionOnTraffic	= 1&lt;&lt;3,
	kSCNetworkReachabilityFlagsInterventionRequired	= 1&lt;&lt;4,
	kSCNetworkReachabilityFlagsConnectionOnDemand	= 1&lt;&lt;5,	// __OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_3_0)
	kSCNetworkReachabilityFlagsIsLocalAddress	= 1&lt;&lt;16,
	kSCNetworkReachabilityFlagsIsDirect		= 1&lt;&lt;17,
#if	TARGET_OS_IPHONE
	kSCNetworkReachabilityFlagsIsWWAN		= 1&lt;&lt;18,
#endif	// TARGET_OS_IPHONE

	kSCNetworkReachabilityFlagsConnectionAutomatic	= kSCNetworkReachabilityFlagsConnectionOnTraffic
};
</code></pre>

<p>这里就是在 <code class="highlighter-rouge">SystemConfiguration</code> 中定义的全部的网络状态的标志位。</p>

<h2 id="与-afnetworking-协作">与 AFNetworking 协作</h2>

<p>其实这个类与 <code class="highlighter-rouge">AFNetworking</code> 整个框架并没有太多的耦合。正相反，它在整个框架中作为一个<strong>即插即用</strong>的类使用，每一个 <code class="highlighter-rouge">AFURLSessionManager</code> 都会持有一个 <code class="highlighter-rouge">AFNetworkReachabilityManager</code> 的实例。</p>

<pre><code class="language-objectivec">self.reachabilityManager = [AFNetworkReachabilityManager sharedManager];
</code></pre>

<p>这是整个框架中除了 <code class="highlighter-rouge">AFNetworkReachabilityManager.h/m</code> 文件，<strong>唯一一个</strong>引用到这个类的地方。</p>

<p>在实际的使用中，我们也可以直接操作 <code class="highlighter-rouge">AFURLSessionManager</code> 的 <code class="highlighter-rouge">reachabilityManager</code> 来获取当前的网络可达性状态，而不是自己手动初始化一个实例，当然这么做也是没有任何问题的。</p>

<h2 id="总结">总结</h2>

<ol>
  <li><code class="highlighter-rouge">AFNetworkReachabilityManager</code> 实际上只是一个对底层 <code class="highlighter-rouge">SystemConfiguration</code> 库中的 C 函数封装的类，它为我们隐藏了 C 语言的实现，提供了统一的 Objective-C 语言接口</li>
  <li>它是 <code class="highlighter-rouge">AFNetworking</code> 中一个即插即用的模块</li>
</ol>

<h2 id="相关文章">相关文章</h2>

<p>关于其他 AFNetworking 源代码分析的其他文章：</p>

<ul>
  <li><a href="http://draveness.me/afnetworking1">AFNetworking 概述（一）</a></li>
  <li><a href="http://draveness.me/afnetworking2">AFNetworking 的核心 AFURLSessionManager（二）</a></li>
  <li><a href="http://draveness.me/afnetworking3">处理请求和响应 AFURLSerialization（三）</a></li>
  <li><a href="http://draveness.me/afnetworking4">AFNetworkReachabilityManager 监控网络状态（四）</a></li>
  <li><a href="http://draveness.me/afnetworking5">验证 HTTPS 请求的证书（五）</a></li>
</ul>

<iframe src="http://ghbtns.com/github-btn.html?user=draveness&amp;type=follow&amp;size=large" height="30" width="240" frameborder="0" scrolling="0" style="width:240px; height: 30px;" allowtransparency="true"></iframe>

<p>Blog: <a href="http://draveness.me">Draveness</a></p>


	  ]]></description>
	</item>

	<item>
	  <title>处理请求和响应 AFURLSerialization（三）</title>
	  <link>/reprinted//afnetworking3</link>
	  <author></author>
	  <pubDate>2016-04-12T14:01:09+00:00</pubDate>
	  <guid>/reprinted//afnetworking3</guid>
	  <description><![CDATA[
	     <p>Blog: <a href="http://draveness.me">Draveness</a></p>

<iframe src="http://ghbtns.com/github-btn.html?user=draveness&amp;type=follow&amp;size=large" height="30" width="240" frameborder="0" scrolling="0" style="width:240px; height: 30px;" allowtransparency="true"></iframe>

<p>关注仓库，及时获得更新：<a href="https://github.com/draveness/iOS-Source-Code-Analyze">iOS-Source-Code-Analyze</a></p>

<p>在前面两个部分已经分析过 <code class="highlighter-rouge">AFNetworking</code> 是对 <code class="highlighter-rouge">NSURLSession</code> 的封装，也了解了它是如何发出请求的，在这里我们<strong>对发出请求以及接收响应的过程</strong>进行序列化，这涉及到两个<strong>模块</strong>：</p>

<ul>
  <li><a href="#AFURLResponseSerialization">AFURLResponseSerialization</a></li>
  <li><a href="#AFURLRequestSerialization">AFURLRequestSerialization</a></li>
</ul>

<p>前者是处理响应的模块，将请求返回的数据解析成对应的格式。而后者的主要作用是修改请求（主要是 HTTP 请求）的头部，提供了一些语义明确的接口设置 HTTP 头部字段。</p>

<p>我们首先会对 <code class="highlighter-rouge">AFURLResponseSerialization</code> 进行简单的介绍，因为这个模块使用在 <code class="highlighter-rouge">AFURLSessionManager</code> 也就是核心类中，而后者 <code class="highlighter-rouge">AFURLRequestSerialization</code> 主要用于 <code class="highlighter-rouge">AFHTTPSessionManager</code> 中，因为它主要用于<strong>修改 HTTP 头部</strong>。</p>

<h2 id="afurlresponseserialization">AFURLResponseSerialization</h2>

<p>其实在整个 <code class="highlighter-rouge">AFNetworking</code> 项目中并不存在 <code class="highlighter-rouge">AFURLResponseSerialization</code> 这个类，这只是一个协议，<strong>遵循这个协议的类会将数据解码成更有意义的表现形式</strong>。</p>

<p>协议的内容也非常简单，只有一个必须实现的方法。</p>

<pre><code class="language-objectivec">@protocol AFURLResponseSerialization &lt;NSObject, NSSecureCoding, NSCopying&gt;

- (nullable id)responseObjectForResponse:(nullable NSURLResponse *)response
                           data:(nullable NSData *)data
                          error:(NSError * _Nullable __autoreleasing *)error NS_SWIFT_NOTHROW;

@end
</code></pre>

<p>遵循这个协议的类同时也要遵循 NSObject、NSSecureCoding 和 NSCopying 这三个协议，实现安全编码、拷贝以及 Objective-C 对象的基本行为。</p>

<p>仅看 <code class="highlighter-rouge">AFURLResponseSerialization</code> 协议对类的要求还是十分的简单，返回<strong>对特定响应的数据解码后的对象</strong>.</p>

<p>在具体了解模块中类的实现之前，先看一下这个小模块的结构：</p>

<p><img src="media/14598507516362/AFURLResponseSerialization.png" alt="AFURLResponseSerialization" /></p>

<ul>
  <li>模块中的所有类都遵循 <code class="highlighter-rouge">AFURLResponseSerialization</code> 协议</li>
  <li><code class="highlighter-rouge">AFHTTPResponseSerializer</code> 为模块中最终要的根类</li>
</ul>

<h3 id="afhttpresponseserializer">AFHTTPResponseSerializer</h3>

<p>下面我们对模块中最重要的根类的实现进行分析，也就是 <code class="highlighter-rouge">AFHTTPResponseSerializer</code>。它是在 <code class="highlighter-rouge">AFURLResponseSerialization</code> 模块中最基本的类（因为 <code class="highlighter-rouge">AFURLResponseSerialization</code> 只是一个协议）</p>

<h4 id="初始化">初始化</h4>

<p>首先是这个类的实例化方法：</p>

<pre><code class="language-objectivec">+ (instancetype)serializer {
    return [[self alloc] init];
}

- (instancetype)init {
    self = [super init];
    if (!self) {
        return nil;
    }

    self.stringEncoding = NSUTF8StringEncoding;

    self.acceptableStatusCodes = [NSIndexSet indexSetWithIndexesInRange:NSMakeRange(200, 100)];
    self.acceptableContentTypes = nil;

    return self;
}
</code></pre>

<p>因为是对 HTTP 响应进行序列化，所以这里设置了 <code class="highlighter-rouge">stringEncoding</code> 为 <code class="highlighter-rouge">NSUTF8StringEncoding</code> 而且没有对接收的内容类型加以限制。</p>

<p>将 <code class="highlighter-rouge">acceptableStatusCodes</code> 设置为从 200 到 299 之间的状态码, 因为只有这些状态码表示<strong>获得了有效的响应</strong>。</p>

<h4 id="验证响应的有效性">验证响应的有效性</h4>

<p><code class="highlighter-rouge">AFHTTPResponseSerializer</code> 中方法的实现最长，并且最重要的就是 <code class="highlighter-rouge">- [AFHTTPResponseSerializer validateResponse:data:error:]</code></p>

<pre><code class="language-objectivec">- (BOOL)validateResponse:(NSHTTPURLResponse *)response
                    data:(NSData *)data
                   error:(NSError * __autoreleasing *)error
{
    BOOL responseIsValid = YES;
    NSError *validationError = nil;

    if (response &amp;&amp; [response isKindOfClass:[NSHTTPURLResponse class]]) {
        if (self.acceptableContentTypes &amp;&amp; ![self.acceptableContentTypes containsObject:[response MIMEType]]) {
			#1: 返回内容类型无效
        }

        if (self.acceptableStatusCodes &amp;&amp; ![self.acceptableStatusCodes containsIndex:(NSUInteger)response.statusCode] &amp;&amp; [response URL]) {
			#2: 返回状态码无效
        }
    }

    if (error &amp;&amp; !responseIsValid) {
        *error = validationError;
    }

    return responseIsValid;
}
</code></pre>

<p>这个方法根据在初始化方法中初始化的属性 <code class="highlighter-rouge">acceptableContentTypes</code> 和 <code class="highlighter-rouge">acceptableStatusCodes</code> 来判断当前响应是否有效。</p>

<pre><code class="language-objectivec">if ([data length] &gt; 0 &amp;&amp; [response URL]) {
    NSMutableDictionary *mutableUserInfo = [@{
                                              NSLocalizedDescriptionKey: [NSString stringWithFormat:NSLocalizedStringFromTable(@"Request failed: unacceptable content-type: %@", @"AFNetworking", nil), [response MIMEType]],
                                              NSURLErrorFailingURLErrorKey:[response URL],
                                              AFNetworkingOperationFailingURLResponseErrorKey: response,
                                            } mutableCopy];
    if (data) {
        mutableUserInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] = data;
    }

    validationError = AFErrorWithUnderlyingError([NSError errorWithDomain:AFURLResponseSerializationErrorDomain code:NSURLErrorCannotDecodeContentData userInfo:mutableUserInfo], validationError);
}

responseIsValid = NO;
</code></pre>

<p>其中第一、二部分的代码非常相似，出现错误时通过 <code class="highlighter-rouge">AFErrorWithUnderlyingError</code> 生成格式化之后的错误，最后设置 <code class="highlighter-rouge">responseIsValid</code>。</p>

<pre><code class="language-objectivec">NSMutableDictionary *mutableUserInfo = [@{
                                   NSLocalizedDescriptionKey: [NSString stringWithFormat:NSLocalizedStringFromTable(@"Request failed: %@ (%ld)", @"AFNetworking", nil), [NSHTTPURLResponse localizedStringForStatusCode:response.statusCode], (long)response.statusCode],
                                   NSURLErrorFailingURLErrorKey:[response URL],
                                   AFNetworkingOperationFailingURLResponseErrorKey: response,
                           } mutableCopy];

if (data) {
    mutableUserInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] = data;
}

validationError = AFErrorWithUnderlyingError([NSError errorWithDomain:AFURLResponseSerializationErrorDomain code:NSURLErrorBadServerResponse userInfo:mutableUserInfo], validationError);

responseIsValid = NO;
</code></pre>

<p>第二部分的代码就不说了，实现上都是差不多的。</p>

<h4 id="协议的实现">协议的实现</h4>

<p>首先是对 <code class="highlighter-rouge">AFURLResponseSerialization</code> 协议的实现</p>

<pre><code class="language-objectivec">- (id)responseObjectForResponse:(NSURLResponse *)response
                           data:(NSData *)data
                          error:(NSError *__autoreleasing *)error
{
    [self validateResponse:(NSHTTPURLResponse *)response data:data error:error];

    return data;
}
</code></pre>

<p>调用上面的方法对响应进行验证，然后返回数据，实在是没什么难度。</p>

<p>之后对 <code class="highlighter-rouge">NSSecureCoding</code> 还有 <code class="highlighter-rouge">NSCopying</code> 协议的实现也都是大同小异，跟我们实现这些协议没什么区别，更没什么值得看的地方。</p>

<h3 id="afjsonresponseserializer">AFJSONResponseSerializer</h3>

<p>接下来，看一下 <code class="highlighter-rouge">AFJSONResponseSerializer</code> 这个继承自 <code class="highlighter-rouge">AFHTTPResponseSerializer</code> 类的实现。</p>

<p>初始化方法只是在调用父类的初始化方法之后更新了 <code class="highlighter-rouge">acceptableContentTypes</code> 属性：</p>

<pre><code class="language-objectivec">- (instancetype)init {
    self = [super init];
    if (!self) {
        return nil;
    }

    self.acceptableContentTypes = [NSSet setWithObjects:@"application/json", @"text/json", @"text/javascript", nil];

    return self;
}
</code></pre>

<h4 id="协议的实现-1">协议的实现</h4>

<p>这个类中与父类差别最大的就是对 <code class="highlighter-rouge">AFURLResponseSerialization</code> 协议的实现。</p>

<pre><code class="language-objectivec">- (id)responseObjectForResponse:(NSURLResponse *)response
                           data:(NSData *)data
                          error:(NSError *__autoreleasing *)error
{
	#1: 验证请求

	#2: 解决一个由只包含一个空格的响应引起的 bug, 略

	#3: 序列化 JSON

	#4: 移除 JSON 中的 null

    if (error) {
        *error = AFErrorWithUnderlyingError(serializationError, *error);
    }

    return responseObject;
}
</code></pre>

<ol>
  <li>
    <p>验证请求的有效性</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> NSStringEncoding stringEncoding = self.stringEncoding;
 if (response.textEncodingName) {
     CFStringEncoding encoding = CFStringConvertIANACharSetNameToEncoding((CFStringRef)response.textEncodingName);
     if (encoding != kCFStringEncodingInvalidId) {
         stringEncoding = CFStringConvertEncodingToNSStringEncoding(encoding);
     }
 }
</code></pre></div>    </div>
  </li>
  <li>解决一个空格引起的 <a href="https://github.com/rails/rails/issues/1742">bug</a></li>
  <li>
    <p>序列化 JSON</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> id responseObject = nil;
 NSError *serializationError = nil;
 @autoreleasepool {
     NSString *responseString = [[NSString alloc] initWithData:data encoding:stringEncoding];
     if (responseString &amp;&amp; ![responseString isEqualToString:@" "]) {
         // Workaround for a bug in NSJSONSerialization when Unicode character escape codes are used instead of the actual character
         // See http://stackoverflow.com/a/12843465/157142
         data = [responseString dataUsingEncoding:NSUTF8StringEncoding];

         if (data) {
             if ([data length] &gt; 0) {
                 responseObject = [NSJSONSerialization JSONObjectWithData:data options:self.readingOptions error:&amp;serializationError];
             } else {
                 return nil;
             }
         } else {
             NSDictionary *userInfo = @{
                                        NSLocalizedDescriptionKey: NSLocalizedStringFromTable(@"Data failed decoding as a UTF-8 string", @"AFNetworking", nil),
                                        NSLocalizedFailureReasonErrorKey: [NSString stringWithFormat:NSLocalizedStringFromTable(@"Could not decode string: %@", @"AFNetworking", nil), responseString]
                                        };

             serializationError = [NSError errorWithDomain:AFURLResponseSerializationErrorDomain code:NSURLErrorCannotDecodeContentData userInfo:userInfo];
         }
     }
 }
</code></pre></div>    </div>
  </li>
  <li>
    <p>移除 JSON 中的 null</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> if (self.removesKeysWithNullValues &amp;&amp; responseObject) {
     responseObject = AFJSONObjectByRemovingKeysWithNullValues(responseObject, self.readingOptions);
 }
</code></pre></div>    </div>
  </li>
</ol>

<p>其中移除 JSON 中 null 的函数 <code class="highlighter-rouge">AFJSONObjectByRemovingKeysWithNullValues</code> 是一个递归调用的函数：</p>

<pre><code class="language-objectivec">static id AFJSONObjectByRemovingKeysWithNullValues(id JSONObject, NSJSONReadingOptions readingOptions) {
    if ([JSONObject isKindOfClass:[NSArray class]]) {
        NSMutableArray *mutableArray = [NSMutableArray arrayWithCapacity:[(NSArray *)JSONObject count]];
        for (id value in (NSArray *)JSONObject) {
            [mutableArray addObject:AFJSONObjectByRemovingKeysWithNullValues(value, readingOptions)];
        }

        return (readingOptions &amp; NSJSONReadingMutableContainers) ? mutableArray : [NSArray arrayWithArray:mutableArray];
    } else if ([JSONObject isKindOfClass:[NSDictionary class]]) {
        NSMutableDictionary *mutableDictionary = [NSMutableDictionary dictionaryWithDictionary:JSONObject];
        for (id &lt;NSCopying&gt; key in [(NSDictionary *)JSONObject allKeys]) {
            id value = (NSDictionary *)JSONObject[key];
            if (!value || [value isEqual:[NSNull null]]) {
                [mutableDictionary removeObjectForKey:key];
            } else if ([value isKindOfClass:[NSArray class]] || [value isKindOfClass:[NSDictionary class]]) {
                mutableDictionary[key] = AFJSONObjectByRemovingKeysWithNullValues(value, readingOptions);
            }
        }

        return (readingOptions &amp; NSJSONReadingMutableContainers) ? mutableDictionary : [NSDictionary dictionaryWithDictionary:mutableDictionary];
    }

    return JSONObject;
}
</code></pre>

<p>其中移除 <code class="highlighter-rouge">null</code> 靠的就是 <code class="highlighter-rouge">[mutableDictionary removeObjectForKey:key]</code> 这一行代码。</p>

<h2 id="afurlrequestserialization">AFURLRequestSerialization</h2>

<p><code class="highlighter-rouge">AFURLRequestSerialization</code> 的主要工作是对发出的 HTTP 请求进行处理，它有几部分的工作需要完成。</p>

<p>而这个文件中的大部分类都是为 <code class="highlighter-rouge">AFHTTPRequestSerializer</code> 服务的：</p>

<ol>
  <li>处理查询的 URL 参数</li>
  <li>设置 HTTP 头部字段</li>
  <li>设置请求的属性</li>
  <li>分块上传</li>
</ol>

<blockquote>
  <p>这篇文章不会对其中涉及分块上传的部分进行分析，因为其中涉及到了多个类的功能，比较复杂，如果有兴趣可以研究一下。</p>
</blockquote>

<h3 id="处理查询参数">处理查询参数</h3>

<p>处理查询参数这部分主要是通过 <code class="highlighter-rouge">AFQueryStringPair</code> 还有一些 C 函数来完成的，这个类有两个属性 <code class="highlighter-rouge">field</code> 和 <code class="highlighter-rouge">value</code> 对应 HTTP 请求的查询 URL 中的参数。</p>

<pre><code class="language-objectivec">@interface AFQueryStringPair : NSObject
@property (readwrite, nonatomic, strong) id field;
@property (readwrite, nonatomic, strong) id value;

- (instancetype)initWithField:(id)field value:(id)value;

- (NSString *)URLEncodedStringValue;
@end
</code></pre>

<p>初始化方法也不必多看，其中的 <code class="highlighter-rouge">- [AFQueryStringPair URLEncodedStringValue]</code> 方法会返回 <code class="highlighter-rouge">key=value</code> 这种格式，同时使用 <code class="highlighter-rouge">AFPercentEscapedStringFromString</code> 函数来对 <code class="highlighter-rouge">field</code> 和 <code class="highlighter-rouge">value</code> 进行处理，将其中的 <code class="highlighter-rouge">:#[]@!$&amp;'()*+,;=</code> 等字符转换为百分号表示的形式。</p>

<p>这一部分代码还负责返回查询参数，将 <code class="highlighter-rouge">AFQueryStringPair</code> 或者 <code class="highlighter-rouge">key</code> <code class="highlighter-rouge">value</code> 转换为以下这种形式：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>username=dravenss&amp;password=123456&amp;hello[world]=helloworld
</code></pre></div></div>

<p>它的实现主要依赖于一个递归函数 <code class="highlighter-rouge">AFQueryStringPairsFromKeyAndValue</code>，如果当前的 <code class="highlighter-rouge">value</code> 是一个集合类型的话，那么它就会不断地递归调用自己。</p>

<pre><code class="language-objectivec">NSArray * AFQueryStringPairsFromKeyAndValue(NSString *key, id value) {
    NSMutableArray *mutableQueryStringComponents = [NSMutableArray array];

    NSSortDescriptor *sortDescriptor = [NSSortDescriptor sortDescriptorWithKey:@"description" ascending:YES selector:@selector(compare:)];

    if ([value isKindOfClass:[NSDictionary class]]) {
        NSDictionary *dictionary = value;
        // Sort dictionary keys to ensure consistent ordering in query string, which is important when deserializing potentially ambiguous sequences, such as an array of dictionaries
        for (id nestedKey in [dictionary.allKeys sortedArrayUsingDescriptors:@[ sortDescriptor ]]) {
            id nestedValue = dictionary[nestedKey];
            if (nestedValue) {
                [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue((key ? [NSString stringWithFormat:@"%@[%@]", key, nestedKey] : nestedKey), nestedValue)];
            }
        }
    } else if ([value isKindOfClass:[NSArray class]]) {
        NSArray *array = value;
        for (id nestedValue in array) {
            [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue([NSString stringWithFormat:@"%@[]", key], nestedValue)];
        }
    } else if ([value isKindOfClass:[NSSet class]]) {
        NSSet *set = value;
        for (id obj in [set sortedArrayUsingDescriptors:@[ sortDescriptor ]]) {
            [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue(key, obj)];
        }
    } else {
        [mutableQueryStringComponents addObject:[[AFQueryStringPair alloc] initWithField:key value:value]];
    }

    return mutableQueryStringComponents;
}
</code></pre>

<p>最后返回一个数组</p>

<pre><code class="language-objectivec">[
	username=draveness,
	password=123456,
	hello[world]=helloworld
]
</code></pre>

<p>得到这个数组之后就会调用 <code class="highlighter-rouge">AFQueryStringFromParameters</code> 使用 <code class="highlighter-rouge">&amp;</code> 来拼接它们。</p>

<pre><code class="language-objectivec">static NSString * AFQueryStringFromParameters(NSDictionary *parameters) {
    NSMutableArray *mutablePairs = [NSMutableArray array];
    for (AFQueryStringPair *pair in AFQueryStringPairsFromDictionary(parameters)) {
        [mutablePairs addObject:[pair URLEncodedStringValue]];
    }

    return [mutablePairs componentsJoinedByString:@"&amp;"];
}
</code></pre>

<h3 id="设置-http-头部字段">设置 HTTP 头部字段</h3>

<p><code class="highlighter-rouge">AFHTTPRequestSerializer</code> 在头文件中提供了一些属性方便我们设置 HTTP 头部字段。同时，在类的内部，它提供了 <code class="highlighter-rouge">- [AFHTTPRequestSerializer setValue:forHTTPHeaderField:]</code> 方法来设置 HTTP 头部，其实它的实现都是基于一个名为 <code class="highlighter-rouge">mutableHTTPRequestHeaders</code> 的属性的：</p>

<pre><code class="language-objectivec">- (void)setValue:(NSString *)value
forHTTPHeaderField:(NSString *)field
{
	[self.mutableHTTPRequestHeaders setValue:value forKey:field];
}

- (NSString *)valueForHTTPHeaderField:(NSString *)field {
    return [self.mutableHTTPRequestHeaders valueForKey:field];
}
</code></pre>

<p>在设置 HTTP 头部字段时，都会存储到这个可变字典中。而当真正使用时，会用 <code class="highlighter-rouge">HTTPRequestHeaders</code> 这个方法，来获取对应版本的不可变字典。</p>

<pre><code class="language-objectivec">- (NSDictionary *)HTTPRequestHeaders {
    return [NSDictionary dictionaryWithDictionary:self.mutableHTTPRequestHeaders];
}
</code></pre>

<p>到了这里，可以来分析一下，这个类是如何设置一些我们平时常用的头部字段的。首先是 <code class="highlighter-rouge">User-Agent</code>，在 <code class="highlighter-rouge">AFHTTPRequestSerializer</code> 刚刚初始化时，就会根据当前编译的平台生成一个 <code class="highlighter-rouge">userAgent</code> 字符串：</p>

<pre><code class="language-objectivec">userAgent = [NSString stringWithFormat:@"%@/%@ (%@; iOS %@; Scale/%0.2f)", [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleExecutableKey] ?: [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleIdentifierKey], [[NSBundle mainBundle] infoDictionary][@"CFBundleShortVersionString"] ?: [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleVersionKey], [[UIDevice currentDevice] model], [[UIDevice currentDevice] systemVersion], [[UIScreen mainScreen] scale]];

[self setValue:userAgent forHTTPHeaderField:@"User-Agent"];
</code></pre>

<p>设置验证字段时，可以使用 <code class="highlighter-rouge">- [AFHTTPRequestSerializer setAuthorizationHeaderFieldWithUsername:password:]</code> 方法</p>

<pre><code class="language-objectivec">- (void)setAuthorizationHeaderFieldWithUsername:(NSString *)username
                                       password:(NSString *)password
{
    NSData *basicAuthCredentials = [[NSString stringWithFormat:@"%@:%@", username, password] dataUsingEncoding:NSUTF8StringEncoding];
    NSString *base64AuthCredentials = [basicAuthCredentials base64EncodedStringWithOptions:(NSDataBase64EncodingOptions)0];
    [self setValue:[NSString stringWithFormat:@"Basic %@", base64AuthCredentials] forHTTPHeaderField:@"Authorization"];
}
</code></pre>

<h3 id="设置请求的属性">设置请求的属性</h3>

<p>还有一写 <code class="highlighter-rouge">NSURLRequest</code> 的属性是通过另一种方式来设置的，AFNetworking 为这些功能提供了接口</p>

<pre><code class="language-objectivec">@property (nonatomic, assign) BOOL allowsCellularAccess;

@property (nonatomic, assign) NSURLRequestCachePolicy cachePolicy;

@property (nonatomic, assign) BOOL HTTPShouldHandleCookies;

@property (nonatomic, assign) BOOL HTTPShouldUsePipelining;

@property (nonatomic, assign) NSURLRequestNetworkServiceType networkServiceType;

@property (nonatomic, assign) NSTimeInterval timeoutInterval;
</code></pre>

<p>它们都会通过 <code class="highlighter-rouge">AFHTTPRequestSerializerObservedKeyPaths</code> 的调用而返回。</p>

<pre><code class="language-objectivec">static NSArray * AFHTTPRequestSerializerObservedKeyPaths() {
    static NSArray *_AFHTTPRequestSerializerObservedKeyPaths = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        _AFHTTPRequestSerializerObservedKeyPaths = @[NSStringFromSelector(@selector(allowsCellularAccess)), NSStringFromSelector(@selector(cachePolicy)), NSStringFromSelector(@selector(HTTPShouldHandleCookies)), NSStringFromSelector(@selector(HTTPShouldUsePipelining)), NSStringFromSelector(@selector(networkServiceType)), NSStringFromSelector(@selector(timeoutInterval))];
    });

    return _AFHTTPRequestSerializerObservedKeyPaths;
}
</code></pre>

<p>在这些属性被设置时，会触发 KVO，然后将新的属性存储在一个名为 <code class="highlighter-rouge">mutableObservedChangedKeyPaths</code> 的字典中：</p>

<pre><code class="language-objectivec">- (void)observeValueForKeyPath:(NSString *)keyPath
                      ofObject:(__unused id)object
                        change:(NSDictionary *)change
                       context:(void *)context
{
    if (context == AFHTTPRequestSerializerObserverContext) {
        if ([change[NSKeyValueChangeNewKey] isEqual:[NSNull null]]) {
            [self.mutableObservedChangedKeyPaths removeObject:keyPath];
        } else {
            [self.mutableObservedChangedKeyPaths addObject:keyPath];
        }
    }
}
</code></pre>

<p>然后会在生成 <code class="highlighter-rouge">NSURLRequest</code> 的时候设置这些属性。</p>

<pre><code class="language-objectivec">NSMutableURLRequest *mutableRequest = [[NSMutableURLRequest alloc] initWithURL:url];
mutableRequest.HTTPMethod = method;

for (NSString *keyPath in AFHTTPRequestSerializerObservedKeyPaths()) {
    if ([self.mutableObservedChangedKeyPaths containsObject:keyPath]) {
        [mutableRequest setValue:[self valueForKeyPath:keyPath] forKey:keyPath];
    }
}
</code></pre>

<p>关于这个方法的的具体实现会在下一节中介绍。</p>

<h3 id="工作流程">工作流程</h3>

<p><code class="highlighter-rouge">AFHTTPRequestSerializer</code> 会在 <code class="highlighter-rouge">AHHTTPSessionManager</code> 初始化时一并初始化，这时它会根据当前系统环境预设置一些 HTTP 头部字段 <code class="highlighter-rouge">Accept-Language</code> <code class="highlighter-rouge">User-Agent</code>。</p>

<pre><code class="language-objectivec">- (instancetype)init {
    self = [super init];
    if (!self) {
        return nil;
    }

    self.stringEncoding = NSUTF8StringEncoding;

    self.mutableHTTPRequestHeaders = [NSMutableDictionary dictionary];


	#1: 设置接收语言，用户代理，略

    // HTTP Method Definitions; see http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html
    self.HTTPMethodsEncodingParametersInURI = [NSSet setWithObjects:@"GET", @"HEAD", @"DELETE", nil];

    self.mutableObservedChangedKeyPaths = [NSMutableSet set];
    for (NSString *keyPath in AFHTTPRequestSerializerObservedKeyPaths()) {
        if ([self respondsToSelector:NSSelectorFromString(keyPath)]) {
            [self addObserver:self forKeyPath:keyPath options:NSKeyValueObservingOptionNew context:AFHTTPRequestSerializerObserverContext];
        }
    }

    return self;
}
</code></pre>

<p>同时它还对一些属性进行 KVO，确保它们在改变后更新 <code class="highlighter-rouge">NSMutableURLRequest</code> 中对应的属性。</p>

<p>在初始化之后，如果调用了 <code class="highlighter-rouge">- [AFHTTPSessionManager dataTaskWithHTTPMethod:URLString:parameters:uploadProgress:downloadProgress:success:failure:]</code>，就会进入 <code class="highlighter-rouge">AFHTTPRequestSerializer</code> 的这一方法：</p>

<pre><code class="language-objectivec">
- (NSMutableURLRequest *)requestWithMethod:(NSString *)method
                                 URLString:(NSString *)URLString
                                parameters:(id)parameters
                                     error:(NSError *__autoreleasing *)error
{
    NSParameterAssert(method);
    NSParameterAssert(URLString);

    NSURL *url = [NSURL URLWithString:URLString];

    NSParameterAssert(url);

    NSMutableURLRequest *mutableRequest = [[NSMutableURLRequest alloc] initWithURL:url];
    mutableRequest.HTTPMethod = method;

    for (NSString *keyPath in AFHTTPRequestSerializerObservedKeyPaths()) {
        if ([self.mutableObservedChangedKeyPaths containsObject:keyPath]) {
            [mutableRequest setValue:[self valueForKeyPath:keyPath] forKey:keyPath];
        }
    }

    mutableRequest = [[self requestBySerializingRequest:mutableRequest withParameters:parameters error:error] mutableCopy];

	return mutableRequest;
}
</code></pre>

<ol>
  <li>对参数进行检查</li>
  <li>
    <p>设置 HTTP 方法</p>

    <pre><code class="language-objectivec"> mutableRequest.HTTPMethod = method;
</code></pre>
  </li>
  <li>
    <p>通过 <code class="highlighter-rouge">mutableObservedChangedKeyPaths</code> 字典设置 <code class="highlighter-rouge">NSMutableURLRequest</code> 的属性</p>

    <pre><code class="language-objectivec"> for (NSString *keyPath in AFHTTPRequestSerializerObservedKeyPaths()) {
     if ([self.mutableObservedChangedKeyPaths containsObject:keyPath]) {
         [mutableRequest setValue:[self valueForKeyPath:keyPath] forKey:keyPath];
     }
 }
</code></pre>
  </li>
  <li>调用 <code class="highlighter-rouge">- [AFHTTPRequestSerializer  requestBySerializingRequest:withParameters:error:]</code> <strong>设置 HTTP 头部字段和查询参数</strong>。</li>
</ol>

<p><code class="highlighter-rouge">- [AFHTTPRequestSerializer  requestBySerializingRequest:withParameters:error:]</code> 方法主要做了两件事情</p>

<pre><code class="language-objectivec">- (NSURLRequest *)requestBySerializingRequest:(NSURLRequest *)request
                               withParameters:(id)parameters
                                        error:(NSError *__autoreleasing *)error
{
    NSParameterAssert(request);

    NSMutableURLRequest *mutableRequest = [request mutableCopy];

    [self.HTTPRequestHeaders enumerateKeysAndObjectsUsingBlock:^(id field, id value, BOOL * __unused stop) {
        if (![request valueForHTTPHeaderField:field]) {
            [mutableRequest setValue:value forHTTPHeaderField:field];
        }
    }];

    NSString *query = nil;
    if (parameters) {
        if (self.queryStringSerialization) {
            NSError *serializationError;
            query = self.queryStringSerialization(request, parameters, &amp;serializationError);

            if (serializationError) {
                if (error) {
                    *error = serializationError;
                }

                return nil;
            }
        } else {
            switch (self.queryStringSerializationStyle) {
                case AFHTTPRequestQueryStringDefaultStyle:
                    query = AFQueryStringFromParameters(parameters);
                    break;
            }
        }
    }

    if ([self.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) {
        if (query) {
            mutableRequest.URL = [NSURL URLWithString:[[mutableRequest.URL absoluteString] stringByAppendingFormat:mutableRequest.URL.query ? @"&amp;%@" : @"?%@", query]];
        }
    } else {
        // #2864: an empty string is a valid x-www-form-urlencoded payload
        if (!query) {
            query = @"";
        }
        if (![mutableRequest valueForHTTPHeaderField:@"Content-Type"]) {
            [mutableRequest setValue:@"application/x-www-form-urlencoded" forHTTPHeaderField:@"Content-Type"];
        }
        [mutableRequest setHTTPBody:[query dataUsingEncoding:self.stringEncoding]];
    }

    return mutableRequest;
}
</code></pre>

<ol>
  <li>
    <p>通过 <code class="highlighter-rouge">HTTPRequestHeaders</code> 字典设置头部字段</p>

    <pre><code class="language-objectivec"> [self.HTTPRequestHeaders enumerateKeysAndObjectsUsingBlock:^(id field, id value, BOOL * __unused stop) {
     if (![request valueForHTTPHeaderField:field]) {
         [mutableRequest setValue:value forHTTPHeaderField:field];
     }
 }];
</code></pre>
  </li>
  <li>
    <p>调用 <code class="highlighter-rouge">AFQueryStringFromParameters</code> 将参数转换为查询参数</p>

    <pre><code class="language-objectivec"> query = AFQueryStringFromParameters(parameters);
</code></pre>
  </li>
  <li>
    <p>将 parameters 添加到 URL 或者 HTTP body 中</p>

    <pre><code class="language-objectivec"> if ([self.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) {
     if (query) {
         mutableRequest.URL = [NSURL URLWithString:[[mutableRequest.URL absoluteString] stringByAppendingFormat:mutableRequest.URL.query ? @"&amp;%@" : @"?%@", query]];
     }
 } else {
     // #2864: an empty string is a valid x-www-form-urlencoded payload
     if (!query) {
         query = @"";
     }
     if (![mutableRequest valueForHTTPHeaderField:@"Content-Type"]) {
         [mutableRequest setValue:@"application/x-www-form-urlencoded" forHTTPHeaderField:@"Content-Type"];
     }
     [mutableRequest setHTTPBody:[query dataUsingEncoding:self.stringEncoding]];
 }
</code></pre>

    <ul>
      <li>如果 HTTP 方法为 <code class="highlighter-rouge">GET</code> <code class="highlighter-rouge">HEAD</code> 或者 <code class="highlighter-rouge">DELETE</code>，也就是在初始化方法中设置的，那么参数会追加到 URL 后面。否则会被放入 HTTP body 中。</li>
    </ul>
  </li>
  <li>
    <p>最后这个方法会返回一个 <code class="highlighter-rouge">NSMutableURLRequest</code></p>
  </li>
</ol>

<h2 id="小结">小结</h2>

<ol>
  <li><code class="highlighter-rouge">AFURLResponseSerialization</code> 负责对返回的数据进行序列化</li>
  <li><code class="highlighter-rouge">AFURLRequestSerialization</code> 负责生成 <code class="highlighter-rouge">NSMutableURLRequest</code>，为请求设置 HTTP 头部，管理发出的请求</li>
</ol>

<ul>
  <li><a href="http://draveness.me/afnetworking1">AFNetworking 概述（一）</a></li>
  <li><a href="http://draveness.me/afnetworking2">AFNetworking 的核心 AFURLSessionManager（二）</a></li>
  <li><a href="http://draveness.me/afnetworking3">处理请求和响应 AFURLSerialization（三）</a></li>
  <li><a href="http://draveness.me/afnetworking4">AFNetworkReachabilityManager 监控网络状态（四）</a></li>
  <li><a href="http://draveness.me/afnetworking5">验证 HTTPS 请求的证书（五）</a></li>
</ul>
<iframe src="http://ghbtns.com/github-btn.html?user=draveness&amp;type=follow&amp;size=large" height="30" width="240" frameborder="0" scrolling="0" style="width:240px; height: 30px;" allowtransparency="true"></iframe>

<p>Blog: <a href="http://draveness.me">Draveness</a></p>


	  ]]></description>
	</item>

	<item>
	  <title>AFNetworking 的核心 AFURLSessionManager（二）</title>
	  <link>/reprinted//afnetworking2</link>
	  <author></author>
	  <pubDate>2016-03-30T01:50:43+00:00</pubDate>
	  <guid>/reprinted//afnetworking2</guid>
	  <description><![CDATA[
	     <p>Blog: <a href="http://draveness.me">Draveness</a></p>

<iframe src="http://ghbtns.com/github-btn.html?user=draveness&amp;type=follow&amp;size=large" height="30" width="240" frameborder="0" scrolling="0" style="width:240px; height: 30px;" allowtransparency="true"></iframe>

<p>关注仓库，及时获得更新：<a href="https://github.com/draveness/iOS-Source-Code-Analyze">iOS-Source-Code-Analyze</a></p>

<p><code class="highlighter-rouge">AFURLSessionManager</code> 绝对可以称得上是 AFNetworking 的核心。</p>

<ol>
  <li><a href="#NSURLSession">负责创建和管理 NSURLSession</a></li>
  <li><a href="#NSURLSessionTask">管理 NSURLSessionTask</a></li>
  <li><a href="#NSURLSessionDelegate">实现 NSURLSessionDelegate 等协议中的代理方法</a></li>
  <li><a href="#AFURLSessionManagerTaskDelegate">使用 AFURLSessionManagerTaskDelegate 管理进度</a></li>
  <li><a href="#_AFURLSessionTaskSwizzling">使用 _AFURLSessionTaskSwizzling 调剂方法</a></li>
  <li><a href="#AFSecurityPolocy">引入 AFSecurityPolicy 保证请求的安全</a></li>
  <li><a href="#AFNetworkReachabilityManager">引入 AFNetworkReachabilityManager 监控网络状态</a></li>
</ol>

<p>我们会在这里着重介绍上面七个功能中的前五个，分析它是如何包装 <code class="highlighter-rouge">NSURLSession</code> 以及众多代理方法的。</p>

<h2 id="创建和管理-nsurlsession"><a id="NSURLSession"></a>创建和管理 <code class="highlighter-rouge">NSURLSession</code></h2>

<p>在使用 <code class="highlighter-rouge">AFURLSessionManager</code> 时，第一件要做的事情一定是初始化：</p>

<pre><code class="language-objectivec">- (instancetype)initWithSessionConfiguration:(NSURLSessionConfiguration *)configuration {
    self = [super init];
    if (!self) {
        return nil;
    }

    if (!configuration) {
        configuration = [NSURLSessionConfiguration defaultSessionConfiguration];
    }

    self.sessionConfiguration = configuration;

    self.operationQueue = [[NSOperationQueue alloc] init];
    self.operationQueue.maxConcurrentOperationCount = 1;

    self.session = [NSURLSession sessionWithConfiguration:self.sessionConfiguration delegate:self delegateQueue:self.operationQueue];

    self.responseSerializer = [AFJSONResponseSerializer serializer];

    self.securityPolicy = [AFSecurityPolicy defaultPolicy];

    self.reachabilityManager = [AFNetworkReachabilityManager sharedManager];

    self.mutableTaskDelegatesKeyedByTaskIdentifier = [[NSMutableDictionary alloc] init];

    self.lock = [[NSLock alloc] init];
    self.lock.name = AFURLSessionManagerLockName;

    #1: 为已有的 task 设置代理, 略

    return self;
}
</code></pre>

<p>在初始化方法中，需要完成初始化一些自己持有的实例：</p>

<ol>
  <li>初始化<strong>会话配置</strong>（NSURLSessionConfiguration），默认为 <code class="highlighter-rouge">defaultSessionConfiguration</code></li>
  <li>初始化会话（session），并设置会话的代理以及代理队列</li>
  <li>初始化管理<strong>响应序列化</strong>（AFJSONResponseSerializer），<strong>安全认证</strong>（AFSecurityPolicy）以及<strong>监控网络状态</strong>（AFNetworkReachabilityManager）的实例</li>
  <li>初始化保存 data task 的字典（mutableTaskDelegatesKeyedByTaskIdentifier）</li>
</ol>

<h2 id="管理-nsurlsessiontask"><a id="NSURLSessionTask"></a>管理 <code class="highlighter-rouge">NSURLSessionTask</code></h2>

<p>接下来，在获得了 <code class="highlighter-rouge">AFURLSessionManager</code> 的实例之后，我们可以通过以下方法创建 <code class="highlighter-rouge">NSURLSessionDataTask</code> 的实例：</p>

<pre><code class="language-objectivec">- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request
                               uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock
                             downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock
                            completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject,  NSError * _Nullable error))completionHandler;

- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request
                                         fromFile:(NSURL *)fileURL
                                         progress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock
                                completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError  * _Nullable error))completionHandler;

...

- (NSURLSessionDownloadTask *)downloadTaskWithRequest:(NSURLRequest *)request
                                             progress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock
                                          destination:(nullable NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination
                                    completionHandler:(nullable void (^)(NSURLResponse *response, NSURL * _Nullable filePath, NSError * _Nullable error))completionHandler;

...

</code></pre>

<p>这里省略了一些返回 <code class="highlighter-rouge">NSURLSessionTask</code> 的方法，因为这些接口的形式都是差不多的。</p>

<p>我们将以 <code class="highlighter-rouge">- [AFURLSessionManager dataTaskWithRequest:uploadProgress:downloadProgress:completionHandler:]</code> 方法的实现为例，分析它是如何实例化并返回一个 <code class="highlighter-rouge">NSURLSessionTask</code> 的实例的：</p>

<pre><code class="language-objectivec">- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request
                               uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock
                             downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock
                            completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject,  NSError * _Nullable error))completionHandler {

    __block NSURLSessionDataTask *dataTask = nil;
    url_session_manager_create_task_safely(^{
        dataTask = [self.session dataTaskWithRequest:request];
    });

    [self addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler];

    return dataTask;
}
</code></pre>

<blockquote>
  <p><code class="highlighter-rouge">url_session_manager_create_task_safely</code> 的调用是因为苹果框架中的一个 bug <a href="https://github.com/AFNetworking/AFNetworking/issues/2093">#2093</a>，如果有兴趣可以看一下，在这里就不说明了</p>
</blockquote>

<ol>
  <li>调用 <code class="highlighter-rouge">- [NSURLSession dataTaskWithRequest:]</code> 方法传入 <code class="highlighter-rouge">NSURLRequest</code></li>
  <li>调用 <code class="highlighter-rouge">- [AFURLSessionManager addDelegateForDataTask:uploadProgress:downloadProgress:completionHandler:]</code> 方法返回一个 <code class="highlighter-rouge">AFURLSessionManagerTaskDelegate</code> 对象</li>
  <li>将 <code class="highlighter-rouge">completionHandler</code> <code class="highlighter-rouge">uploadProgressBlock</code> 和 <code class="highlighter-rouge">downloadProgressBlock</code> 传入该对象并在相应事件发生时进行回调</li>
</ol>

<pre><code class="language-objectivec">- (void)addDelegateForDataTask:(NSURLSessionDataTask *)dataTask
                uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock
              downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock
             completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler
{
    AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] init];
    delegate.manager = self;
    delegate.completionHandler = completionHandler;

    dataTask.taskDescription = self.taskDescriptionForSessionTasks;
    [self setDelegate:delegate forTask:dataTask];

    delegate.uploadProgressBlock = uploadProgressBlock;
    delegate.downloadProgressBlock = downloadProgressBlock;
}
</code></pre>

<p>在这个方法中同时调用了另一个方法 <code class="highlighter-rouge">- [AFURLSessionManager setDelegate:forTask:]</code> 来设置代理：</p>

<pre><code class="language-objectivec">- (void)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate
            forTask:(NSURLSessionTask *)task
{

	#1: 检查参数, 略

    [self.lock lock];
    self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate;
    [delegate setupProgressForTask:task];
    [self addNotificationObserverForTask:task];
    [self.lock unlock];
}
</code></pre>

<p>正如上面所提到的，<code class="highlighter-rouge">AFNRUSessionManager</code> 就是通过字典 <code class="highlighter-rouge">mutableTaskDelegatesKeyedByTaskIdentifier</code> 来存储并管理每一个 <code class="highlighter-rouge">NSURLSessionTask</code>，它以 <code class="highlighter-rouge">taskIdentifier</code> 为键存储 task。</p>

<p>该方法使用 <code class="highlighter-rouge">NSLock</code> 来保证不同线程使用 <code class="highlighter-rouge">mutableTaskDelegatesKeyedByTaskIdentifier</code> 时，不会出现<strong>线程竞争</strong>的问题。</p>

<p>同时调用 <a href="#setupProgressForTask">- setupProgressForTask:</a>，我们会在下面具体介绍这个方法。</p>

<h2 id="实现-nsurlsessiondelegate-等协议中的代理方法"><a id="NSURLSessionDelegate"></a>实现 <code class="highlighter-rouge">NSURLSessionDelegate</code> 等协议中的代理方法</h2>

<p>在 <code class="highlighter-rouge">AFURLSessionManager</code> 的头文件中可以看到，它遵循了多个协议，其中包括：</p>

<ul>
  <li><code class="highlighter-rouge">NSURLSessionDelegate</code></li>
  <li><code class="highlighter-rouge">NSURLSessionTaskDelegate</code></li>
  <li><code class="highlighter-rouge">NSURLSessionDataDelegate</code></li>
  <li><code class="highlighter-rouge">NSURLSessionDownloadDelegate</code></li>
</ul>

<p>它在初始化方法 <code class="highlighter-rouge">- [AFURLSessionManager initWithSessionConfiguration:]</code> 将 <code class="highlighter-rouge">NSURLSession</code> 的代理指向 <code class="highlighter-rouge">self</code>，然后<strong>实现这些方法</strong>，提供更简洁的 block 的接口：</p>

<pre><code class="language-objectivec">- (void)setSessionDidBecomeInvalidBlock:(nullable void (^)(NSURLSession *session, NSError *error))block;
- (void)setSessionDidReceiveAuthenticationChallengeBlock:(nullable NSURLSessionAuthChallengeDisposition (^)(NSURLSession *session, NSURLAuthenticationChallenge *challenge, NSURLCredential * _Nullable __autoreleasing * _Nullable credential))block;
...
</code></pre>

<p>它为所有的代理协议都提供了对应的 block 接口，方法实现的思路都是相似的，我们以 <code class="highlighter-rouge">- [AFNRLSessionManager setSessionDidBecomeInvalidBlock:]</code> 为例。</p>

<p>首先调用 setter 方法，将 block 存入 <code class="highlighter-rouge">sessionDidBecomeInvalid</code> 属性中：</p>

<pre><code class="language-objectivec">- (void)setSessionDidBecomeInvalidBlock:(void (^)(NSURLSession *session, NSError *error))block {
    self.sessionDidBecomeInvalid = block;
}
</code></pre>

<p>当代理方法调用时，如果存在对应的 block，会执行对应的 block：</p>

<pre><code class="language-objectivec">- (void)URLSession:(NSURLSession *)session
didBecomeInvalidWithError:(NSError *)error
{
    if (self.sessionDidBecomeInvalid) {
        self.sessionDidBecomeInvalid(session, error);
    }

    [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDidInvalidateNotification object:session];
}
</code></pre>

<p>其他相似的接口实现也都差不多，这里直接跳过了。</p>

<h2 id="使用-afurlsessionmanagertaskdelegate-管理进度"><a id="AFURLSessionManagerTaskDelegate"></a>使用 <code class="highlighter-rouge">AFURLSessionManagerTaskDelegate</code> 管理进度</h2>

<p>在上面我们提到过 <code class="highlighter-rouge">AFURLSessionManagerTaskDelegate</code> 类，它主要为 task 提供<strong>进度管理</strong>功能，并在 task 结束时<strong>回调</strong>， 也就是调用在 <code class="highlighter-rouge">- [AFURLSessionManager dataTaskWithRequest:uploadProgress:downloadProgress:completionHandler:]</code> 等方法中传入的 <code class="highlighter-rouge">completionHandler</code>。</p>

<p><a id="setupProgressForTask"></a>我们首先分析一下 <code class="highlighter-rouge">AFURLSessionManagerTaskDelegate</code> 是如何对进度进行跟踪的：</p>

<pre><code class="language-objectivec">- (void)setupProgressForTask:(NSURLSessionTask *)task {

	#1：设置在上传进度或者下载进度状态改变时的回调

	#2：KVO

}
</code></pre>

<p>该方法的实现有两个部分，一部分是对代理持有的两个属性 <code class="highlighter-rouge">uploadProgress</code> 和 <code class="highlighter-rouge">downloadProgress</code> 设置回调</p>

<pre><code class="language-objectivec">__weak __typeof__(task) weakTask = task;

self.uploadProgress.totalUnitCount = task.countOfBytesExpectedToSend;
[self.uploadProgress setCancellable:YES];
[self.uploadProgress setCancellationHandler:^{
   __typeof__(weakTask) strongTask = weakTask;
   [strongTask cancel];
}];
[self.uploadProgress setPausable:YES];
[self.uploadProgress setPausingHandler:^{
   __typeof__(weakTask) strongTask = weakTask;
   [strongTask suspend];
}];
if ([self.uploadProgress respondsToSelector:@selector(setResumingHandler:)]) {
   [self.uploadProgress setResumingHandler:^{
       __typeof__(weakTask) strongTask = weakTask;
       [strongTask resume];
   }];
}
</code></pre>

<p>这里只有对 <code class="highlighter-rouge">uploadProgress</code> 设置回调的代码，设置 <code class="highlighter-rouge">downloadProgress</code> 与这里完全相同</p>

<blockquote>
  <p>主要目的是在对应 <code class="highlighter-rouge">NSProgress</code> 的状态改变时，调用 <code class="highlighter-rouge">resume</code> <code class="highlighter-rouge">suspend</code> 等方法改变 task 的状态。</p>
</blockquote>

<p>第二部分是对 task 和 <code class="highlighter-rouge">NSProgress</code> 属性进行键值观测：</p>

<pre><code class="language-objectivec">[task addObserver:self
      forKeyPath:NSStringFromSelector(@selector(countOfBytesReceived))
         options:NSKeyValueObservingOptionNew
         context:NULL];
[task addObserver:self
      forKeyPath:NSStringFromSelector(@selector(countOfBytesExpectedToReceive))
         options:NSKeyValueObservingOptionNew
         context:NULL];

[task addObserver:self
      forKeyPath:NSStringFromSelector(@selector(countOfBytesSent))
         options:NSKeyValueObservingOptionNew
         context:NULL];
[task addObserver:self
      forKeyPath:NSStringFromSelector(@selector(countOfBytesExpectedToSend))
         options:NSKeyValueObservingOptionNew
         context:NULL];

[self.downloadProgress addObserver:self
                       forKeyPath:NSStringFromSelector(@selector(fractionCompleted))
                          options:NSKeyValueObservingOptionNew
                          context:NULL];
[self.uploadProgress addObserver:self
                     forKeyPath:NSStringFromSelector(@selector(fractionCompleted))
                        options:NSKeyValueObservingOptionNew
                        context:NULL];
</code></pre>

<p>在 <code class="highlighter-rouge">observeValueForKeypath:ofObject:change:context:</code> 方法中改变进度，并调用 block</p>

<pre><code class="language-objectivec">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context {
    if ([object isKindOfClass:[NSURLSessionTask class]]) {
        if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesReceived))]) {
            self.downloadProgress.completedUnitCount = [change[@"new"] longLongValue];
        } else if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesExpectedToReceive))]) {
            self.downloadProgress.totalUnitCount = [change[@"new"] longLongValue];
        } else if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesSent))]) {
            self.uploadProgress.completedUnitCount = [change[@"new"] longLongValue];
        } else if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesExpectedToSend))]) {
            self.uploadProgress.totalUnitCount = [change[@"new"] longLongValue];
        }
    }
    else if ([object isEqual:self.downloadProgress]) {
        if (self.downloadProgressBlock) {
            self.downloadProgressBlock(object);
        }
    }
    else if ([object isEqual:self.uploadProgress]) {
        if (self.uploadProgressBlock) {
            self.uploadProgressBlock(object);
        }
    }
}
</code></pre>

<p>对象的某些属性改变时更新 <code class="highlighter-rouge">NSProgress</code> 对象或使用 block 传递 <code class="highlighter-rouge">NSProgress</code> 对象 <code class="highlighter-rouge">self.uploadProgressBlock(object)</code>。</p>

<h3 id="代理方法-urlsessiontaskdidcompletewitherror">代理方法 <code class="highlighter-rouge">URLSession:task:didCompleteWithError:</code></h3>

<p>在每一个 <code class="highlighter-rouge">NSURLSessionTask</code> 结束时，都会在代理方法 <code class="highlighter-rouge">URLSession:task:didCompleteWithError:</code> 中：</p>

<ol>
  <li>调用传入的 <code class="highlighter-rouge">completionHander</code> block</li>
  <li>发出 <code class="highlighter-rouge">AFNetworkingTaskDidCompleteNotification</code> 通知</li>
</ol>

<pre><code class="language-objectivec">- (void)URLSession:(__unused NSURLSession *)session
              task:(NSURLSessionTask *)task
didCompleteWithError:(NSError *)error
{
    #1：获取数据, 存储 `responseSerializer` 和 `downloadFileURL`

    if (error) {
    	#2：在存在错误时调用 `completionHandler`
    } else {
		#3：调用 `completionHandler`
    }
}
</code></pre>

<p>这是整个代理方法的骨架，先看一下最简单的第一部分代码：</p>

<pre><code class="language-objectivec">__block NSMutableDictionary *userInfo = [NSMutableDictionary dictionary];
userInfo[AFNetworkingTaskDidCompleteResponseSerializerKey] = manager.responseSerializer;

//Performance Improvement from #2672
NSData *data = nil;
if (self.mutableData) {
   data = [self.mutableData copy];
   //We no longer need the reference, so nil it out to gain back some memory.
   self.mutableData = nil;
}

if (self.downloadFileURL) {
   userInfo[AFNetworkingTaskDidCompleteAssetPathKey] = self.downloadFileURL;
} else if (data) {
   userInfo[AFNetworkingTaskDidCompleteResponseDataKey] = data;
}
</code></pre>

<p>这部分代码从 <code class="highlighter-rouge">mutableData</code> 中取出了数据，设置了 <code class="highlighter-rouge">userInfo</code>。</p>

<pre><code class="language-objectivec">userInfo[AFNetworkingTaskDidCompleteErrorKey] = error;

dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^{
    if (self.completionHandler) {
        self.completionHandler(task.response, responseObject, error);
    }

    dispatch_async(dispatch_get_main_queue(), ^{
        [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];
    });
});
</code></pre>

<p>如果当前 <code class="highlighter-rouge">manager</code> 持有 <code class="highlighter-rouge">completionGroup</code> 或者 <code class="highlighter-rouge">completionQueue</code> 就使用它们。否则会创建一个 <code class="highlighter-rouge">dispatch_group_t</code> 并在主线程中调用 <code class="highlighter-rouge">completionHandler</code> 并发送通知(在主线程中)。</p>

<p>如果在执行当前 task 时没有遇到错误，那么先<strong>对数据进行序列化</strong>，然后同样调用 block 并发送通知。</p>

<pre><code class="language-objectivec">dispatch_async(url_session_manager_processing_queue(), ^{
    NSError *serializationError = nil;
    responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError];

    if (self.downloadFileURL) {
        responseObject = self.downloadFileURL;
    }

    if (responseObject) {
        userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] = responseObject;
    }

    if (serializationError) {
        userInfo[AFNetworkingTaskDidCompleteErrorKey] = serializationError;
    }

    dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^{
        if (self.completionHandler) {
            self.completionHandler(task.response, responseObject, serializationError);
        }

        dispatch_async(dispatch_get_main_queue(), ^{
            [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];
        });
    });
});
</code></pre>

<h3 id="代理方法-urlsessiondatataskdidreceivedata-和---urlsessiondownloadtaskdidfinishdownloadingtourl">代理方法 <code class="highlighter-rouge">URLSession:dataTask:didReceiveData:</code> 和 <code class="highlighter-rouge">- URLSession:downloadTask:didFinishDownloadingToURL:</code></h3>

<p>这两个代理方法分别会在收到数据或者完成下载对应文件时调用，作用分别是为 <code class="highlighter-rouge">mutableData</code> 追加数据和处理下载的文件：</p>

<pre><code class="language-objectivec">- (void)URLSession:(__unused NSURLSession *)session
          dataTask:(__unused NSURLSessionDataTask *)dataTask
    didReceiveData:(NSData *)data
{
    [self.mutableData appendData:data];
}

- (void)URLSession:(NSURLSession *)session
      downloadTask:(NSURLSessionDownloadTask *)downloadTask
didFinishDownloadingToURL:(NSURL *)location
{
    NSError *fileManagerError = nil;
    self.downloadFileURL = nil;

    if (self.downloadTaskDidFinishDownloading) {
        self.downloadFileURL = self.downloadTaskDidFinishDownloading(session, downloadTask, location);
        if (self.downloadFileURL) {
            [[NSFileManager defaultManager] moveItemAtURL:location toURL:self.downloadFileURL error:&amp;fileManagerError];

            if (fileManagerError) {
                [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:fileManagerError.userInfo];
            }
        }
    }
}
</code></pre>

<h2 id="使用-_afurlsessiontaskswizzling-调剂方法"><a id="_AFURLSessionTaskSwizzling"></a>使用 <code class="highlighter-rouge">_AFURLSessionTaskSwizzling</code> 调剂方法</h2>

<p><code class="highlighter-rouge">_AFURLSessionTaskSwizzling</code> 的唯一功能就是修改 <code class="highlighter-rouge">NSURLSessionTask</code> 的 <code class="highlighter-rouge">resume</code> 和 <code class="highlighter-rouge">suspend</code> 方法，使用下面的方法替换原有的实现</p>

<pre><code class="language-objectivec">- (void)af_resume {
    NSAssert([self respondsToSelector:@selector(state)], @"Does not respond to state");
    NSURLSessionTaskState state = [self state];
    [self af_resume];

    if (state != NSURLSessionTaskStateRunning) {
        [[NSNotificationCenter defaultCenter] postNotificationName:AFNSURLSessionTaskDidResumeNotification object:self];
    }
}

- (void)af_suspend {
    NSAssert([self respondsToSelector:@selector(state)], @"Does not respond to state");
    NSURLSessionTaskState state = [self state];
    [self af_suspend];

    if (state != NSURLSessionTaskStateSuspended) {
        [[NSNotificationCenter defaultCenter] postNotificationName:AFNSURLSessionTaskDidSuspendNotification object:self];
    }
}
</code></pre>

<p>这样做的目的是为了在方法 <code class="highlighter-rouge">resume</code> 或者 <code class="highlighter-rouge">suspend</code> 被调用时发出通知。</p>

<p>具体方法调剂的过程是在 <code class="highlighter-rouge">+ load</code> 方法中进行的</p>

<blockquote>
  <p><code class="highlighter-rouge">load</code> 方法只会在整个文件被引入时调用一次</p>
</blockquote>

<pre><code class="language-objectivec">+ (void)load {
    if (NSClassFromString(@"NSURLSessionTask")) {
        NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration ephemeralSessionConfiguration];
        NSURLSession * session = [NSURLSession sessionWithConfiguration:configuration];
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wnonnull"
        NSURLSessionDataTask *localDataTask = [session dataTaskWithURL:nil];
#pragma clang diagnostic pop
        IMP originalAFResumeIMP = method_getImplementation(class_getInstanceMethod([self class], @selector(af_resume)));
        Class currentClass = [localDataTask class];

        while (class_getInstanceMethod(currentClass, @selector(resume))) {
            Class superClass = [currentClass superclass];
            IMP classResumeIMP = method_getImplementation(class_getInstanceMethod(currentClass, @selector(resume)));
            IMP superclassResumeIMP = method_getImplementation(class_getInstanceMethod(superClass, @selector(resume)));
            if (classResumeIMP != superclassResumeIMP &amp;&amp;
                originalAFResumeIMP != classResumeIMP) {
                [self swizzleResumeAndSuspendMethodForClass:currentClass];
            }
            currentClass = [currentClass superclass];
        }

        [localDataTask cancel];
        [session finishTasksAndInvalidate];
    }
}
</code></pre>

<ol>
  <li>首先用 <code class="highlighter-rouge">NSClassFromString(@"NSURLSessionTask")</code> 判断当前部署的 iOS 版本是否含有类 <code class="highlighter-rouge">NSURLSessionTask</code></li>
  <li>因为 iOS7 和 iOS8 上对于 <code class="highlighter-rouge">NSURLSessionTask</code> 的实现不同，所以会通过 <code class="highlighter-rouge">- [NSURLSession dataTaskWithURL:]</code> 方法返回一个 <code class="highlighter-rouge">NSURLSessionTask</code> 实例</li>
  <li>取得当前类 <code class="highlighter-rouge">_AFURLSessionTaskSwizzling</code> 中的实现 <code class="highlighter-rouge">af_resume</code></li>
  <li>如果当前类 <code class="highlighter-rouge">currentClass</code> 有 <code class="highlighter-rouge">resume</code> 方法
    <ul>
      <li>真：5</li>
      <li>假：7</li>
    </ul>
  </li>
  <li>使用 <code class="highlighter-rouge">swizzleResumeAndSuspendMethodForClass:</code> 调剂该类的 <code class="highlighter-rouge">resume</code> 和 <code class="highlighter-rouge">suspend</code> 方法</li>
  <li><code class="highlighter-rouge">currentClass = [currentClass superclass]</code></li>
</ol>

<blockquote>
  <p>这里复杂的实现是为了解决 bug <a href="https://github.com/AFNetworking/AFNetworking/pull/2702">#2702</a></p>
</blockquote>

<h2 id="引入-afsecuritypolicy-保证请求的安全"><a id="AFSecurityPolicy"></a>引入 <code class="highlighter-rouge">AFSecurityPolicy</code> 保证请求的安全</h2>

<p><code class="highlighter-rouge">AFSecurityPolicy</code> 是 <code class="highlighter-rouge">AFNetworking</code> 用来保证 HTTP 请求安全的类，它被 <code class="highlighter-rouge">AFURLSessionManager</code> 持有，如果你在 <code class="highlighter-rouge">AFURLSessionManager</code> 的实现文件中搜索 <em>self.securityPolicy</em>，你只会得到三条结果：</p>

<ol>
  <li>初始化 <code class="highlighter-rouge">self.securityPolicy = [AFSecurityPolicy defaultPolicy]</code></li>
  <li>收到连接层的验证请求时</li>
  <li>任务接收到验证请求时</li>
</ol>

<p>在 API 调用上，后两者都调用了 <code class="highlighter-rouge">- [AFSecurityPolicy evaluateServerTrust:forDomain:]</code> 方法来判断<strong>当前服务器是否被信任</strong>，我们会在接下来的文章中具体介绍这个方法的实现的作用。</p>

<pre><code class="language-objectivec">- (void)URLSession:(NSURLSession *)session
              task:(NSURLSessionTask *)task
didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge
 completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler
{
    NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling;
    __block NSURLCredential *credential = nil;

    if (self.taskDidReceiveAuthenticationChallenge) {
        disposition = self.taskDidReceiveAuthenticationChallenge(session, task, challenge, &amp;credential);
    } else {
        if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) {
            if ([self.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) {
                disposition = NSURLSessionAuthChallengeUseCredential;
                credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust];
            } else {
                disposition = NSURLSessionAuthChallengeRejectProtectionSpace;
            }
        } else {
            disposition = NSURLSessionAuthChallengePerformDefaultHandling;
        }
    }

    if (completionHandler) {
        completionHandler(disposition, credential);
    }
}
</code></pre>

<p>如果没有传入 <code class="highlighter-rouge">taskDidReceiveAuthenticationChallenge</code> block，只有在上述方法返回 <code class="highlighter-rouge">YES</code> 时，才会获得认证凭证 <code class="highlighter-rouge">credential</code>。</p>

<h2 id="引入-afnetworkreachabilitymanager-监控网络状态"><a id="AFNetworkReachabilityManager"></a>引入 <code class="highlighter-rouge">AFNetworkReachabilityManager</code> 监控网络状态</h2>

<p>与 <code class="highlighter-rouge">AFSecurityPolicy</code> 相同，<code class="highlighter-rouge">AFURLSessionManager</code> 对网络状态的监控是由 <code class="highlighter-rouge">AFNetworkReachabilityManager</code> 来负责的，它仅仅是持有一个 <code class="highlighter-rouge">AFNetworkReachabilityManager</code> 的对象。</p>

<blockquote>
  <p>真正需要判断网络状态时，仍然<strong>需要开发者调用对应的 API 获取网络状态</strong>。</p>
</blockquote>

<h2 id="小结">小结</h2>

<ol>
  <li><code class="highlighter-rouge">AFURLSessionManager</code> 是对 <code class="highlighter-rouge">NSURLSession</code> 的封装</li>
  <li>它通过 <code class="highlighter-rouge">- [AFURLSessionManager dataTaskWithRequest:completionHandler:]</code> 等接口创建 <code class="highlighter-rouge">NSURLSessionDataTask</code> 的实例</li>
  <li>持有一个字典 <code class="highlighter-rouge">mutableTaskDelegatesKeyedByTaskIdentifier</code> 管理这些 data task 实例</li>
  <li>引入 <code class="highlighter-rouge">AFURLSessionManagerTaskDelegate</code> 来对传入的 <code class="highlighter-rouge">uploadProgressBlock</code> <code class="highlighter-rouge">downloadProgressBlock</code> <code class="highlighter-rouge">completionHandler</code> 在合适的时间进行调用</li>
  <li>实现了全部的代理方法来提供 block 接口</li>
  <li>通过方法调剂在 data task 状态改变时，发出通知</li>
</ol>

<p>关于其他 AFNetworking 源代码分析的其他文章：</p>

<ul>
  <li><a href="http://draveness.me/afnetworking1">AFNetworking 概述（一）</a></li>
  <li><a href="http://draveness.me/afnetworking2">AFNetworking 的核心 AFURLSessionManager（二）</a></li>
  <li><a href="http://draveness.me/afnetworking3">处理请求和响应 AFURLSerialization（三）</a></li>
  <li><a href="http://draveness.me/afnetworking4">AFNetworkReachabilityManager 监控网络状态（四）</a></li>
  <li><a href="http://draveness.me/afnetworking5">验证 HTTPS 请求的证书（五）</a></li>
</ul>

<iframe src="http://ghbtns.com/github-btn.html?user=draveness&amp;type=follow&amp;size=large" height="30" width="240" frameborder="0" scrolling="0" style="width:240px; height: 30px;" allowtransparency="true"></iframe>

<p>关注仓库，及时获得更新：<a href="https://github.com/draveness/iOS-Source-Code-Analyze">iOS-Source-Code-Analyze</a></p>

<p>Blog: <a href="http://draveness.me">Draveness</a></p>


	  ]]></description>
	</item>

	<item>
	  <title>AFNetworking 概述（一）</title>
	  <link>/reprinted//afnetworking1</link>
	  <author></author>
	  <pubDate>2016-03-21T02:57:28+00:00</pubDate>
	  <guid>/reprinted//afnetworking1</guid>
	  <description><![CDATA[
	     <p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-03-21-afnetworking-logo.png" alt="afnetworking-logo" /></p>

<p>Blog: <a href="http://draveness.me">Draveness</a></p>

<p>关注仓库，及时获得更新：<a href="https://github.com/draveness/iOS-Source-Code-Analyze">iOS-Source-Code-Analyze</a></p>

<p>在这一系列的文章中，我会对 AFNetworking 的源代码进行分析，深入了解一下它是如何构建的，如何在日常中完成发送 HTTP 请求、构建网络层这一任务。</p>

<p><a href="https://github.com/AFNetworking/AFNetworking">AFNetworking</a> 是如今 iOS 开发中不可缺少的组件之一。它的 github 配置上是如下介绍的：</p>

<blockquote>
  <p>Perhaps the most important feature of all, however, is the amazing community of developers who use and contribute to AFNetworking every day. AFNetworking powers some of the most popular and critically-acclaimed apps on the iPhone, iPad, and Mac.</p>
</blockquote>

<p>可以说<strong>使用 AFNetworking 的工程师构成的社区</strong>才使得它变得非常重要。</p>

<h2 id="概述">概述</h2>

<p>我们今天是来深入研究一下这个与我们日常开发密切相关的框架是如何实现的。</p>

<p>这是我对 AFNetworking 整个架构的理解，随后一系列的文章也会逐步分析这些模块。</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-03-21-afnetworking-arch.png" alt="afnetworking-arch" /></p>

<p>在这篇文章中，我们有两个问题需要了解：</p>

<ol>
  <li>如何使用 NSURLSession 发出 HTTP 请求</li>
  <li>如何使用 AFNetworking 发出 HTTP 请求</li>
</ol>

<h2 id="nsurlsession">NSURLSession</h2>

<p><code class="highlighter-rouge">NSURLSession</code> 以及与它相关的类为我们提供了下载内容的 API，这个 API 提供了一系列的代理方法来支持身份认证，并且支持后台下载。</p>

<p>使用 <code class="highlighter-rouge">NSURLSession</code> 来进行 HTTP 请求并且获得数据总共有五个步骤：</p>

<ol>
  <li>实例化一个 <code class="highlighter-rouge">NSURLRequest/NSMutableURLRequest</code>，设置 URL</li>
  <li>通过 <code class="highlighter-rouge">- sharedSession</code> 方法获取 <code class="highlighter-rouge">NSURLSession</code></li>
  <li>在 session 上调用 <code class="highlighter-rouge">- dataTaskWithRequest:completionHandler:</code> 方法返回一个 <code class="highlighter-rouge">NSURLSessionDataTask</code></li>
  <li>向 data task 发送消息 <code class="highlighter-rouge">- resume</code>，开始执行这个任务</li>
  <li>在 completionHandler 中将数据编码，返回字符串</li>
</ol>

<pre><code class="language-objectivec">NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:[[NSURL alloc] initWithString:@"https://github.com"]];
NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *task = [session dataTaskWithRequest:request
                                       completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
                                           NSString *dataStr = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];
                                           NSLog(@"%@", dataStr);
                                       }];
[task resume];
</code></pre>

<p>这一段代码可以说是使用 <code class="highlighter-rouge">NSURLSession</code> 发送请求最简单的一段代码了，当你运行这段代码会在控制台看到一坨 <a href="github.com">github</a> 首页的 html。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="nt">&lt;html</span> <span class="na">lang=</span><span class="s">"en"</span> <span class="na">class=</span><span class="s">""</span><span class="nt">&gt;</span>
  <span class="nt">&lt;head</span> <span class="na">prefix=</span><span class="s">"og: http://ogp.me/ns# fb: http://ogp.me/ns/fb# object: http://ogp.me/ns/object# article: http://ogp.me/ns/article# profile: http://ogp.me/ns/profile#"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;meta</span> <span class="na">charset=</span><span class="s">'utf-8'</span><span class="nt">&gt;</span>
		...
	<span class="nt">&lt;/head&gt;</span>
	...
<span class="nt">&lt;/html&gt;</span>
</code></pre></div></div>

<h2 id="afnetworking">AFNetworking</h2>

<p>AFNetworking 的使用也是比较简单的，使用它来发出 HTTP 请求有两个步骤</p>

<ol>
  <li>以服务器的<strong>主机地址或者域名</strong>生成一个 AFHTTPSessionManager 的实例</li>
  <li>调用 <code class="highlighter-rouge">- GET:parameters:progress:success:failure:</code> 方法</li>
</ol>

<pre><code class="language-objectivec">AFHTTPSessionManager *manager = [[AFHTTPSessionManager alloc] initWithBaseURL:[[NSURL alloc] initWithString:@"hostname"]];
[manager GET:@"relative_url" parameters:nil progress:nil
    success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {
        NSLog(@"%@" ,responseObject);
    } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {
        NSLog(@"%@", error);
    }];
</code></pre>

<blockquote>
  <p>注意：在 iOS9 中，苹果默认全局 HTTPs，如果你要发送不安全的 HTTP 请求，需要在 info.plist 中加入如下键值对才能发出不安全的 HTTP 请求</p>

  <p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-03-21-afnetworking-plist.png" alt="afnetworking-plist" /></p>

  <p>还有一件事情是要注意的是，AFNetworking 默认接收 json 格式的响应（因为这是在 iOS 平台上的框架，一般不需要 text/html），如果想要返回 html，需要设置 <code class="highlighter-rouge">acceptableContentTypes</code></p>
</blockquote>

<h2 id="afnetworking-的调用栈">AFNetworking 的调用栈</h2>

<p>在这一节中我们要分析一下在上面两个方法的调用栈，首先来看的是 <code class="highlighter-rouge">AFHTTPSessionManager</code> 的初始化方法 <code class="highlighter-rouge">- initWithBaseURL:</code></p>

<pre><code class="language-objectivec">- [AFHTTPSessionManager initWithBaseURL:]
	- [AFHTTPSessionManager initWithBaseURL:sessionConfiguration:]
		- [AFURLSessionManager initWithSessionConfiguration:]
			- [NSURLSession sessionWithConfiguration:delegate:delegateQueue:]
			- [AFJSONResponseSerializer serializer] // 负责序列化响应
			- [AFSecurityPolicy defaultPolicy] // 负责身份认证
			- [AFNetworkReachabilityManager sharedManager] // 查看网络连接情况
		- [AFHTTPRequestSerializer serializer] // 负责序列化请求
		- [AFJSONResponseSerializer serializer] // 负责序列化响应
</code></pre>

<p>从这个初始化方法的调用栈，我们可以非常清晰地了解这个框架的结构：</p>

<ul>
  <li>其中 <code class="highlighter-rouge">AFURLSessionManager</code> 是 <code class="highlighter-rouge">AFHTTPSessionManager</code> 的父类</li>
  <li><code class="highlighter-rouge">AFURLSessionManager</code> 负责生成 <code class="highlighter-rouge">NSURLSession</code> 的实例，管理 <code class="highlighter-rouge">AFSecurityPolicy</code> 和 <code class="highlighter-rouge">AFNetworkReachabilityManager</code>，来保证请求的安全和查看网络连接情况，它有一个 <code class="highlighter-rouge">AFJSONResponseSerializer</code> 的实例来序列化 HTTP 响应</li>
  <li><code class="highlighter-rouge">AFHTTPSessionManager</code> 有着<strong>自己的</strong> <code class="highlighter-rouge">AFHTTPRequestSerializer</code> 和 <code class="highlighter-rouge">AFJSONResponseSerializer</code> 来管理请求和响应的序列化，同时<strong>依赖父类提供的接口</strong>保证安全、监控网络状态，实现发出 HTTP 请求这一核心功能</li>
</ul>

<p>初始化方法很好地揭示了 AFNetworking 整个框架的架构，接下来我们要通过分析另一个方法 <code class="highlighter-rouge">- GET:parameters:process:success:failure:</code> 的调用栈，看一下 HTTP 请求是如何发出的：</p>

<pre><code class="language-objectivec">- [AFHTTPSessionManager GET:parameters:process:success:failure:]
	- [AFHTTPSessionManager dataTaskWithHTTPMethod:parameters:uploadProgress:downloadProgress:success:failure:] // 返回 NSURLSessionDataTask #1
		- [AFHTTPRequestSerializer requestWithMethod:URLString:parameters:error:] // 返回 NSMutableURLRequest
		- [AFURLSessionManager dataTaskWithRequest:uploadProgress:downloadProgress:completionHandler:] // 返回 NSURLSessionDataTask #2
			- [NSURLSession dataTaskWithRequest:] // 返回 NSURLSessionDataTask #3
			- [AFURLSessionManager addDelegateForDataTask:uploadProgress:downloadProgress:completionHandler:]
				- [AFURLSessionManagerTaskDelegate init]
				- [AFURLSessionManager setDelegate:forTask:]
	- [NSURLSessionDataTask resume]
</code></pre>

<p>在这里 <code class="highlighter-rouge">#1</code> <code class="highlighter-rouge">#2</code> <code class="highlighter-rouge">#3</code> 处返回的是同一个 data task，我们可以看到，在 <code class="highlighter-rouge">#3</code> 处调用的方法 <code class="highlighter-rouge">- [NSURLSession dataTaskWithRequest:]</code> 和只使用 <code class="highlighter-rouge">NSURLSession</code> 发出 HTTP 请求时调用的方法 <code class="highlighter-rouge">- [NSURLSession dataTaskWithRequest:completionHandler:]</code> 差不多。在这个地方返回 data task 之后，我们再调用 <code class="highlighter-rouge">- resume</code> 方法执行请求，并在某些事件执行时通知代理 <code class="highlighter-rouge">AFURLSessionManagerTaskDelegate</code></p>

<h2 id="小结">小结</h2>

<p>AFNetworking 实际上只是对 <code class="highlighter-rouge">NSURLSession</code> 高度地封装, 提供一些简单易用的 API 方便我们在 iOS 开发中发出网络请求并在其上更快地构建网络层组件并提供合理的接口.</p>

<p>到这里，这一篇文章从上到下对 AFNetworking 是如何调用的进行了一个简单的概述，我会在随后的文章中会具体介绍 AFNetworking 中的每一个模块，了解它们是如何工作，并且如何合理地组织到一起的。</p>

<p>关于其他 AFNetworking 源代码分析的其他文章：</p>

<ul>
  <li><a href="http://draveness.me/afnetworking1">AFNetworking 概述（一）</a></li>
  <li><a href="http://draveness.me/afnetworking2">AFNetworking 的核心 AFURLSessionManager（二）</a></li>
  <li><a href="http://draveness.me/afnetworking3">处理请求和响应 AFURLSerialization（三）</a></li>
  <li><a href="http://draveness.me/afnetworking4">AFNetworkReachabilityManager 监控网络状态（四）</a></li>
  <li><a href="http://draveness.me/afnetworking5">验证 HTTPS 请求的证书（五）</a></li>
</ul>

<iframe src="http://ghbtns.com/github-btn.html?user=draveness&amp;type=follow&amp;size=large" height="30" width="240" frameborder="0" scrolling="0" style="width:240px; height: 30px;" allowtransparency="true"></iframe>

<p>关注仓库，及时获得更新：<a href="https://github.com/draveness/iOS-Source-Code-Analyze">iOS-Source-Code-Analyze</a></p>

<p>Blog: <a href="http://draveness.me">Draveness</a></p>


	  ]]></description>
	</item>

	<item>
	  <title>神奇的 BlocksKit （二）</title>
	  <link>/reprinted//blockskit-2</link>
	  <author></author>
	  <pubDate>2016-03-10T09:42:55+00:00</pubDate>
	  <guid>/reprinted//blockskit-2</guid>
	  <description><![CDATA[
	     <iframe src="http://ghbtns.com/github-btn.html?user=draveness&amp;type=follow&amp;size=large" height="30" width="240" frameborder="0" scrolling="0" style="width:240px; height: 30px;" allowtransparency="true"></iframe>

<blockquote>
  <p>关注仓库，及时获得更新：<a href="https://github.com/draveness/iOS-Source-Code-Analyze">iOS-Source-Code-Analyze</a></p>
</blockquote>

<p>这篇文章『神奇的 BlocksKit』的第二部分，关于第一部分的内容在这里：</p>

<ul>
  <li><a href="http://draveness.me/blockskit-1/">神奇的 BlocksKit（一）</a></li>
  <li><a href="http://draveness.me/blockskit-2/">神奇的 BlocksKit（二）</a></li>
</ul>

<h2 id="动态代理">动态代理</h2>

<p>动态代理这部分可以说是 BlocksKit 的精华。它<strong>使用 block 属性替换 UIKit 中的所有能够通过代理完成的事件</strong>，省略了设置代理和实现方法的过程，让对象自己实现代理方法，而且这个功能的实现是极其动态的。</p>

<blockquote>
  <p>其实不是对象自己实现的代理方法，只是框架为我们提供的便捷方法，不需要构造其它对象就能完成代理方法的实现，具体我们会在后面详细地解释。</p>
</blockquote>

<p>下面是这部分几个关键的类：</p>

<ul>
  <li><code class="highlighter-rouge">A2BlockInvocation</code> 的主要作用是存储和转发 block</li>
  <li><code class="highlighter-rouge">A2DynamicDelegate</code> 用来实现类的代理和数据源，它是 <code class="highlighter-rouge">NSProxy</code> 的子类</li>
  <li><code class="highlighter-rouge">NSObject+A2DynamicDelegate</code> 负责为返回 <code class="highlighter-rouge">bk_dynamicDelegate</code> 和 <code class="highlighter-rouge">bk_dynamicDataSource</code> 等 <code class="highlighter-rouge">A2DynamicDelegate</code> 类型的实例，为 <code class="highlighter-rouge">NSObject</code> 提供主要的接口</li>
  <li><code class="highlighter-rouge">NSObject+A2BlockDelegate</code> 提供了一系列接口将代理方法映射到 block 上</li>
  <li>其他的 UIKit 的分类提供对应的属性，并在对应的 <code class="highlighter-rouge">A2DynamicDelegate</code> 子类中实现代理方法</li>
</ul>

<p>这里是我对这部分代码结构的理解：</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-03-20-blockskit.png" alt="" /></p>

<p>这篇文成首先会从上到下对整个工作原理进行概述，然后再从底层到顶层详细地解释这个框架的机制和原理。</p>

<h3 id="动态代理工作概述">动态代理工作概述</h3>

<p>在这里我们要对这部分的实现进行一个简单的概述，从上到下跟踪 BlocksKit 的调用过程。</p>

<p>以 <code class="highlighter-rouge">UIImagePickerController</code> 为例，因为这个文件中的代码较少，能省去很多不必要的实现细节。</p>

<p>在头文件中声明了两个属性，也就是 <code class="highlighter-rouge">UIImagePickerController</code> 代理方法的对应 block 属性：</p>

<pre><code class="language-objectivec">@property (nonatomic，copy) void(^bk_didFinishPickingMediaBlock)(UIImagePickerController *，NSDictionary *);
@property (nonatomic，copy) void(^bk_didCancelBlock)(UIImagePickerController *);
</code></pre>

<p>然后在实现文件中动态生成这两个方法的存取方法</p>

<pre><code class="language-objectivec">@dynamic bk_didFinishPickingMediaBlock;
@dynamic bk_didCancelBlock;
</code></pre>

<p>你可以看到在这个名为 <code class="highlighter-rouge">BlocksKit</code> 的分类中只添加了一个方法：</p>

<pre><code class="language-objectivec">+ (void)load
{
	@autoreleasepool {
		[self bk_registerDynamicDelegate];
		[self bk_linkDelegateMethods:@{ @"bk_didFinishPickingMediaBlock": @"imagePickerController:didFinishPickingMediaWithInfo:",
                                        @"bk_didCancelBlock": @"imagePickerControllerDidCancel:" }];
	}
}
</code></pre>

<p>在 <code class="highlighter-rouge">load</code> 中实现这个方法，能够减少其中两个方法的调用次数，在 <code class="highlighter-rouge">autoreleasepool</code> 块中调用方法，使得其它地方的代码不会受到这里注册代理，链接代理方法中产生的对象的影响。</p>

<p><code class="highlighter-rouge">bk_registerDynamicDelegate</code> 方法是 <code class="highlighter-rouge">NSObject+A2BlockDelegate</code> 分类中添加的方法，用于修改原有属性 <code class="highlighter-rouge">delegate</code> 方法的实现（<strong>动态替换 delegate 方法实现</strong>）。在这里就是与 <code class="highlighter-rouge">UIImagePickerController+BlocksKit</code> 处于同一文件下的 <code class="highlighter-rouge">A2DynamicUIImagePickerControllerDelegate</code>，先不说这个文件的功能，会在之后介绍。</p>

<p>在 <code class="highlighter-rouge">NSObject+A2DynamicDelegate</code> 分类中的 <code class="highlighter-rouge">bk_registerDynamicDelegateNamed:forProtocol:</code> 修改 <code class="highlighter-rouge">@selector(delegate)</code> 和 <code class="highlighter-rouge">@selector(setDelegate:)</code> 的实现，使用 <code class="highlighter-rouge">A2DynamicUIImagePickerControllerDelegate</code> 替换原有的 <code class="highlighter-rouge">delegate</code></p>

<pre><code class="language-objectivec">IMP setterImplementation = imp_implementationWithBlock(^(NSObject *delegatingObject，id delegate) {
	A2DynamicDelegate *dynamicDelegate = getDynamicDelegate(delegatingObject，protocol，infoAsPtr，YES);
	if ([delegate isEqual:dynamicDelegate]) {
		delegate = nil;
	}
	dynamicDelegate.realDelegate = delegate;
});

IMP getterImplementation = imp_implementationWithBlock(^(NSObject *delegatingObject) {
    return [delegatingObject bk_dynamicDelegateForProtocol:a2_protocolForDelegatingObject(delegatingObject，protocol)];
});
</code></pre>

<p>在获取 <code class="highlighter-rouge">delegate</code> 属性时，就会获取 <code class="highlighter-rouge">A2DynamicUIImagePickerControllerDelegate</code>， <code class="highlighter-rouge">realDelegate</code> 相当于原有的 <code class="highlighter-rouge">delegate</code> 属性，会在下面的小节中具体分析。</p>

<p>在 <code class="highlighter-rouge">load</code> 方法中调用下一个方法是 <code class="highlighter-rouge">bk_linkDelegateMethods:</code> 这个方法会把代理方法和对应的 block 属性链接起来，这样可以通过代理方法的选择子查找对应的 block。</p>

<pre><code class="language-objectivec">IMP getterImplementation = imp_implementationWithBlock(^(NSObject *delegatingObject) {
	A2DynamicDelegate *delegate = getDynamicDelegate(delegatingObject，protocol，info，NO);
	return [delegate blockImplementationForMethod:selector];
});

IMP setterImplementation = imp_implementationWithBlock(^(NSObject *delegatingObject，id block) {
	A2DynamicDelegate *delegate = getDynamicDelegate(delegatingObject，protocol，info，YES);
	[delegate implementMethod:selector withBlock:block];
});
</code></pre>

<p>通过调用 <code class="highlighter-rouge">A2DynamicDelegate</code> 的实例方法 <code class="highlighter-rouge">blockImplementationForMethod:</code> 和 <code class="highlighter-rouge">implementMethod:withBlock:</code> 动态实现 block 的存取方法。</p>

<p>当代理方法 <code class="highlighter-rouge">imagePickerController:didFinishPickingMediaWithInfo:</code> 被调用时，因为 <code class="highlighter-rouge">A2DynamicUIImagePickerControllerDelegate</code> 是 <code class="highlighter-rouge">UIImagePickerController</code> 的代理，所以会调用它的方法：</p>

<pre><code class="language-objectivec">- (void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary *)info {
	id realDelegate = self.realDelegate;
	if (realDelegate &amp;&amp; [realDelegate respondsToSelector:@selector(imagePickerController:didFinishPickingMediaWithInfo:)])
		[realDelegate imagePickerController:picker didFinishPickingMediaWithInfo:info];

	void (^block)(UIImagePickerController *，NSDictionary *) = [self blockImplementationForMethod:_cmd];
	if (block) block(picker，info);
}
</code></pre>

<p>通过 <code class="highlighter-rouge">blockImplementationForMethod:</code> 方法获取在上面存储的 block，然后传入参数执行该代码块。</p>

<ol>
  <li>在 <code class="highlighter-rouge">load</code> 方法注册动态代理并链接代理方法</li>
  <li>在运行时修改原有的 <code class="highlighter-rouge">delegate</code> 属性的存取方法，使用 <code class="highlighter-rouge">A2DynamicDelegate</code> 替换原有的 <code class="highlighter-rouge">delegate</code>，原有的 <code class="highlighter-rouge">delegate</code> 换为 <code class="highlighter-rouge">realDelegate</code></li>
  <li>为 block 属性动态实现存取方法，返回对应 <code class="highlighter-rouge">A2DynamicDelegate</code> 子类中存储的 block</li>
  <li>在代理方法真正被调用时，查找 <code class="highlighter-rouge">realDelegate</code> 中是否对代理方法做出响应，无论是否响应，都通过选择子查找对应的 <code class="highlighter-rouge">block</code>，然后传入相应参数执行 block</li>
</ol>

<h3 id="自底向上分析动态代理的工作">自底向上分析动态代理的工作</h3>

<p>我们已经自顶向下分析了 BlocksKit 的工作过程，也对这个部分有一个基本的了解，接下来我们将从底层到顶层分析整个 BlocksKit，我们再来看一下整个框架的结构图：</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-03-20-blockskit.png" alt="" /></p>

<p>我们将以下面的顺序来依次介绍这些模块，其中的 <code class="highlighter-rouge">UITextField</code> 可以换成其它的类：</p>

<ol>
  <li>A2BlockInvocation</li>
  <li>A2DynamicDelegate</li>
  <li>NSObject+A2DynamicDelegate</li>
  <li>A2DynamicUITextFieldDelegate</li>
  <li>UITextField+BlocksKit</li>
</ol>

<h4 id="a2blockinvocation">A2BlockInvocation</h4>

<p><code class="highlighter-rouge">A2BlockInvocation</code> 使用来对闭包，也就是 block 进行存储和转发的类。</p>

<p>先介绍这个的是因为 <code class="highlighter-rouge">A2BlockInvocation</code> 的功能比较底层，涉及的内容也都比较奇葩，所以想先简单介绍一下，避免之后一个类分几部分介绍。</p>

<p>在 Objective-C 中，每一个方法甚至 block 都是有类型签名的：</p>

<pre><code class="language-objectivec">@interface NSMethodSignature : NSObject {

...

@property (readonly) NSUInteger numberOfArguments;

...

@property (readonly) const char *methodReturnType NS_RETURNS_INNER_POINTER;

...

@end
</code></pre>

<p>它们有返回类型、参数数字和参数类型等等。</p>

<h5 id="block-结构体">Block 结构体</h5>

<p>block 的签名没有哪个函数能够直接获取，它存储在 block 的结构体中，就像这样：</p>

<pre><code class="language-objectivec">typedef NS_OPTIONS(int，BKBlockFlags) {
	BKBlockFlagsHasCopyDisposeHelpers = (1 &lt;&lt; 25),
	BKBlockFlagsHasSignature          = (1 &lt;&lt; 30)
};

typedef struct _BKBlock {
	__unused Class isa;
	BKBlockFlags flags;
	__unused int reserved;
	void (__unused *invoke)(struct _BKBlock *block，...);
	struct {
		unsigned long int reserved;
		unsigned long int size;
		// requires BKBlockFlagsHasCopyDisposeHelpers
		void (*copy)(void *dst，const void *src);
		void (*dispose)(const void *);
		// requires BKBlockFlagsHasSignature
		const char *signature;
		const char *layout;
	} *descriptor;
	// imported variables
} *BKBlockRef;
</code></pre>

<p>这部分其实就是 block 实际存储在内存中的数据接口，可以在 runtime 中的源代码中看到这里的代码。</p>

<h5 id="typesignatureforblock">typeSignatureForBlock</h5>

<p>上面的 <code class="highlighter-rouge">signature</code> 就是 block 的签名，下面实现方法来获取这个签名</p>

<pre><code class="language-objectivec">+ (NSMethodSignature *)typeSignatureForBlock:(id)block __attribute__((pure，nonnull(1)))
{
	BKBlockRef layout = (__bridge void *)block;

	// 如果 block 没有签名直接返回空
	if (!(layout-&gt;flags &amp; BKBlockFlagsHasSignature))
		return nil;

	void *desc = layout-&gt;descriptor;
	desc += 2 * sizeof(unsigned long int);

	if (layout-&gt;flags &amp; BKBlockFlagsHasCopyDisposeHelpers)
		desc += 2 * sizeof(void *);

	if (!desc)
		return nil;

	const char *signature = (*(const char **)desc);

	return [NSMethodSignature signatureWithObjCTypes:signature];
}
</code></pre>

<p>知道了这个方法的作用再理解它的实现就非常简单了，根据<code class="highlighter-rouge">flag</code> 来移动指针，最终 <code class="highlighter-rouge">signature</code> 所在的内存空间。</p>

<blockquote>
  <p>Unlike a typical method signature，a block type signature has no <code class="highlighter-rouge">self</code> (<code class="highlighter-rouge">'@'</code>)
 or <code class="highlighter-rouge">_cmd</code> (<code class="highlighter-rouge">':'</code>) parameter，but instead just one parameter for the block itself
 (<code class="highlighter-rouge">'@?'</code>)。</p>
</blockquote>

<p>在这里所涉及的 <code class="highlighter-rouge">@</code>、<code class="highlighter-rouge">:</code> 和<code class="highlighter-rouge">@?</code> 可以看这里的文档 <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html">类型编码</a></p>

<p>在一般的方法签名中 block 的类型签名是没有 <code class="highlighter-rouge">self</code> (<code class="highlighter-rouge">'@'</code>) 或者 <code class="highlighter-rouge">_cmd</code> (<code class="highlighter-rouge">':'</code>) 的，只有一个参数代表 block 自己 (<code class="highlighter-rouge">'@?'</code>).</p>

<ul>
  <li><code class="highlighter-rouge">^(UIActionSheet *) {}</code>
    <ul>
      <li>参数类型：<code class="highlighter-rouge">@?(@"UIActionSheet")</code></li>
      <li>返回类型：<code class="highlighter-rouge">v</code></li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">- (void)willPresentActionSheet:(UIActionSheet *)actionSheet</code>
    <ul>
      <li>参数类型：<code class="highlighter-rouge">@:@</code></li>
      <li>返回类型：<code class="highlighter-rouge">v</code></li>
    </ul>
  </li>
</ul>

<p>为什么要把 <code class="highlighter-rouge">@"UIActionSheet"</code> 标记上括号？因为它们属于同一个参数。</p>

<p>同时因为 <code class="highlighter-rouge">UIActionSheet</code> 也是 <code class="highlighter-rouge">id</code> 类型，所以它的类型编码也是 <code class="highlighter-rouge">@</code>。</p>

<p>当调用 <code class="highlighter-rouge">initWithBlock:</code> 方法时，会先调用上面说的方法 <code class="highlighter-rouge">typeSignatureForBlock:</code> 获取 block 的类型签名：</p>

<pre><code class="language-objectivec">- (instancetype)initWithBlock:(id)block
{
	NSParameterAssert(block);
	NSMethodSignature *blockSignature = [[self class] typeSignatureForBlock:block];
	NSMethodSignature *methodSignature = [[self class] methodSignatureForBlockSignature:blockSignature];
	NSAssert(methodSignature，@"Incompatible block: %@"，block);
	return (self = [self initWithBlock:block methodSignature:methodSignature blockSignature:blockSignature]);
}
</code></pre>

<h5 id="methodsignatureforblocksignature">methodSignatureForBlockSignature</h5>

<p>然后调用 <code class="highlighter-rouge">methodSignatureForBlockSignature:</code> 方法构造一个可以兼容的方法签名：</p>

<pre><code class="language-objectivec">+ (NSMethodSignature *)methodSignatureForBlockSignature:(NSMethodSignature *)original
{
	#1: 检查方法签名的参数，省略

	NSMutableString *signature = [[NSMutableString alloc] initWithCapacity:original.numberOfArguments + 1];

	const char *retTypeStr = original.methodReturnType;
	// 返回类型，id 类型(self @)，选择子类型(SEL :)
	[signature appendFormat:@"%s%s%s"，retTypeStr，@encode(id)，@encode(SEL)];
	// signature = (返回类型)@:

	for (NSUInteger i = 1; i &lt; original.numberOfArguments; i++) {
		const char *typeStr = [original getArgumentTypeAtIndex:i];
		NSString *type = [[NSString alloc] initWithBytesNoCopy:(void *)typeStr length:strlen(typeStr) encoding:NSUTF8StringEncoding freeWhenDone:NO];
		[signature appendString:type];
	}

	// signature = (返回类型)@:(参数类型)

	return [NSMethodSignature signatureWithObjCTypes:signature.UTF8String];
}
</code></pre>

<p>具体的实现细节我们就省略了，它的工作原理是把 <code class="highlighter-rouge">@?(@"UIActionSheet")</code> 类型签名转换成 <code class="highlighter-rouge">@:@</code>，然后返回方法签名。</p>

<p>关于代码中的 <code class="highlighter-rouge">@encode</code> 可以看这里 <a href="https://gcc.gnu.org/onlinedocs/gcc-3.2/gcc/Function-Attributes.html">声明方法的属性</a></p>

<h5 id="issignaturecompatiblewithsignature">isSignature:compatibleWithSignature:</h5>

<p>在这个类中最后一个重要的方法就是 <code class="highlighter-rouge">isSignature:compatibleWithSignature:</code>，这个方法是判断传入的 block 和方法的类型签名是否兼容。</p>

<pre><code class="language-objectivec">+ (BOOL)isSignature:(NSMethodSignature *)signatureA compatibleWithSignature:(NSMethodSignature *)signatureB __attribute__((pure))
{
	#1: 参数检查，省略

	...

	#2: 判断返回值是否相同，省略
	if (signatureA.methodReturnType[0] != signatureB.methodReturnType[0]) return NO;

	#3: 设置 methodSignature 和 blockSignature

	...

	#4: 比较 methodSignature 和 blockSignature

	return YES;
}
</code></pre>

<p>第 <code class="highlighter-rouge">#3</code> 部分设置 <code class="highlighter-rouge">methodSignature</code> 和 <code class="highlighter-rouge">blockSignature</code>。</p>

<p>因为<strong>方法签名会比 block 类型签名多一个默认参数</strong>，所以，这里会将参数多的设置为 <code class="highlighter-rouge">methodSignature</code>，如果把为 block 类型签名的设置给了 <code class="highlighter-rouge">methodSignature</code> 也不会有问题，在 <code class="highlighter-rouge">#4</code> 部分会判断出来并返回 <code class="highlighter-rouge">NO</code>。</p>

<blockquote>
  <p>方法默认参数：<code class="highlighter-rouge">self，SEL</code>，block 默认类型参数: <code class="highlighter-rouge">block</code></p>
</blockquote>

<pre><code class="language-objectivec">NSMethodSignature *methodSignature = nil，*blockSignature = nil;
if (signatureA.numberOfArguments &gt; signatureB.numberOfArguments) {
    methodSignature = signatureA;
    blockSignature = signatureB;
} else if (signatureB.numberOfArguments &gt; signatureA.numberOfArguments) {
    methodSignature = signatureB;
    blockSignature = signatureA;
} else {
    return NO;
}
</code></pre>

<p>第 <code class="highlighter-rouge">#4</code> 部分就是一次比较各个类型签名，也没什么复杂的，需要注意的就是选择正确的 index</p>

<pre><code class="language-objectivec">NSUInteger numberOfArguments = methodSignature.numberOfArguments;
for (NSUInteger i = 2; i &lt; numberOfArguments; i++) {
    if ([methodSignature getArgumentTypeAtIndex:i][0] != [blockSignature getArgumentTypeAtIndex:i - 1][0])
        return NO;
}
</code></pre>

<h5 id="invokewithinvocationreturnvalueoutreturnvalue">invokeWithInvocation:returnValue:outReturnValue:</h5>

<p>这一节主要介绍的是，当 <code class="highlighter-rouge">A2BlockInvocation</code> 对象具体需要执行某一个 <code class="highlighter-rouge">NSInvocation</code> 时是如何工作的，其实这个方法还是很容易理解的。</p>

<pre><code class="language-objectivec">- (BOOL)invokeWithInvocation:(NSInvocation *)outerInv returnValue:(out NSValue **)outReturnValue setOnInvocation:(BOOL)setOnInvocation
{
	#1: 参数以及类型签名是否匹配的检查，省略

	NSInvocation *innerInv = [NSInvocation invocationWithMethodSignature:self.blockSignature];

	#2: 设置 innerInv 参数

	...

	[innerInv invokeWithTarget:self.block];

	#3: 获取返回值

	free(argBuf);

	return YES;
}
</code></pre>

<p>第 <code class="highlighter-rouge">#2</code>、<code class="highlighter-rouge">#3</code> 部分的代码是为了设置 <code class="highlighter-rouge">innerInv</code> 的参数，获取返回值：</p>

<pre><code class="language-objectivec">void *argBuf = NULL;

for (NSUInteger i = 2; i &lt; sig.numberOfArguments; i++) {
	const char *type = [sig getArgumentTypeAtIndex:i];
	NSUInteger argSize;
	NSGetSizeAndAlignment(type，&amp;argSize，NULL);

	if (!(argBuf = reallocf(argBuf，argSize))) {
		return NO;
	}

	[outerInv getArgument:argBuf atIndex:i];
	[innerInv setArgument:argBuf atIndex:i - 1];
}

// 执行 block

NSUInteger retSize = sig.methodReturnLength;
if (retSize) {
    if (outReturnValue || setOnInvocation) {
        if (!(argBuf = reallocf(argBuf，retSize))) {
            return NO;
        }

        [innerInv getReturnValue:argBuf];

        if (setOnInvocation) {
            [outerInv setReturnValue:argBuf];
        }

        if (outReturnValue) {
            *outReturnValue = [NSValue valueWithBytes:argBuf objCType:sig.methodReturnType];
        }
    }
} else {
    if (outReturnValue) {
        *outReturnValue = nil;
    }
}
</code></pre>

<p><code class="highlighter-rouge">A2BlockInvocation</code> 这一节就到这里了，接下来要说一下 <code class="highlighter-rouge">A2DynamicDelegate</code>。</p>

<h4 id="a2dynamicdelegate">A2DynamicDelegate</h4>

<p><code class="highlighter-rouge">A2DynamicDelegate</code> 可以说是 BlocksKit 实现动态代理的关键，是这个框架中很重要的类，它通过 block 实现了类的代理和数据源等协议。</p>

<p><code class="highlighter-rouge">A2DynamicDelegate</code> 它的父类是 <code class="highlighter-rouge">NSProxy</code>，而 <code class="highlighter-rouge">NSProxy</code> 出现的目的就是为了代理一个对象的。</p>

<pre><code class="language-objectivec">@interface NSProxy &lt;NSObject&gt;
</code></pre>

<p>我们不具体解释这里的 <code class="highlighter-rouge">NSProxy</code>，如果想要更详细的信息，请看<a href="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Reference/Foundation/Classes/NSProxy_Class/index.html">这里</a>。</p>

<p><code class="highlighter-rouge">A2DynamicDelegate</code> 作为 <code class="highlighter-rouge">NSProxy</code> 的子类，必须实现 <code class="highlighter-rouge">forwardInvocation:</code> <code class="highlighter-rouge">methodSignatureForSelector:</code> 方法进行对象转发，这是在苹果官方文档中说明的。</p>

<h5 id="覆写必要的方法-methodsignatureforselector-和-forwardinvocation">覆写必要的方法 methodSignatureForSelector: 和 forwardInvocation:</h5>

<p>我们首先来看一下 <code class="highlighter-rouge">methodSignatureForSelector:</code>，它为一个选择子返回合适的方法签名：</p>

<pre><code class="language-objectivec">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector
{
	A2BlockInvocation *invocation = nil;
	if ((invocation = [self.invocationsBySelectors bk_objectForSelector:aSelector]))
		return invocation.methodSignature;
	else if ([self.realDelegate methodSignatureForSelector:aSelector])
		return [self.realDelegate methodSignatureForSelector:aSelector];
	else if (class_respondsToSelector(object_getClass(self)，aSelector))
		return [object_getClass(self) methodSignatureForSelector:aSelector];
	return [[NSObject class] methodSignatureForSelector:aSelector];
}
</code></pre>

<p>这里的逻辑如下：</p>

<ol>
  <li>判断 <code class="highlighter-rouge">invocationsBySelectors</code> 属性中是否存储了该选择子对应的 <code class="highlighter-rouge">A2BlockInvocation</code>，直接返回这个 <code class="highlighter-rouge">invocation</code> 对象的类型签名，也就是说自己实现了该选择子对应的方法</li>
  <li>
    <p>在真正的 <code class="highlighter-rouge">realDelegate</code> 中查找原有的代理(不是当前的动态代理 <code class="highlighter-rouge">A2DynamicDelegate</code>)是否实现了该选择子，并返回方法签名</p>

    <blockquote>
      <p>在这里的 <code class="highlighter-rouge">realDelegate</code> 是对象真正的代理，例如</p>
    </blockquote>

    <pre><code class="language-objectivec"> self.tableView.delegate = [[UIViewController alloc] init];
</code></pre>

    <p>其中 <code class="highlighter-rouge">realDelegate</code> 是视图控制器，但是在我们设置时，不需要这么设置</p>

    <pre><code class="language-objectivec"> self.tableView.realDelegate = [[UIViewController alloc] init];
</code></pre>

    <p>因为在 <code class="highlighter-rouge">NSObject+A2BlockDelegate</code> 中会进行<strong>方法调剂</strong>，修改原有方法的实现，每次在设置 <code class="highlighter-rouge">delegate</code> 时，会将这个值设置传到 <code class="highlighter-rouge">realDelegate</code> 中。</p>
  </li>
  <li>在自己的类中查找该方法的选择子</li>
  <li>如果上面三个步骤都没有得到相应，那么调用 <code class="highlighter-rouge">NSObject</code> 对象的 <code class="highlighter-rouge">methodSignatureForSelector:</code> 方法获取方法签名，当然可能返回空值</li>
</ol>

<p>====</p>

<p><code class="highlighter-rouge">forwardInvocation:</code> 的实现其实跟上面的方法的思路差不多</p>

<pre><code class="language-objectivec">- (void)forwardInvocation:(NSInvocation *)outerInv
{
	SEL selector = outerInv.selector;
	A2BlockInvocation *innerInv = nil;
	if ((innerInv = [self.invocationsBySelectors bk_objectForSelector:selector])) {
		[innerInv invokeWithInvocation:outerInv];
	} else if ([self.realDelegate respondsToSelector:selector]) {
		[outerInv invokeWithTarget:self.realDelegate];
	}
}
</code></pre>

<ol>
  <li>
    <p>判断 <code class="highlighter-rouge">invocationsBySelectors</code> 属性中是否存储了该选择子对应的 <code class="highlighter-rouge">A2BlockInvocation</code>，然后调用 <code class="highlighter-rouge">invokeWithInvocation:</code> 传入 <code class="highlighter-rouge">outerInv</code> 转发这个方法，最终会调用 <code class="highlighter-rouge">- [A2BlockInvocation invokeWithInvocation:returnValue:setOnInvocation:]
</code></p>
  </li>
  <li>
    <p>判断 <code class="highlighter-rouge">realDelegate</code> 是否实现了该方法，如果真正的代理能做出响应，将方法转发给 <code class="highlighter-rouge">realDelegate</code></p>
  </li>
</ol>

<h5 id="block-实现方法-blockimplementationformethod-和-implementmethodwithblock">Block 实现方法 blockImplementationForMethod: 和 implementMethod:withBlock:</h5>

<p>这部分的代码其实相当于平时的 Getter/Setter</p>

<pre><code class="language-objectivec">- (id)blockImplementationForMethod:(SEL)selector
{
	A2BlockInvocation *invocation = nil;
	if ((invocation = [self.invocationsBySelectors bk_objectForSelector:selector]))
		return invocation.block;
	return NULL;
}
</code></pre>

<p>因为 block 都是在 <code class="highlighter-rouge">A2BlockInvocation</code> 中封装的，所以在通过选择子查找 block 的时候，实际上是查找对应的 <code class="highlighter-rouge">A2BlockInvocation</code>，然后返回它的 block。</p>

<pre><code class="language-objectivec">- (void)implementMethod:(SEL)selector withBlock:(id)block
{

	#1: 参数检查，省略

	if (!block) {
		[self.invocationsBySelectors bk_removeObjectForSelector:selector];
		return;
	}

	#2: 实例化 A2BlockInvocation

	[self.invocationsBySelectors bk_setObject:inv forSelector:selector];
}
</code></pre>

<p>如果能获取到方法的描述，那么就可以得到对应的方法签名，然后调用不同的初始化方法实例一个 <code class="highlighter-rouge">A2Blockinvocation</code> 对象。</p>

<pre><code class="language-objectivec">	struct objc_method_description methodDescription = protocol_getMethodDescription(self.protocol，selector，YES，!isClassMethod);
	if (!methodDescription.name) methodDescription = protocol_getMethodDescription(self.protocol，selector，NO，!isClassMethod);

	A2BlockInvocation *inv = nil;
	if (methodDescription.name) {
	    NSMethodSignature *protoSig = [NSMethodSignature signatureWithObjCTypes:methodDescription.types];
	    inv = [[A2BlockInvocation alloc] initWithBlock:block methodSignature:protoSig];
	} else {
	    inv = [[A2BlockInvocation alloc] initWithBlock:block];
	}
</code></pre>

<p>这两个方法的实现，主要目的是<strong>为子类实现代理方法提供支持</strong>。</p>

<h4 id="nsobjecta2dynamicdelegate-为对象添加动态代理">NSObject+A2DynamicDelegate 为对象添加动态代理</h4>

<p>这个分类是为所有的对象提供简单快捷的接口找到对应的动态代理:</p>

<pre><code class="language-objectivec">@property (readonly，strong) id bk_dynamicDataSource;
@property (readonly，strong) id bk_dynamicDelegate;
- (id)bk_dynamicDelegateForProtocol:(Protocol *)protocol;
</code></pre>

<p>以 <code class="highlighter-rouge">UITableView</code> 为例:</p>

<ul>
  <li>访问 <code class="highlighter-rouge">tableView.bk_dynamicDataSource</code> 那么它就会寻找 <code class="highlighter-rouge">A2DynamicUITableViewDataSource</code> 的对象</li>
  <li>访问 <code class="highlighter-rouge">tableView.bk_dynamicDelegate</code> 那么它就会寻找 <code class="highlighter-rouge">A2DynamicUITableViewDelegate</code> 的对象</li>
</ul>

<p>这些对象都是在后台进程中惰性初始化的：</p>

<pre><code class="language-objectivec">- (id)bk_dynamicDelegateWithClass:(Class)cls forProtocol:(Protocol *)protocol
{
	__block A2DynamicDelegate *dynamicDelegate;

	dispatch_sync(a2_backgroundQueue()，^{
		dynamicDelegate = objc_getAssociatedObject(self，(__bridge const void *)protocol);

		if (!dynamicDelegate)
		{
			dynamicDelegate = [[cls alloc] initWithProtocol:protocol];
			objc_setAssociatedObject(self，(__bridge const void *)protocol，dynamicDelegate，OBJC_ASSOCIATION_RETAIN_NONATOMIC);
		}
	});

	return dynamicDelegate;
}
</code></pre>

<h4 id="nsobjecta2blockdelegate">NSObject+A2BlockDelegate</h4>

<p>我们在概述的一部分实际上已经接触过这个分类里面的重要方法 <code class="highlighter-rouge">bk_linkProtocol:methods:</code>，它动态实现所有添加的 block 属性的存取方法，比如说 <code class="highlighter-rouge">bk_didFinishPickingMediaBlock</code> <code class="highlighter-rouge">bk_didCancelBlock</code></p>

<pre><code class="language-objectivec">		IMP getterImplementation = imp_implementationWithBlock(^(NSObject *delegatingObject) {
			A2DynamicDelegate *delegate = getDynamicDelegate(delegatingObject，protocol，info，NO);
			return [delegate blockImplementationForMethod:selector];
		});

		IMP setterImplementation = imp_implementationWithBlock(^(NSObject *delegatingObject，id block) {
			A2DynamicDelegate *delegate = getDynamicDelegate(delegatingObject，protocol，info，YES);
			[delegate implementMethod:selector withBlock:block];
		});
</code></pre>

<p>方法调剂之后的存取方法如下</p>

<ul>
  <li>getter: 以 selector 为键在动态代理中查找对应的 block</li>
  <li>setter: 以 selector 也就是代理方法为键，通过 <code class="highlighter-rouge">implementMethod:withBlock:</code> 方法以 <code class="highlighter-rouge">A2BlockInvocation</code> 的形式存储 block</li>
</ul>

<p>另一个方法 <code class="highlighter-rouge">bk_registerDynamicDelegateNamed:forProtocol:</code>，它主要功能就是修改 getter 和 setter 方法，将原有的 <code class="highlighter-rouge">delegate</code> 转发到 <code class="highlighter-rouge">realDelegate</code>，修改原有的 <code class="highlighter-rouge">delegate</code> 的实现，实现的方法就是喜闻乐见的方法调节：</p>

<pre><code class="language-objectivec">	IMP setterImplementation = imp_implementationWithBlock(^(NSObject *delegatingObject，id delegate) {
		A2DynamicDelegate *dynamicDelegate = getDynamicDelegate(delegatingObject，protocol，infoAsPtr，YES);
		if ([delegate isEqual:dynamicDelegate]) {
			delegate = nil;
		}
		dynamicDelegate.realDelegate = delegate;
	});

	IMP getterImplementation = imp_implementationWithBlock(^(NSObject *delegatingObject) {
		return [delegatingObject bk_dynamicDelegateForProtocol:a2_protocolForDelegatingObject(delegatingObject，protocol)];
	});
</code></pre>

<p>注意，在这里省略了一些与脉络无关的实现细节，在调剂过后 <code class="highlighter-rouge">delegate</code> 的存取方法如下：</p>

<ul>
  <li>getter：返回一个动态代理对象</li>
  <li>setter：设置代理并不会改变 <code class="highlighter-rouge">delegate</code> 中存储的动态代理，只会修改 <code class="highlighter-rouge">realDelegate</code></li>
</ul>

<p>我们现在有了通过 runtime 实现 block 的 getter/setter，修改原有的 <code class="highlighter-rouge">delegate</code> 属性的方法将对象的代理设置为动态代理，接下来要在子类化动态代理，使用动态代理的子类实现所有的代理方法。</p>

<h4 id="a2dynamicuitextfielddelegate">A2DynamicUITextFieldDelegate</h4>

<p><code class="highlighter-rouge">A2DynamicUITextFieldDelegate</code> 和 <code class="highlighter-rouge">UITextField+BlocksKit</code> 位于统一文件下，它是一个私有类，我们选取其中一个简单的代理方法：</p>

<pre><code class="language-objectivec">- (void)textFieldDidEndEditing:(UITextField *)textField
{
	id realDelegate = self.realDelegate;
	if (realDelegate &amp;&amp; [realDelegate respondsToSelector:@selector(textFieldDidEndEditing:)])
		[realDelegate textFieldDidEndEditing:textField];
	void (^block)(UITextField *) = [self blockImplementationForMethod:_cmd];
	if (block)
		block(textField);
}
</code></pre>

<ol>
  <li>当 <code class="highlighter-rouge">realDelegate</code> 实现了该代理方法时，首先调用代理的方法</li>
  <li>当该代理方法对应的 block 存在的话，也会调用该 block</li>
</ol>

<h4 id="uitextfieldblockskit-分类和-load-方法">UITextField+BlocksKit 分类和 load 方法</h4>

<p>在最后就是对 <code class="highlighter-rouge">NSObject+A2BlockDelegate</code> 分类中方法的调用</p>

<pre><code class="language-objectivec">+ (void)load {
    [self bk_registerDynamicDelegate];
    [self bk_linkDelegateMethods: @{
        @"bk_shouldBeginEditingBlock": @"textFieldShouldBeginEditing:",
        @"bk_didBeginEditingBlock": @"textFieldDidBeginEditing:",
        @"bk_shouldEndEditingBlock": @"textFieldShouldEndEditing:",
        @"bk_didEndEditingBlock" : @"textFieldDidEndEditing:",
        @"bk_shouldChangeCharactersInRangeWithReplacementStringBlock" : @"textField:shouldChangeCharactersInRange:replacementString:",
        @"bk_shouldClearBlock" : @"textFieldShouldClear:",
        @"bk_shouldReturnBlock" : @"textFieldShouldReturn:",
    }];
}
</code></pre>

<p>为什么在 <code class="highlighter-rouge">load</code> 方法中调用这两个方法？原因有两个：</p>

<ul>
  <li>该方法只会调用一次，减少了调用的次数</li>
  <li>该方法只会在文件被引用的时候调用，减少了不必要的动态代理注册等一系列步骤</li>
</ul>

<p>其中的 <code class="highlighter-rouge">autoreleasepool</code> 的作用在上面已经介绍过了，它使得其它地方的代码不会受到这里注册代理，链接代理方法中产生的对象的影响。</p>

<p><code class="highlighter-rouge">UIKit+BlocksKit</code> 这些分类的另一作用就是提供 block 回调接口，声明属性，然后使用 <code class="highlighter-rouge">@dynamic</code> 表明属性是动态生成的。</p>

<pre><code class="language-objectivec">@property (nonatomic，copy，nullable) BOOL(^bk_shouldBeginEditingBlock)(UITextField *textField);
@property (nonatomic，copy，nullable) void(^bk_didBeginEditingBlock)(UITextField *textField);

...

@dynamic bk_shouldBeginEditingBlock，bk_didBeginEditingBlock ...;
</code></pre>

<h2 id="end">End</h2>

<p>到这里对于 BlocksKit 的实现机制就基本上已经看完了。我们在来看一下 整个 BlocksKit 的结构图：</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-03-20-blockskit.png" alt="" /></p>

<p>我写这篇文章大约用了七天的时间，如果你对其中的内容有些疑问，可以发邮件或者在下面留言。</p>

<ul>
  <li><a href="http://draveness.me/blockskit-1/">神奇的 BlocksKit（一）</a></li>
  <li><a href="http://draveness.me/blockskit-2/">神奇的 BlocksKit（二）</a></li>
</ul>

<iframe src="http://ghbtns.com/github-btn.html?user=draveness&amp;type=follow&amp;size=large" height="30" width="240" frameborder="0" scrolling="0" style="width:240px; height: 30px;" allowtransparency="true"></iframe>

<p>Blog: <a href="http://draveness.me">Draveness</a></p>


	  ]]></description>
	</item>

	<item>
	  <title>神奇的 BlocksKit （一）</title>
	  <link>/reprinted//blockskit-1</link>
	  <author></author>
	  <pubDate>2016-03-10T09:42:33+00:00</pubDate>
	  <guid>/reprinted//blockskit-1</guid>
	  <description><![CDATA[
	     <blockquote>
  <p>关注仓库，及时获得更新：<a href="https://github.com/draveness/iOS-Source-Code-Analyze">iOS-Source-Code-Analyze</a></p>
</blockquote>

<p><strong>高能预警：本篇文章非常长，因为 BlocksKit 的实现还是比较复杂和有意的。这篇文章不是为了剖析 iOS 开发中的 block 的实现以及它是如何组成甚至使用的，如果你想通过这篇文章来了解 block 的实现，它并不能帮到你。</strong></p>

<p>Block 到底是什么？这可能是困扰很多 iOS 初学者的一个问题。如果你在 Google 上搜索类似的问题时，可以查找到几十万条结果，block 在 iOS 开发中有着非常重要的地位，而且它的作用也越来越重要。</p>

<hr />

<h2 id="概述">概述</h2>

<p>这篇文章仅对 <a href="https://github.com/zwaldowski/BlocksKit">BlocksKit</a> v2.2.5 的源代码进行分析，从框架的内部理解下面的功能是如何实现的：</p>

<ul>
  <li>为 <code class="highlighter-rouge">NSArray</code>、 <code class="highlighter-rouge">NSDictionary</code> 和 <code class="highlighter-rouge">NSSet</code> 等集合类型以及对应的可变集合类型 <code class="highlighter-rouge">NSMutableArray</code>、 <code class="highlighter-rouge">NSMutableDictionary</code> 和 <code class="highlighter-rouge">NSMutableSet</code> 添加 <code class="highlighter-rouge">bk_each:</code> 等方法完成对集合中元素的<strong>快速遍历</strong></li>
  <li>使用 block 对 <code class="highlighter-rouge">NSObject</code> 对象 KVO</li>
  <li>为 <code class="highlighter-rouge">UIView</code> 对象添加 <code class="highlighter-rouge">bk_whenTapped:</code> 等方法快速添加手势</li>
  <li>使用 block 替换 <code class="highlighter-rouge">UIKit</code> 中的 <code class="highlighter-rouge">delegate</code> ，涉及到核心模块 <code class="highlighter-rouge">DynamicDelegate</code>。</li>
</ul>

<p>BlocksKit 框架中包括但不仅限于上述的功能，这篇文章是对 <em>v2.2.5</em> 版本源代码的分析，其它版本的功能不会在本篇文章中具体讨论。</p>

<h2 id="如何提供简洁的遍历方法">如何提供简洁的遍历方法</h2>

<p>BlocksKit 实现的最简单的功能就是为集合类型添加方法遍历集合中的元素。</p>

<pre><code class="language-objectivec">[@[@1,@2,@3] bk_each:^(id obj) {
    NSLog(@"%@"，obj);
}];
</code></pre>

<p>这段代码非常简单，我们可以使用 <code class="highlighter-rouge">enumerateObjectsUsingBlock:</code> 方法替代 <code class="highlighter-rouge">bk_each:</code> 方法：</p>

<pre><code class="language-objectivec">[@[@1,@2,@3] enumerateObjectsUsingBlock:^(id obj，NSUInteger idx，BOOL *stop) {
    NSLog(@"%@"，obj);
}];

2016-03-05 16:02:57.295 Draveness[10725:453402] 1
2016-03-05 16:02:57.296 Draveness[10725:453402] 2
2016-03-05 16:02:57.297 Draveness[10725:453402] 3
</code></pre>

<p>这部分代码的实现也没什么难度：</p>

<pre><code class="language-objectivec">- (void)bk_each:(void (^)(id obj))block
{
	NSParameterAssert(block != nil);

	[self enumerateObjectsUsingBlock:^(id obj，NSUInteger idx，BOOL *stop) {
		block(obj);
	}];
}
</code></pre>

<p>它在 block 执行前会判断传进来的 block 是否为空，然后就是调用遍历方法，把数组中的每一个 <code class="highlighter-rouge">obj</code> 传给 block。</p>

<p>BlocksKit 在这些集合类中所添加的一些方法在 Ruby、Haskell 等语言中也同样存在。如果你接触过上面的语言，理解这里方法的功能也就更容易了，不过这不是这篇文章关注的主要内容。</p>

<pre><code class="language-objectivec">// NSArray+BlocksKit.h

- (void)bk_each:(void (^)(id obj))block;
- (void)bk_apply:(void (^)(id obj))block;
- (id)bk_match:(BOOL (^)(id obj))block;
- (NSArray *)bk_select:(BOOL (^)(id obj))block;
- (NSArray *)bk_reject:(BOOL (^)(id obj))block;
- (NSArray *)bk_map:(id (^)(id obj))block;
- (id)bk_reduce:(id)initial withBlock:(id (^)(id sum，id obj))block;
- (NSInteger)bk_reduceInteger:(NSInteger)initial withBlock:(NSInteger(^)(NSInteger result，id obj))block;
- (CGFloat)bk_reduceFloat:(CGFloat)inital withBlock:(CGFloat(^)(CGFloat result，id obj))block;
- (BOOL)bk_any:(BOOL (^)(id obj))block;
- (BOOL)bk_none:(BOOL (^)(id obj))block;
- (BOOL)bk_all:(BOOL (^)(id obj))block;
- (BOOL)bk_corresponds:(NSArray *)list withBlock:(BOOL (^)(id obj1，id obj2))block;
</code></pre>

<h2 id="nsobject-上的魔法">NSObject 上的魔法</h2>

<blockquote>
  <p><code class="highlighter-rouge">NSObject</code> 是 iOS 中的『上帝类』。</p>
</blockquote>

<p>在 <code class="highlighter-rouge">NSObject</code> 上添加的方法几乎会添加到 Cocoa Touch 中的所有类上，关于 <code class="highlighter-rouge">NSObject</code> 的讨论和总共分为以下三部分进行：</p>

<ol>
  <li>AssociatedObject</li>
  <li>BlockExecution</li>
  <li>BlockObservation</li>
</ol>

<h3 id="添加-associatedobject">添加 AssociatedObject</h3>

<p>经常跟 runtime 打交道的人不可能不知道 <a href="http://nshipster.cn/associated-objects/">AssociatedObject</a> ，当我们想要为一个已经存在的类添加属性时，就需要用到 AssociatedObject 为类添加属性，而  BlocksKit 提供了更简单的方法来实现，不需要新建一个分类。</p>

<pre><code class="language-objectivec">NSObject *test = [[NSObject alloc] init];
[test bk_associateValue:@"Draveness" withKey:@" name"];
NSLog(@"%@"，[test bk_associatedValueForKey:@"name"]);

2016-03-05 16:02:25.761 Draveness[10699:452125] Draveness
</code></pre>

<p>这里我们使用了 <code class="highlighter-rouge">bk_associateValue:withKey:</code> 和 <code class="highlighter-rouge">bk_associatedValueForKey:</code> 两个方法设置和获取 <code class="highlighter-rouge">name</code> 对应的值 <code class="highlighter-rouge">Draveness</code>.</p>

<pre><code class="language-objectivec">- (void)bk_associateValue:(id)value withKey:(const void *)key
{
	objc_setAssociatedObject(self，key，value，OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}
</code></pre>

<p>这里的 <code class="highlighter-rouge">OBJC_ASSOCIATION_RETAIN_NONATOMIC</code> 表示当前属性为 <code class="highlighter-rouge">retain</code> <code class="highlighter-rouge">nonatomic</code> 的，还有其它的参数如下：</p>

<pre><code class="language-objectivec">/**
 * Policies related to associative references.
 * These are options to objc_setAssociatedObject()
 */
typedef OBJC_ENUM(uintptr_t，objc_AssociationPolicy) {
    OBJC_ASSOCIATION_ASSIGN = 0，          /**&lt; Specifies a weak reference to the associated object. */
    OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1，/**&lt; Specifies a strong reference to the associated object.
                                            *   The association is not made atomically. */
    OBJC_ASSOCIATION_COPY_NONATOMIC = 3，  /**&lt; Specifies that the associated object is copied.
                                            *   The association is not made atomically. */
    OBJC_ASSOCIATION_RETAIN = 01401，      /**&lt; Specifies a strong reference to the associated object.
                                            *   The association is made atomically. */
    OBJC_ASSOCIATION_COPY = 01403          /**&lt; Specifies that the associated object is copied.
                                            *   The association is made atomically. */
};
</code></pre>

<p>上面的这个 NS_ENUM 也没什么好说的，需要注意的是这里没有 <code class="highlighter-rouge">weak</code> 属性。</p>

<p>BlocksKit 通过另一种方式实现了『弱属性』：</p>

<pre><code class="language-objectivec">- (void)bk_weaklyAssociateValue:(__autoreleasing id)value withKey:(const void *)key
{
	_BKWeakAssociatedObject *assoc = objc_getAssociatedObject(self，key);
	if (!assoc) {
		assoc = [_BKWeakAssociatedObject new];
		[self bk_associateValue:assoc withKey:key];
	}
	assoc.value = value;
}
</code></pre>

<p>在这里先获取了一个 <code class="highlighter-rouge">_BKWeakAssociatedObject</code> 对象 <code class="highlighter-rouge">assoc</code>，然后更新这个对象的属性 <code class="highlighter-rouge">value</code>。</p>

<p>因为直接使用 AssociatedObject 不能为对象添加弱属性，所以在这里添加了一个对象，然后让这个对象持有一个弱属性：</p>

<pre><code class="language-objectivec">@interface _BKWeakAssociatedObject : NSObject

@property (nonatomic，weak) id value;

@end

@implementation _BKWeakAssociatedObject

@end
</code></pre>

<p>这就是 BlocksKit 实现弱属性的方法，我觉得这个实现的方法还是比较简洁的。</p>

<p>getter 方法的实现也非常类似：</p>

<pre><code class="language-objectivec">- (id)bk_associatedValueForKey:(const void *)key
{
	id value = objc_getAssociatedObject(self，key);
	if (value &amp;&amp; [value isKindOfClass:[_BKWeakAssociatedObject class]]) {
		return [(_BKWeakAssociatedObject *)value value];
	}
	return value;
}
</code></pre>

<h3 id="在任意对象上执行-block">在任意对象上执行 block</h3>

<p>通过这个类提供的一些接口，可以在任意对象上快速执行线程安全、异步的 block，而且这些 block 也可以在执行之前取消。</p>

<pre><code class="language-objectivec">- (id &lt;NSObject，NSCopying&gt;)bk_performOnQueue:(dispatch_queue_t)queue afterDelay:(NSTimeInterval)delay usingBlock:(void (^)(id obj))block
{
    NSParameterAssert(block != nil);

    return BKDispatchCancellableBlock(queue，delay，^{
        block(self);
    });
}
</code></pre>

<p>判断 block 是否为空在这里都是细枝末节，这个方法中最关键的也就是它返回了一个可以取消的 block，而这个 block 就是用静态函数 <code class="highlighter-rouge">BKDispatchCancellableBlock</code> 生成的。</p>

<pre><code class="language-objectivec">static id &lt;NSObject，NSCopying&gt; BKDispatchCancellableBlock(dispatch_queue_t queue，NSTimeInterval delay，void(^block)(void)) {
    dispatch_time_t time = BKTimeDelay(delay);

#if DISPATCH_CANCELLATION_SUPPORTED
    if (BKSupportsDispatchCancellation()) {
        dispatch_block_t ret = dispatch_block_create(0，block);
        dispatch_after(time，queue，ret);
        return ret;
    }
#endif

    __block BOOL cancelled = NO;
    void (^wrapper)(BOOL) = ^(BOOL cancel) {
        if (cancel) {
            cancelled = YES;
            return;
        }
        if (!cancelled) block();
    };

    dispatch_after(time，queue，^{
        wrapper(NO);
    });

    return wrapper;
}
</code></pre>

<p>这个函数首先会执行 <code class="highlighter-rouge">BKSupportsDispatchCancellation</code> 来判断当前平台和版本是否支持使用 GCD 取消 block，当然一般都是支持的：</p>

<ul>
  <li>函数返回的是 <code class="highlighter-rouge">YES</code>，那么在 block 被派发到指定队列之后就会返回这个 <code class="highlighter-rouge">dispatch_block_t</code> 类型的 block</li>
  <li>函数返回的是 <code class="highlighter-rouge">NO</code>，那么就会就会手动包装一个可以取消的 block，具体实现的部分如下：</li>
</ul>

<pre><code class="language-objectivec">__block BOOL cancelled = NO;
void (^wrapper)(BOOL) = ^(BOOL cancel) {
    if (cancel) {
        cancelled = YES;
        return;
    }
    if (!cancelled) block();
};

dispatch_after(time，queue，^{
    wrapper(NO);
});

return wrapper;
</code></pre>

<p>上面这部分代码就先创建一个 <code class="highlighter-rouge">wrapper</code> block，然后派发到指定队列，派发到指定队列的这个 block 是一定会执行的，但是怎么取消这个 block 呢？</p>

<p>如果当前 block 没有执行，我们在外面调用一次 <code class="highlighter-rouge">wrapper(YES)</code> 时，block 内部的 <code class="highlighter-rouge">cancelled</code> 变量就会被设置为 <code class="highlighter-rouge">YES</code>，所以 block 就不会执行。</p>

<ol>
  <li><code class="highlighter-rouge">dispatch_after  --- cancelled = NO</code></li>
  <li><strong><code class="highlighter-rouge">wrapper(YES) --- cancelled = YES</code></strong></li>
  <li><code class="highlighter-rouge">wrapper(NO) --- cancelled = YES</code> block 不会执行</li>
</ol>

<p>这是实现取消的关键部分：</p>

<pre><code class="language-objectivec">+ (void)bk_cancelBlock:(id &lt;NSObject，NSCopying&gt;)block
{
    NSParameterAssert(block != nil);

#if DISPATCH_CANCELLATION_SUPPORTED
    if (BKSupportsDispatchCancellation()) {
        dispatch_block_cancel((dispatch_block_t)block);
        return;
    }
#endif

    void (^wrapper)(BOOL) = (void(^)(BOOL))block;
    wrapper(YES);
}
</code></pre>

<ul>
  <li>GCD 支持取消 block，那么直接调用 <code class="highlighter-rouge">dispatch_block_cancel</code> 函数取消 block</li>
  <li>GCD 不支持取消 block 那么调用一次 <code class="highlighter-rouge">wrapper(YES)</code></li>
</ul>

<h3 id="使用-block-封装-kvo">使用 Block 封装 KVO</h3>

<p>BlocksKit 对 KVO 的封装由两部分组成：</p>

<ol>
  <li><code class="highlighter-rouge">NSObject</code> 的分类负责提供便利方法</li>
  <li>私有类 <code class="highlighter-rouge">_BKObserver</code> 具体实现原生的 KVO 功能</li>
</ol>

<h4 id="提供接口并在-dealloc-时停止-blockobservation">提供接口并在 <code class="highlighter-rouge">dealloc</code> 时停止 BlockObservation</h4>

<p><code class="highlighter-rouge">NSObject+BKBlockObservation</code> 这个分类中的大部分接口都会调用这个方法:</p>

<pre><code class="language-objectivec">- (void)bk_addObserverForKeyPaths:(NSArray *)keyPaths identifier:(NSString *)identifier options:(NSKeyValueObservingOptions)options context:(BKObserverContext)context task:(id)task
{
	#1: 检查参数，省略

	#2: 使用神奇的方法在分类中覆写 dealloc

	NSMutableDictionary *dict;
	_BKObserver *observer = [[_BKObserver alloc] initWithObservee:self keyPaths:keyPaths context:context task:task];
	[observer startObservingWithOptions:options];

	#3: 惰性初始化 bk_observerBlocks 也就是下面的 dict，省略

	dict[identifier] = observer;
}
</code></pre>

<p>我们不会在这里讨论 <code class="highlighter-rouge">#1</code>、<code class="highlighter-rouge">#3</code> 部分，再详细阅读 <code class="highlighter-rouge">#2</code> 部分代码之前，先来看一下这个省略了绝大部分细节的核心方法。</p>

<p>使用传入方法的参数创建了一个 <code class="highlighter-rouge">_BKObserver</code> 对象，然后调用 <code class="highlighter-rouge">startObservingWithOptions:</code> 方法开始 KVO 观测相应的属性，然后以 <code class="highlighter-rouge">{identifier，obeserver}</code> 的形式存到字典中保存。</p>

<p>这里实在没什么新意，我们在下一小节中会介绍 <code class="highlighter-rouge">startObservingWithOptions:</code> 这一方法。</p>

<h4 id="在分类中调剂-dealloc-方法">在分类中调剂 dealloc 方法</h4>

<p>这个问题我觉得是非常值得讨论的一个问题，也是我最近在写框架时遇到很棘手的一个问题。</p>

<blockquote>
  <p>当我们在分类中注册一些通知或者使用 KVO 时，很有可能会找不到注销这些通知的时机。</p>
</blockquote>

<p>因为在<strong>分类中是无法直接实现 <code class="highlighter-rouge">dealloc</code> 方法的</strong>。 在 iOS8 以及之前的版本，如果某个对象被释放了，但是刚对象的注册的通知没有被移除，那么当事件再次发生，就会<em>向已经释放的对象发出通知</em>，整个程序就会崩溃。</p>

<p>这里解决的办法就十分的巧妙:</p>

<pre><code class="language-objectivec">Class classToSwizzle = self.class;
// 获取所有修改过 dealloc 方法的类
NSMutableSet *classes = self.class.bk_observedClassesHash;

// 保证互斥避免 classes 出现难以预测的结果
@synchronized (classes) {

   // 获取当前类名，并判断是否修改过 dealloc 方法以减少这部分代码的调用次数
   NSString *className = NSStringFromClass(classToSwizzle);
   if (![classes containsObject:className]) {
       // 这里的 sel_registerName 方法会返回 dealloc 的 selector，因为 dealloc 已经注册过
       SEL deallocSelector = sel_registerName("dealloc");

		__block void (*originalDealloc)(__unsafe_unretained id，SEL) = NULL;

       // 实现新的 dealloc 方法
		id newDealloc = ^(__unsafe_unretained id objSelf) {
           //在方法 dealloc 之前移除所有 observer
           [objSelf bk_removeAllBlockObservers];

           if (originalDealloc == NULL) {
               // 如果原有的 dealloc 方法没有被找到就会查找父类的 dealloc 方法，调用父类的 dealloc 方法
               struct objc_super superInfo = {
                   .receiver = objSelf,
                   .super_class = class_getSuperclass(classToSwizzle)
               };

               void (*msgSend)(struct objc_super *，SEL) = (__typeof__(msgSend))objc_msgSendSuper;
               msgSend(&amp;superInfo，deallocSelector);
           } else {
               // 如果 dealloc 方法被找到就会直接调用该方法，并传入参数
               originalDealloc(objSelf，deallocSelector);
           }
       };

       // 构建选择子实现 IMP
       IMP newDeallocIMP = imp_implementationWithBlock(newDealloc);

       // 向当前类添加方法，但是多半不会成功，因为类已经有 dealloc 方法
       if (!class_addMethod(classToSwizzle，deallocSelector，newDeallocIMP，"v@:")) {
           // 获取原有 dealloc 实例方法
           Method deallocMethod = class_getInstanceMethod(classToSwizzle，deallocSelector);

           // 存储 dealloc 方法实现防止在 set 的过程中调用该方法
           originalDealloc = (void(*)(__unsafe_unretained id，SEL))method_getImplementation(deallocMethod);

           // 重新设置 dealloc 方法的实现，并存储到 originalDealloc 防止方法实现改变
           originalDealloc = (void(*)(__unsafe_unretained id，SEL))method_setImplementation(deallocMethod，newDeallocIMP);
       }

       // 将当前类名添加到已经改变的类的集合中
       [classes addObject:className];
   }
}
</code></pre>

<p>这部分代码的执行顺序如下:</p>

<ol>
  <li>首先调用 <code class="highlighter-rouge">bk_observedClassesHash</code> 类方法获取所有修改过 <code class="highlighter-rouge">dealloc</code> 方法的类的集合 <code class="highlighter-rouge">classes</code></li>
  <li>使用 <code class="highlighter-rouge">@synchronized (classes)</code> 保证互斥，避免同时修改 <code class="highlighter-rouge">classes</code> 集合的类过多出现意料之外的结果</li>
  <li>判断即将调剂方法的类 <code class="highlighter-rouge">classToSwizzle</code> 是否调剂过 <code class="highlighter-rouge">dealloc</code> 方法</li>
  <li>如果 <code class="highlighter-rouge">dealloc</code> 方法没有调剂过，就会通过 <code class="highlighter-rouge">sel_registerName("dealloc")</code> 方法获取选择子，这行代码并不会真正注册 <code class="highlighter-rouge">dealloc</code> 选择子而是会获取 <code class="highlighter-rouge">dealloc</code> 的选择子，具体原因可以看这个方法的实现 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Reference/ObjCRuntimeRef/index.html#//apple_ref/c/func/sel_registerName">sel_registerName</a></li>
  <li>
    <p>在新的 <code class="highlighter-rouge">dealloc</code> 中<strong>添加移除 Observer 的方法</strong>， 再调用原有的 <code class="highlighter-rouge">dealloc</code></p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> id newDealloc = ^(__unsafe_unretained id objSelf) {
 	[objSelf bk_removeAllBlockObservers];

    if (originalDealloc == NULL) {
     	struct objc_super superInfo = {
      		.receiver = objSelf,
     		.super_class = class_getSuperclass(classToSwizzle)
     	};
         void (*msgSend)(struct objc_super *，SEL) = (__typeof__(msgSend))objc_msgSendSuper;
         msgSend(&amp;superInfo，deallocSelector);
     } else {
         originalDealloc(objSelf，deallocSelector);
     }
 };
 IMP newDeallocIMP = imp_implementationWithBlock(newDealloc);
</code></pre></div>    </div>

    <ol>
      <li>调用 <code class="highlighter-rouge">bk_removeAllBlockObservers</code> 方法移除所有观察者，也就是这段代码的最终目的</li>
      <li>根据 <code class="highlighter-rouge">originalDealloc</code> 是否为空，决定是向父类发送消息，还是直接调用 <code class="highlighter-rouge">originalDealloc</code> 并传入 <code class="highlighter-rouge">objSelf，deallocSelector</code> 作为参数</li>
    </ol>
  </li>
  <li>
    <p>在我们获得了新 <code class="highlighter-rouge">dealloc</code> 方法的选择子和 <code class="highlighter-rouge">IMP</code> 时，就要改变原有的 <code class="highlighter-rouge">dealloc</code> 的实现了</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> if (!class_addMethod(classToSwizzle，deallocSelector，newDeallocIMP，"v@:")) {
     // The class already contains a method implementation.
     Method deallocMethod = class_getInstanceMethod(classToSwizzle，deallocSelector);

    // We need to store original implementation before setting new implementation
     // in case method is called at the time of setting.
     originalDealloc = (void(*)(__unsafe_unretained id，SEL))method_getImplementation(deallocMethod);

    // We need to store original implementation again，in case it just changed.
     originalDealloc = (void(*)(__unsafe_unretained id，SEL))method_setImplementation(deallocMethod，newDeallocIMP);
 }
</code></pre></div>    </div>

    <ol>
      <li>调用 <code class="highlighter-rouge">class_addMethod</code> 方法为当前类添加选择子为 <code class="highlighter-rouge">dealloc</code> 的方法（当然 99.99% 的可能不会成功）</li>
      <li>获取原有的 <code class="highlighter-rouge">dealloc</code> 实例方法</li>
      <li>将原有的实现保存到 <code class="highlighter-rouge">originalDealloc</code> 中，防止使用 <code class="highlighter-rouge">method_setImplementation</code> 重新设置该方法的过程中调用 <code class="highlighter-rouge">dealloc</code> 导致无方法可用</li>
      <li>重新设置 <code class="highlighter-rouge">dealloc</code> 方法的实现。同样，将实现存储到 <code class="highlighter-rouge">originalDealloc</code> 中防止实现改变</li>
    </ol>
  </li>
</ol>

<p>关于在分类中调剂 <code class="highlighter-rouge">dealloc</code> 方法的这部分到这里就结束了，下一节将继续分析私有类 <code class="highlighter-rouge">_BKObserver</code>。</p>

<h4 id="私有类-_bkobserver">私有类 <code class="highlighter-rouge">_BKObserver</code></h4>

<p><code class="highlighter-rouge">_BKObserver</code> 是用来观测属性的对象，它在接口中定义了 4 个属性：</p>

<pre><code class="language-objectivec">@property (nonatomic，readonly，unsafe_unretained) id observee;
@property (nonatomic，readonly) NSMutableArray *keyPaths;
@property (nonatomic，readonly) id task;
@property (nonatomic，readonly) BKObserverContext context;
</code></pre>

<p>上面四个属性的具体作用在这里不说了，上面的 <code class="highlighter-rouge">bk_addObserverForKeyPaths:identifier:options:context:</code> 方法中调用 <code class="highlighter-rouge">_BKObserver</code> 的初始化方法 <code class="highlighter-rouge">initWithObservee:keyPaths:context:task:</code> 太简单了也不说了。</p>

<pre><code class="language-objectivec">_BKObserver *observer = [[_BKObserver alloc] initWithObservee:self keyPaths:keyPaths context:context task:task];
[observer startObservingWithOptions:options];
</code></pre>

<p>上面的第一行代码生成一个 <code class="highlighter-rouge">observer</code> 实例之后立刻调用了 <code class="highlighter-rouge">startObservingWithOptions:</code> 方法开始观测对应的 <code class="highlighter-rouge">keyPath</code>：</p>

<pre><code class="language-objectivec">- (void)startObservingWithOptions:(NSKeyValueObservingOptions)options
{
	@synchronized(self) {
		if (_isObserving) return;

		#1：遍历 keyPaths 实现 KVO

		_isObserving = YES;
	}
}
</code></pre>

<p><code class="highlighter-rouge">startObservingWithOptions:</code> 方法最重要的就是第 <code class="highlighter-rouge">#1</code> 部分：</p>

<pre><code class="language-objectivec">[self.keyPaths bk_each:^(NSString *keyPath) {
	[self.observee addObserver:self forKeyPath:keyPath options:options context:BKBlockObservationContext];
}];
</code></pre>

<p>遍历自己的 <code class="highlighter-rouge">keyPaths</code> 然后让 <code class="highlighter-rouge">_BKObserver</code> 作观察者观察自己，然后传入对应的 <code class="highlighter-rouge">keyPath</code>。</p>

<p>关于 <code class="highlighter-rouge">_stopObservingLocked</code> 方法的实现也十分的相似，这里就不说了。</p>

<pre><code class="language-objectivec">[keyPaths bk_each:^(NSString *keyPath) {
	[observee removeObserver:self forKeyPath:keyPath context:BKBlockObservationContext];
}];
</code></pre>

<p>到目前为止，我们还没有看到实现 KVO 所必须的方法 <code class="highlighter-rouge">observeValueForKeyPath:ofObject:change:context</code>，这个方法就是每次属性改变之后的回调：</p>

<pre><code class="language-objectivec">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context
{
	if (context != BKBlockObservationContext) return;

	@synchronized(self) {
		switch (self.context) {
			case BKObserverContextKey: {
				void (^task)(id) = self.task;
				task(object);
				break;
			}
			case BKObserverContextKeyWithChange: {
				void (^task)(id，NSDictionary *) = self.task;
				task(object，change);
				break;
			}
			case BKObserverContextManyKeys: {
				void (^task)(id，NSString *) = self.task;
				task(object，keyPath);
				break;
			}
			case BKObserverContextManyKeysWithChange: {
				void (^task)(id，NSString *，NSDictionary *) = self.task;
				task(object，keyPath，change);
				break;
			}
		}
	}
}
</code></pre>

<p>这个方法的实现也很简单，根据传入的 <code class="highlighter-rouge">context</code> 值，对 <code class="highlighter-rouge">task</code> 类型转换，并传入具体的值。</p>

<p>这个模块倒着就介绍完了，在下一节会介绍 BlocksKit 对 UIKit 组件一些简单的改造。</p>

<h2 id="改造-uikit">改造 UIKit</h2>

<p>在这个小结会具体介绍 BlocksKit 是如何对一些简单的控件进行改造的，本节大约有两部分内容：</p>

<ul>
  <li>UIGestureRecongizer + UIBarButtonItem + UIControl</li>
  <li>UIView</li>
</ul>

<h3 id="改造-uigesturerecongizeruibarbuttonitem-和-uicontrol">改造 UIGestureRecongizer，UIBarButtonItem 和 UIControl</h3>

<p>先来看一个 <code class="highlighter-rouge">UITapGestureRecognizer</code> 使用的例子</p>

<pre><code class="language-objectivec"> UITapGestureRecognizer *singleTap = [UITapGestureRecognizer bk_recognizerWithHandler:^(id sender) {
     NSLog(@"Single tap.");
 } delay:0.18];
 [self addGestureRecognizer:singleTap];
</code></pre>

<p>代码中的 <code class="highlighter-rouge">bk_recognizerWithHandler:delay:</code> 方法在最后都会调用初始化方法 <code class="highlighter-rouge">bk_initWithHandler:delay:</code> 生成一个 <code class="highlighter-rouge">UIGestureRecongizer</code> 的实例</p>

<pre><code class="language-objectivec">- (instancetype)bk_initWithHandler:(void (^)(UIGestureRecognizer *sender，UIGestureRecognizerState state，CGPoint location))block delay:(NSTimeInterval)delay
{
	self = [self initWithTarget:self action:@selector(bk_handleAction:)];
	if (!self) return nil;

	self.bk_handler = block;
	self.bk_handlerDelay = delay;

	return self;
}
</code></pre>

<p>它会在这个方法中传入 <code class="highlighter-rouge">target</code> 和 <code class="highlighter-rouge">selector</code>。 其中 <code class="highlighter-rouge">target</code> 就是 <code class="highlighter-rouge">self</code>，而 <code class="highlighter-rouge">selector</code> 也会在这个分类中实现：</p>

<pre><code class="language-objectivec">- (void)bk_handleAction:(UIGestureRecognizer *)recognizer
{
	void (^handler)(UIGestureRecognizer *sender，UIGestureRecognizerState state，CGPoint location) = recognizer.bk_handler;
	if (!handler) return;

	NSTimeInterval delay = self.bk_handlerDelay;

	#1: 封装 block 并控制 block 是否可以执行

	self.bk_shouldHandleAction = YES;

    [NSObject bk_performAfterDelay:delay usingBlock:block];
}
</code></pre>

<p>因为在初始化方法 <code class="highlighter-rouge">bk_initWithHandler:delay:</code> 中保存了当前手势的 <code class="highlighter-rouge">bk_handler</code>，所以直接调用在 Block Execution 一节中提到过的 <code class="highlighter-rouge">bk_performAfterDelay:usingBlock:</code> 方法，将 block 派发到指定的队列中，最终完成对 block 的调用。</p>

<h4 id="封装-block-并控制-block-是否可以执行">封装 block 并控制 block 是否可以执行</h4>

<p>这部分代码和前面的部分有些相似，因为这里也用到了一个属性 <code class="highlighter-rouge">bk_shouldHandleAction</code> 来控制 block 是否会被执行：</p>

<pre><code class="language-objectivec">CGPoint location = [self locationInView:self.view];
void (^block)(void) = ^{
	if (!self.bk_shouldHandleAction) return;
	handler(self，self.state，location);
};
</code></pre>

<p>====</p>

<p>同样 <code class="highlighter-rouge">UIBarButtonItem</code> 和 <code class="highlighter-rouge">UIControl</code> 也是用了几乎相同的机制，把 <code class="highlighter-rouge">target</code> 设置为 <code class="highlighter-rouge">self</code>，让后在分类的方法中调用指定的 block。</p>

<h4 id="uicontrolwrapper">UIControlWrapper</h4>

<p>稍微有些不同的是 <code class="highlighter-rouge">UIControl</code>。因为 <code class="highlighter-rouge">UIControl</code> 有多种 <code class="highlighter-rouge">UIControlEvents</code>，所以使用另一个类 <code class="highlighter-rouge">BKControlWrapper</code> 来封装 <code class="highlighter-rouge">handler</code> 和 <code class="highlighter-rouge">controlEvents</code></p>

<pre><code class="language-objectivec">@property (nonatomic) UIControlEvents controlEvents;
@property (nonatomic，copy) void (^handler)(id sender);
</code></pre>

<p>其中 <code class="highlighter-rouge">UIControlWrapper</code> 对象以 <code class="highlighter-rouge">{controlEvents，wrapper}</code> 的形式作为 <code class="highlighter-rouge">UIControl</code> 的属性存入字典。</p>

<h3 id="改造-uiview">改造 UIView</h3>

<p>因为在上面已经改造过了 <code class="highlighter-rouge">UIGestureRecognizer</code>，在这里改造 <code class="highlighter-rouge">UIView</code> 就变得很容易了：</p>

<pre><code class="language-objectivec">- (void)bk_whenTouches:(NSUInteger)numberOfTouches tapped:(NSUInteger)numberOfTaps handler:(void (^)(void))block
{
	if (!block) return;

	UITapGestureRecognizer *gesture = [UITapGestureRecognizer bk_recognizerWithHandler:^(UIGestureRecognizer *sender，UIGestureRecognizerState state，CGPoint location) {
		if (state == UIGestureRecognizerStateRecognized) block();
	}];

	gesture.numberOfTouchesRequired = numberOfTouches;
	gesture.numberOfTapsRequired = numberOfTaps;

	[self.gestureRecognizers enumerateObjectsUsingBlock:^(id obj，NSUInteger idx，BOOL *stop) {
		if (![obj isKindOfClass:[UITapGestureRecognizer class]]) return;

		UITapGestureRecognizer *tap = obj;
		BOOL rightTouches = (tap.numberOfTouchesRequired == numberOfTouches);
		BOOL rightTaps = (tap.numberOfTapsRequired == numberOfTaps);
		if (rightTouches &amp;&amp; rightTaps) {
			[gesture requireGestureRecognizerToFail:tap];
		}
	}];

	[self addGestureRecognizer:gesture];
}
</code></pre>

<p><code class="highlighter-rouge">UIView</code> 分类只有这一个核心方法，其它的方法都是向这个方法传入不同的参数，这里需要注意的就是。它会遍历所有的 <code class="highlighter-rouge">gestureRecognizers</code>，然后把对所有有冲突的手势调用 <code class="highlighter-rouge">requireGestureRecognizerToFail:</code> 方法，保证添加的手势能够正常的执行。</p>

<p>由于这篇文章中的内容较多，所以内容分成了两个部分，下一部分介绍的是 BlocksKit 中的最重要的部分动态代理：</p>

<ul>
  <li><a href="http://draveness.me/blockskit-1/">神奇的 BlocksKit（一）</a></li>
  <li><a href="http://draveness.me/blockskit-2/">神奇的 BlocksKit（二）</a></li>
</ul>

<iframe src="http://ghbtns.com/github-btn.html?user=draveness&amp;type=follow&amp;size=large" height="30" width="240" frameborder="0" scrolling="0" style="width:240px; height: 30px;" allowtransparency="true"></iframe>

<p>Blog: <a href="http://draveness.me">Draveness</a></p>


	  ]]></description>
	</item>

	<item>
	  <title>iOS 开发中的重构</title>
	  <link>/reprinted//ios-kai-fa-zhong-de-zhong-gou</link>
	  <author></author>
	  <pubDate>2016-03-10T09:42:11+00:00</pubDate>
	  <guid>/reprinted//ios-kai-fa-zhong-de-zhong-gou</guid>
	  <description><![CDATA[
	     <p>随着一个项目的开发的进行, 项目中代码行数会随着时间的推移, 而逐渐增长. 但是由于一些历史原因, 先人在软件开发的过程中, 没有注意到项目中可以复用的模块以及代码. 这样一个工程中就出现了很多复制粘贴产生的代码, 违反了 <code class="highlighter-rouge">DRY</code> 的原则, 使得项目难以维护.</p>

<h2 id="为什么要重构">为什么要重构</h2>

<p>为什么要重构, 重构其实是一件持续性的工作, 工程师在进行开发的过程中难免会有无法考虑周全的地方, 而目前的很多 iOS, Android 项目其实都是业务驱动的, 而业务和需求的更改导致原来模块的设计不再适用于当前的状况.</p>

<p>而大多数工程师是懒惰的. 因为没有足够的推动力去修改当前模块的设计, 所以通过打补丁的方式实现需求, 最终可能会导致整个项目代码的失控, 陷入焦油坑.</p>

<p>重构, 在我看来就是改变原有的设计, 减少项目中冗余的代码的过程. 重构应该伴随着项目的开发进行, 而不是在整个项目要失控时, 才去做这件事情.</p>

<blockquote>
  <p>早重构, 及时重构</p>
</blockquote>

<h2 id="如何在-ios-开发中完成项目的重构">如何在 iOS 开发中完成项目的重构</h2>

<p>因为在 iOS 开发中 <code class="highlighter-rouge">viewController</code> 非常不便于测试, 所以绝大多数 iOS 的工程中都是没有单元测试, 同时也是没有单元测试这个意识的, 集成测试什么的就更不必多说了. 如果我们的工程项目是用 Ruby 或者 Python 写的, 那么补齐所有的单元测试是重构之前最好要做额事情, 不过对于后端代码的重构, 我由于没有太多的经验只能说这么多了.</p>

<p>在 iOS 项目中, 既然没有单元测试, 如何能保证重构前后的模块效果完全一样呢. 这是一个非常麻烦的问题, 因为没有各种自动化测试工具或者代码, 我们真的无法保证重构前后的功能 100% 的相同, 只能通过”人肉测试”的方式来检验重构的正确性.</p>

<p>重构一个模块之前我们要首先了解什么样的模块是需要重构的, 我想需要重构的最常见的场景就是<strong>违反了 DRY 原则</strong>.</p>

<blockquote>
  <p>当一个项目中很多代码都是复制粘贴的, 那么这个项目就是有问题的了, 就要考虑复制粘贴的这部分代码是否需要抽象成一个可复用的模块.</p>
</blockquote>

<p>而我遇到的这种情况就是违反了 <code class="highlighter-rouge">DRY</code> 原则, 大量复制粘贴的代码遍布整个工程的每一个角落, 使得整个项目难以维护.</p>

<h3 id="设计模块">设计模块</h3>

<p>在重构之前我们不仅要熟悉需要重构的这部分代码的业务逻辑, 而且更有对于重构后的模块有着什么样的功能有着清晰而且明确的定义.</p>

<h3 id="分步重构">分步重构</h3>

<p>如果需要重构的模块过于庞大, 你可以通过重构后的代码, 一部分一部分的代替原有的代码, 并删除掉废弃的功能和逻辑.</p>

<p>有的模块可能同时包含 <code class="highlighter-rouge">UI</code> 和逻辑, 那么我们可以选择先重构其中的 <code class="highlighter-rouge">UI</code> 部分代码, 将 <code class="highlighter-rouge">UI</code> 从原有的模块中剥离出来, 改变原有的设计. 再删除原有模块中的代码.</p>

<h2 id="总结">总结</h2>

<p>重构其实是一个非常庞大的话题, 如果没有亲自重构一个模块和项目很难去理解如何去重构一个项目和重构的作用.</p>

<p>往往有的人会想重写整个项目的代码, 然而在大多数情况下, 原有的逻辑可能由于历史原因已经不知道该如何重写, 而且目前的项目代码并不是完全不可用. 重写项目相对于重构也往往更加容易, 但是需要的周期确实太长, 所以说是要重写还是重构是一个需要权衡的问题.</p>

<iframe src="http://ghbtns.com/github-btn.html?user=draveness&amp;type=follow&amp;size=large" height="30" width="240" frameborder="0" scrolling="0" style="width:240px; height: 30px;" allowtransparency="true"></iframe>

<p>Blog: <a href="http://draveness.me">draveness.me</a></p>


	  ]]></description>
	</item>


</channel>
</rss>
