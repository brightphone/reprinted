<!DOCTYPE html>
<html>
<head>
    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Page Meta -->
    <title>iOS 源代码分析----SDWebImage</title>
    <meta name="description" content="" />

    <!-- Mobile Meta -->
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- Brand icon -->
    <link rel="shortcut icon" href="/reprinted/assets/images/favicon.ico" >

    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/reprinted/assets/css/screen.css" />
    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400" />
    <link rel="stylesheet" type="text/css" href="/reprinted/assets/css/syntax.css" />

    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/styles/default.min.css">
    <style>.hljs { background: none; }</style>

    <!-- Ghost outputs important style and meta data with this tag -->
        <link rel="canonical" href="/reprinted//ios-yuan-dai-ma-jie-xi-sdwebimage" />
    <meta name="referrer" content="origin" />
    <link rel="next" href="/reprinted/page2/" />

    <meta property="og:site_name" content="" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="iOS 源代码分析----SDWebImage" />
    <meta property="og:description" content="" />
    <meta property="og:url" content="/reprinted//ios-yuan-dai-ma-jie-xi-sdwebimage" />
    <meta property="og:image" content="/reprinted/assets/images/cover2.jpg" />

    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="iOS 源代码分析----SDWebImage" />
    <meta name="twitter:description" content="" />
    <meta name="twitter:url" content="/reprinted//ios-yuan-dai-ma-jie-xi-sdwebimage" />
    <meta name="twitter:image:src" content="/reprinted/assets/images/cover2.jpg" />

    <script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "Website",
    "publisher": "",
    "name": "iOS 源代码分析----SDWebImage",
    "url": "/reprinted//ios-yuan-dai-ma-jie-xi-sdwebimage",
    "image": "/reprinted/assets/images/cover2.jpg",
    "description": ""
}
    </script>

    <meta name="generator" content="Jekyll 3.0.0" />
    <link rel="alternate" type="application/rss+xml" title="" href="/reprinted/feed.xml" />


</head>
<body class="home-template nav-closed">

    <!-- The blog navigation links -->
    <div class="nav">
    <h3 class="nav-title">Menu</h3>
    <a href="#" class="nav-close">
        <span class="hidden">Close</span>
    </a>
    <ul>
        <li class="nav-home " role="presentation"><a href="/reprinted/">Home</a></li>
        <li class="nav-about " role="presentation"><a href="/reprinted/about">About</a></li>
        <li class="nav-ios  nav-current" role="presentation"><a href="/reprinted/tag/ios">iOS</a></li>
        <li class="nav-objective-c " role="presentation"><a href="/reprinted/tag/objective-c">objective-c</a></li>
        <li class="nav-swift " role="presentation"><a href="/reprinted/tag/swift">Swift</a></li>
        <li class="nav-others " role="presentation"><a href="/reprinted/tag/others">others</a></li>
    </ul>
    <a class="subscribe-button icon-feed" href="/reprinted/feed.xml">Subscribe</a>
</div>
<span class="nav-cover"></span>


    <div class="site-wrapper">

        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- default -->

<!-- The comment above "< default" means - insert everything in this file into -->
    <!-- the [body] of the default.hbs template, which contains our header/footer. -->

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<header class="main-header post-head " style="background-image: url(/reprinted/assets/images/cover2.jpg) ">
    <nav class="main-nav  overlay  clearfix">
        <a class="blog-logo" href="/reprinted/"><img src="/reprinted/assets/images/ghost.png" alt="Blog Logo" /></a>
        
            <a class="menu-button icon-menu" href="#"><span class="word">Menu</span></a>
        
    </nav>
</header>

<main class="content" role="main">

    <article class="post tag-fiction">

        <header class="post-header">
            <h1 class="post-title">iOS 源代码分析----SDWebImage</h1>
            <section class="post-meta">
            <!-- <a href='/reprinted/'></a> -->

            
                
                    <a href='/reprinted/author/Draveness'>Draveness</a>
                
            
            <time class="post-date" datetime="2015-04-12">12 Apr 2015</time>
                <!-- [[tags prefix=" on "]] -->
                
                on
                
                    
                       <a href='/reprinted/tag/iOS'>iOS</a>,
                    
                
                    
                       <a href='/reprinted/tag/OSS'>OSS</a>
                    
                
                
            </section>
        </header>

        <section class="post-content">

            <p>世人都说阅读源代码对于功力的提升是十分显著的, 但是很多的著名开源框架源代码动辄上万行, 复杂度实在太高, 在暑假的时候我曾经试图读一些开源框架的源代码, 比如说 <code class="highlighter-rouge">AFNetworking</code>, <code class="highlighter-rouge">SDWebImage</code>, <code class="highlighter-rouge">ReactiveCocoa</code> 但是由于当时比较浮躁, 实在没法静下心来看, 而且有一些急功近利, 所以面对宝藏实在无力挖掘.</p>

<p>而最近, 由于时间比较充裕, 也终于能静下心来一段一段分析这些著名项目的源代码, 也准备开始写一些关于 iOS 源代码分析的 post.</p>

<p>第一篇文章为什么选择 <code class="highlighter-rouge">SDWebImage</code>, 原因其实我也忘了…. :(</p>

<p>##简洁的接口</p>

<p>首先来介绍一下这个 <a href="https://github.com/rs/SDWebImage">SDWebImage</a> 这个著名开源框架吧, 这个开源框架的主要作用就是:</p>

<blockquote>
  <p>Asynchronous image downloader with cache support with an UIImageView category.</p>
</blockquote>

<p>一个异步下载图片并且支持缓存的 <code class="highlighter-rouge">UIImageView</code> 分类.</p>

<p>就这么直译过来相信各位也能理解, 框架中最最常用的方法其实就是这个:</p>

<pre><code class="language-objectivec">[self.imageView sd_setImageWithURL:[NSURL URLWithString:@"url"]
                  placeholderImage:[UIImage imageNamed:@"placeholder.png"]];
</code></pre>

<p>当然这个框架中还有 <code class="highlighter-rouge">UIButton</code> 的分类, 可以给 <code class="highlighter-rouge">UIButton</code> 异步加载图片, 不过这个并没有 <code class="highlighter-rouge">UIImageView</code> 分类中的这个方法常用.</p>

<p>这个框架的设计还是极其的优雅和简洁, 主要的功能就是这么一行代码, 而其中复杂的实现细节全部隐藏在这行代码之后, 正应了那句话:</p>

<blockquote>
  <p>把简洁留给别人, 把复杂留给自己.</p>
</blockquote>

<p>我们已经看到了这个框架简洁的接口, 接下来我们看一下 <code class="highlighter-rouge">SDWebImage</code> 是用什么样的方式优雅地实现异步加载图片和缓存的功能呢?</p>

<p>##复杂的实现</p>

<p>其实复杂只是相对于简洁而言的, 并不是说 <code class="highlighter-rouge">SDWebImage</code> 的实现就很糟糕, 相反, 它的实现还是非常 <code class="highlighter-rouge">amazing</code> 的, 在这里我们会忽略很多的实现细节, 并不会对每一行源代码逐一解读.</p>

<p>首先, 我们从一个很高的层次来看一下这个框架是如何组织的.</p>

<p><img src="/content/images/2015/04/Untitled-2.png" alt="" /></p>

<p>这张图片已经将这个框架是如何组织的基本展示了出来, <code class="highlighter-rouge">UIImageView+WebCache</code> 和 <code class="highlighter-rouge">UIButton+WebCache</code> 直接为表层的 <code class="highlighter-rouge">UIKit</code> 框架提供接口, 而 <code class="highlighter-rouge">SDWebImageManger</code> 负责处理和协调 <code class="highlighter-rouge">SDWebImageDownloader</code> 和 <code class="highlighter-rouge">SDWebImageCache</code>. 并与 <code class="highlighter-rouge">UIKit</code> 层进行交互, 而底层的一些类为更高层级的抽象提供支持.</p>

<p>###UIImageView+WebCache</p>

<p>接下来我们就以 <code class="highlighter-rouge">UIImageView+WebCache</code> 中的</p>

<pre><code class="language-objectivec">- (void)sd_setImageWithURL:(NSURL *)url
          placeholderImage:(UIImage *)placeholder;
</code></pre>

<p>这一方法为入口研究一下 <code class="highlighter-rouge">SDWebImage</code> 是怎样工作的. 我们打开上面这段方法的实现代码 <a href="https://github.com/rs/SDWebImage/blob/master/SDWebImage/UIImageView%2BWebCache.m">UIImageView+WebCache.m</a></p>

<p>当然你也可以 <code class="highlighter-rouge">git clone git@github.com:rs/SDWebImage.git</code> 到本地来查看.</p>

<pre><code class="language-objectivec">- (void)sd_setImageWithURL:(NSURL *)url
          placeholderImage:(UIImage *)placeholder {
    [self sd_setImageWithURL:url
            placeholderImage:placeholder
                     options:0
                    progress:nil
                   completed:nil];
}
</code></pre>

<p>这段方法唯一的作用就是调用了另一个方法</p>

<pre><code class="language-objectivec">[self sd_setImageWithURL:placeholderImage:options:progress:completed:]
</code></pre>

<p>在这个文件中, 你会看到很多的 <code class="highlighter-rouge">sd_setImageWithURL......</code> 方法, 它们最终都会调用上面这个方法, 只是根据需要传入不同的参数, 这在很多的开源项目中乃至我们平时写的项目中都是很常见的. 而这个方法也是 <code class="highlighter-rouge">UIImageView+WebCache</code> 中的核心方法.</p>

<p>这里就不再复制出这个方法的全部实现了.</p>

<p>####操作的管理</p>

<p>这是这个方法的第一行代码:</p>

<pre><code class="language-objectivec">// UIImageView+WebCache
// sd_setImageWithURL:placeholderImage:options:progress:completed: #1

[self sd_cancelCurrentImageLoad];
</code></pre>

<p>这行看似简单的代码最开始是被我忽略的, 我后来才发现蕴藏在这行代码之后的思想, 也就是 <code class="highlighter-rouge">SDWebImage</code> 管理操作的办法.</p>

<p>框架中的所有操作实际上都是通过一个 <code class="highlighter-rouge">operationDictionary</code> 来管理, 而这个字典实际上是<strong>动态</strong>的添加到 <code class="highlighter-rouge">UIView</code> 上的一个属性, 至于为什么添加到 <code class="highlighter-rouge">UIView</code> 上, 主要是因为这个  <code class="highlighter-rouge">operationDictionary</code> 需要在 <code class="highlighter-rouge">UIButton</code> 和 <code class="highlighter-rouge">UIImageView</code> 上重用, 所以需要添加到它们的根类上.</p>

<p>这行代码是要保证没有当前正在进行的异步下载操作, 不会与即将进行的操作发生冲突, 它会调用:</p>

<pre><code class="language-objectivec">// UIImageView+WebCache
// sd_cancelCurrentImageLoad #1

[self sd_cancelImageLoadOperationWithKey:@"UIImageViewImageLoad"]
</code></pre>

<p>而这个方法会使当前 <code class="highlighter-rouge">UIImageView</code> 中的所有操作都被 <code class="highlighter-rouge">cancel</code>. 不会影响之后进行的下载操作.</p>

<hr />

<p>####占位图的实现</p>

<pre><code class="language-objectivec">// UIImageView+WebCache
// sd_setImageWithURL:placeholderImage:options:progress:completed: #4

if (!(options &amp; SDWebImageDelayPlaceholder)) {
    self.image = placeholder;
}
</code></pre>

<p>如果传入的 <code class="highlighter-rouge">options</code> 中没有 <code class="highlighter-rouge">SDWebImageDelayPlaceholder</code>(默认情况下 <code class="highlighter-rouge">options == 0</code>), 那么就会为 <code class="highlighter-rouge">UIImageView</code> 添加一个临时的 <code class="highlighter-rouge">image</code>, 也就是占位图.</p>

<hr />

<p>####获取图片</p>

<pre><code class="language-objectivec">// UIImageView+WebCache
// sd_setImageWithURL:placeholderImage:options:progress:completed: #8

if (url)
</code></pre>

<p>接下来会检测传入的 <code class="highlighter-rouge">url</code> 是否非空, 如果非空那么一个全局的 <code class="highlighter-rouge">SDWebImageManager</code> 就会调用以下的方法获取图片:</p>

<pre><code class="language-objectivec">[SDWebImageManager.sharedManager downloadImageWithURL:options:progress:completed:]
</code></pre>

<p>下载完成后会调用 <code class="highlighter-rouge">(SDWebImageCompletionWithFinishedBlock)completedBlock</code> 为 <code class="highlighter-rouge">UIImageView.image</code> 赋值, 添加上最终所需要的图片.</p>

<pre><code class="language-objectivec">// UIImageView+WebCache
// sd_setImageWithURL:placeholderImage:options:progress:completed: #10

dispatch_main_sync_safe(^{
    if (!wself) return;
    if (image) {
        wself.image = image;
        [wself setNeedsLayout];
    } else {
        if ((options &amp; SDWebImageDelayPlaceholder)) {
            wself.image = placeholder;
            [wself setNeedsLayout];
        }
    }
    if (completedBlock &amp;&amp; finished) {
        completedBlock(image, error, cacheType, url);
    }
});
</code></pre>

<hr />

<p>####dispatch_main_sync_safe 宏定义</p>

<p>上述代码中的 <code class="highlighter-rouge">dispatch_main_sync_safe</code> 是一个宏定义, 点进去一看发现宏是这样定义的</p>

<pre><code class="language-objectivec">#define dispatch_main_sync_safe(block)\
    if ([NSThread isMainThread]) {\
        block();\
    } else {\
        dispatch_sync(dispatch_get_main_queue(), block);\
    }
</code></pre>

<p>相信这个宏的名字已经讲他的作用解释的很清楚了: 因为<strong>图像的绘制只能在主线程完成</strong>, 所以, <code class="highlighter-rouge">dispatch_main_sync_safe</code> 就是为了保证 <code class="highlighter-rouge">block</code> 能在主线程中执行.</p>

<hr />

<p>而最后, 在 <code class="highlighter-rouge">[SDWebImageManager.sharedManager downloadImageWithURL:options:progress:completed:]</code> 返回 <code class="highlighter-rouge">operation</code> 的<strong>同时</strong>, 也会向 <code class="highlighter-rouge">operationDictionary</code> 中添加一个键值对, 来表示操作的正在进行:</p>

<pre><code class="language-objectivec">// UIImageView+WebCache
// sd_setImageWithURL:placeholderImage:options:progress:completed: #28

[self sd_setImageLoadOperation:operation forKey:@"UIImageViewImageLoad"];
</code></pre>

<p>它将 <code class="highlighter-rouge">opertion</code> 存储到 <code class="highlighter-rouge">operationDictionary</code> 中方便以后的 <code class="highlighter-rouge">cancel</code>.</p>

<p>到此为止我们已经对 <code class="highlighter-rouge">SDWebImage</code> 框架中的这一方法分析完了, 接下来我们将要分析 <code class="highlighter-rouge">SDWebImageManager</code> 中的方法</p>

<pre><code class="language-objectivec">[SDWebImageManager.sharedManager downloadImageWithURL:options:progress:completed:]
</code></pre>

<p>###SDWebImageManager</p>

<p>在 <a href="https://github.com/rs/SDWebImage/blob/master/SDWebImage/SDWebImageManager.h">SDWebImageManager.h</a> 中你可以看到关于 <code class="highlighter-rouge">SDWebImageManager</code> 的描述:</p>

<blockquote>
  <p>The SDWebImageManager is the class behind the UIImageView+WebCache category and likes. It ties the asynchronous downloader (SDWebImageDownloader) with the image cache store (SDImageCache). You can use this class directly to benefit from web image downloading with caching in another context than a UIView.</p>
</blockquote>

<p>这个类就是隐藏在 <code class="highlighter-rouge">UIImageView+WebCache</code> 背后, 用于处理异步下载和图片缓存的类, 当然你也可以直接使用 <code class="highlighter-rouge">SDWebImageManager</code> 的上述方法 <code class="highlighter-rouge">downloadImageWithURL:options:progress:completed:</code> 来直接下载图片.</p>

<p>可以看到, 这个类的主要作用就是为 <code class="highlighter-rouge">UIImageView+WebCache</code> 和 <code class="highlighter-rouge">SDWebImageDownloader, SDImageCache</code> 之间构建一个桥梁, 使它们能够更好的协同工作, 我们在这里分析这个核心方法的源代码, 它是如何协调异步下载和图片缓存的.</p>

<pre><code class="language-objectivec">// SDWebImageManager
// downloadImageWithURL:options:progress:completed: #6

if ([url isKindOfClass:NSString.class]) {
    url = [NSURL URLWithString:(NSString *)url];
}

if (![url isKindOfClass:NSURL.class]) {
    url = nil;
}
</code></pre>

<p>这块代码的功能是确定 <code class="highlighter-rouge">url</code> 是否被正确传入, 如果传入参数的是 <code class="highlighter-rouge">NSString</code> 类型就会被转换为 <code class="highlighter-rouge">NSURL</code>. 如果转换失败, 那么 <code class="highlighter-rouge">url</code> 会被赋值为空, 这个下载的操作就会出错.</p>

<hr />

<p>####SDWebImageCombinedOperation</p>

<p>当 <code class="highlighter-rouge">url</code> 被正确传入之后, 会实例一个非常奇怪的 “operation”, 它其实是一个遵循 <code class="highlighter-rouge">SDWebImageOperation</code> 协议的 <code class="highlighter-rouge">NSObject</code> 的子类. 而这个协议也非常的简单:</p>

<pre><code class="language-objectivec">@protocol SDWebImageOperation &lt;NSObject&gt;

- (void)cancel;

@end
</code></pre>

<p><strong>这里仅仅是将这个 <code class="highlighter-rouge">SDWebImageOperation</code> 类包装成一个看着像 <code class="highlighter-rouge">NSOperation</code> 其实并不是 <code class="highlighter-rouge">NSOperation</code> 的类, 而这个类唯一与 <code class="highlighter-rouge">NSOperation</code> 的相同之处就是它们都可以响应 <code class="highlighter-rouge">cancel</code> 方法.</strong> (不知道这句看似像绕口令的话, 你看懂没有, 如果没看懂..请多读几遍).</p>

<p>而调用这个类的存在实际是为了使代码更加的简洁, 因为调用这个类的 <code class="highlighter-rouge">cancel</code> 方法, 会使得它持有的两个 <code class="highlighter-rouge">operation</code> 都被 <code class="highlighter-rouge">cancel</code>.</p>

<pre><code class="language-objectivec">// SDWebImageCombinedOperation
// cancel #1

- (void)cancel {
    self.cancelled = YES;
    if (self.cacheOperation) {
        [self.cacheOperation cancel];
        self.cacheOperation = nil;
    }
    if (self.cancelBlock) {
        self.cancelBlock();
        _cancelBlock = nil;
    }
}
</code></pre>

<p>而这个类, 应该是为了实现更简洁的 <code class="highlighter-rouge">cancel</code> 操作而设计出来的.</p>

<hr />

<p>既然我们获取了 <code class="highlighter-rouge">url</code>, 再通过 <code class="highlighter-rouge">url</code> 获取对应的 <code class="highlighter-rouge">key</code></p>

<pre><code class="language-objectivec">NSString *key = [self cacheKeyForURL:url];
</code></pre>

<p>下一步是使用 <code class="highlighter-rouge">key</code> 在缓存中查找以前是否下载过相同的图片.</p>

<pre><code class="language-objectivec">operation.cacheOperation = [self.imageCache
		queryDiskCacheForKey:key
        			    done:^(UIImage *image, SDImageCacheType cacheType) { ... }];
</code></pre>

<p>这里调用 <code class="highlighter-rouge">SDImageCache</code> 的实例方法 <code class="highlighter-rouge">queryDiskCacheForKey:done:</code> 来尝试在缓存中获取图片的数据. 而这个方法返回的就是货真价实的 <code class="highlighter-rouge">NSOperation</code>.</p>

<p>如果我们在缓存中查找到了对应的图片, 那么我们直接调用 <code class="highlighter-rouge">completedBlock</code> 回调块结束这一次的图片下载操作.</p>

<pre><code class="language-objectivec">// SDWebImageManager
// downloadImageWithURL:options:progress:completed: #47

dispatch_main_sync_safe(^{
    completedBlock(image, nil, cacheType, YES, url);
});
</code></pre>

<p>如果我们没有找到图片, 那么就会调用 <code class="highlighter-rouge">SDWebImageDownloader</code> 的实例方法:</p>

<pre><code class="language-objectivec">id &lt;SDWebImageOperation&gt; subOperation =
  [self.imageDownloader downloadImageWithURL:url
                                     options:downloaderOptions
                                    progress:progressBlock
                                   completed:^(UIImage *downloadedImage, NSData *data, NSError *error, BOOL finished) { ... }];
</code></pre>

<p>如果这个方法返回了正确的 <code class="highlighter-rouge">downloadedImage</code>, 那么我们就会在全局的缓存中存储这个图片的数据:</p>

<pre><code class="language-objectivec">[self.imageCache storeImage:downloadedImage
	   recalculateFromImage:NO
                  imageData:data
                     forKey:key
                     toDisk:cacheOnDisk];
</code></pre>

<p>并调用 <code class="highlighter-rouge">completedBlock</code> 对 <code class="highlighter-rouge">UIImageView</code> 或者 <code class="highlighter-rouge">UIButton</code> 添加图片, 或者进行其它的操作.</p>

<p>最后, 我们将这个 <code class="highlighter-rouge">subOperation</code> 的 <code class="highlighter-rouge">cancel</code> 操作添加到 <code class="highlighter-rouge">operation.cancelBlock</code> 中. 方便操作的取消.</p>

<pre><code class="language-objectivec">operation.cancelBlock = ^{
    [subOperation cancel];
    }
</code></pre>

<p>###SDWebImageCache</p>

<p><a href="https://github.com/rs/SDWebImage/blob/master/SDWebImage/SDImageCache.h">SDWebImageCache.h</a> 这个类在源代码中有这样的注释:</p>

<blockquote>
  <p>SDImageCache maintains a memory cache and an optional disk cache.</p>
</blockquote>

<p>它维护了一个内存缓存和一个可选的磁盘缓存, 我们先来看一下在上一阶段中没有解读的两个方法, 首先是:</p>

<pre><code class="language-objectivec">- (NSOperation *)queryDiskCacheForKey:(NSString *)key
                                 done:(SDWebImageQueryCompletedBlock)doneBlock;
</code></pre>

<p>这个方法的主要功能是异步的查询图片缓存. 因为图片的缓存可能在两个地方, 而该方法首先会在内存中查找是否有图片的缓存.</p>

<pre><code class="language-objectivec">// SDWebImageCache
// queryDiskCacheForKey:done: #9

UIImage *image = [self imageFromMemoryCacheForKey:key];
</code></pre>

<p>这个 <code class="highlighter-rouge">imageFromMemoryCacheForKey</code> 方法会在 <code class="highlighter-rouge">SDWebImageCache</code> 维护的缓存 <code class="highlighter-rouge">memCache</code> 中查找是否有对应的数据, 而 <code class="highlighter-rouge">memCache</code> 就是一个 <code class="highlighter-rouge">NSCache</code>.</p>

<p>如果在内存中并没有找到图片的缓存的话, 就需要在磁盘中寻找了, 这个就比较麻烦了..</p>

<p>在这里会调用一个方法 <code class="highlighter-rouge">diskImageForKey</code> 这个方法的具体实现我在这里就不介绍了, 涉及到很多底层 <code class="highlighter-rouge">Core Foundation</code> 框架的知识, 不过这里文件名字的存储使用 <code class="highlighter-rouge">MD5</code> 处理过后的文件名.</p>

<pre><code class="language-objectivec">// SDImageCache
// cachedFileNameForKey: #6

CC_MD5(str, (CC_LONG)strlen(str), r);
</code></pre>

<p>对于其它的实现细节也就不多说了…</p>

<p>如果在磁盘中查找到对应的图片, 我们会将它复制到内存中, 以便下次的使用.</p>

<pre><code class="language-objectivec">// SDImageCache
// queryDiskCacheForKey:done: #24

UIImage *diskImage = [self diskImageForKey:key];
if (diskImage) {
    CGFloat cost = diskImage.size.height * diskImage.size.width * diskImage.scale;
    [self.memCache setObject:diskImage forKey:key cost:cost];
}
</code></pre>

<p>这些就是 <code class="highlighter-rouge">SDImageCache</code> 的核心内容了, 而接下来将介绍如果缓存没有命中, 图片是如何被下载的.</p>

<p>###SDWebImageDownloader</p>

<p>按照之前的惯例, 我们先来看一下 <a href="https://github.com/rs/SDWebImage/blob/master/SDWebImage/SDWebImageDownloader.h">SDWebImageDownloader.h</a> 中对这个类的描述.</p>

<blockquote>
  <p>Asynchronous downloader dedicated and optimized for image loading.</p>
</blockquote>

<p>专用的并且优化的图片异步下载器.</p>

<p>这个类的核心功能就是下载图片, 而核心方法就是上面提到的:</p>

<pre><code class="language-objectivec">- (id &lt;SDWebImageOperation&gt;)downloadImageWithURL:(NSURL *)url
        options:(SDWebImageDownloaderOptions)options
       progress:(SDWebImageDownloaderProgressBlock)progressBlock
      completed:(SDWebImageDownloaderCompletedBlock)completedBlock;
</code></pre>

<p>####回调</p>

<p>这个方法直接调用了另一个关键的方法:</p>

<pre><code class="language-objectivec">- (void)addProgressCallback:(SDWebImageDownloaderProgressBlock)progressBlock
          andCompletedBlock:(SDWebImageDownloaderCompletedBlock)completedBlock
                     forURL:(NSURL *)url
             createCallback:(SDWebImageNoParamsBlock)createCallback
</code></pre>

<p>它为这个下载的操作添加回调的块, 在下载进行时, 或者在下载结束时执行一些操作, 先来阅读一下这个方法的源代码:</p>

<pre><code class="language-objectivec">// SDWebImageDownloader
// addProgressCallback:andCompletedBlock:forURL:createCallback: #10

BOOL first = NO;
if (!self.URLCallbacks[url]) {
    self.URLCallbacks[url] = [NSMutableArray new];
    first = YES;
}

// Handle single download of simultaneous download request for the same URL
NSMutableArray *callbacksForURL = self.URLCallbacks[url];
NSMutableDictionary *callbacks = [NSMutableDictionary new];
if (progressBlock) callbacks[kProgressCallbackKey] = [progressBlock copy];
if (completedBlock) callbacks[kCompletedCallbackKey] = [completedBlock copy];
[callbacksForURL addObject:callbacks];
self.URLCallbacks[url] = callbacksForURL;

if (first) {
    createCallback();
}
</code></pre>

<p>方法会先查看这个 <code class="highlighter-rouge">url</code> 是否有对应的 <code class="highlighter-rouge">callback</code>, 使用的是 <code class="highlighter-rouge">downloader</code> 持有的一个字典 <code class="highlighter-rouge">URLCallbacks</code>.</p>

<p>如果是第一次添加回调的话, 就会执行 <code class="highlighter-rouge">first = YES</code>, 这个赋值非常的关键, 因为 <code class="highlighter-rouge">first</code> 不为 <code class="highlighter-rouge">YES</code> 那么 HTTP 请求就不会被初始化, 图片也无法被获取.</p>

<p>然后, 在这个方法中会重新修正在 <code class="highlighter-rouge">URLCallbacks</code> 中存储的回调块.</p>

<pre><code class="language-objectivec">NSMutableArray *callbacksForURL = self.URLCallbacks[url];
NSMutableDictionary *callbacks = [NSMutableDictionary new];
if (progressBlock) callbacks[kProgressCallbackKey] = [progressBlock copy];
if (completedBlock) callbacks[kCompletedCallbackKey] = [completedBlock copy];
[callbacksForURL addObject:callbacks];
self.URLCallbacks[url] = callbacksForURL;
</code></pre>

<hr />

<p>如果是第一次添加回调块, 那么就会直接运行这个 <code class="highlighter-rouge">createCallback</code> 这个 block, 而这个 block, 就是我们在前一个方法 <code class="highlighter-rouge">downloadImageWithURL:options:progress:completed:</code> 中传入的回调块.</p>

<pre><code class="language-objectivec">// SDWebImageDownloader
// downloadImageWithURL:options:progress:completed: #4

[self addProgressCallback:progressBlock andCompletedBlock:completedBlock forURL:url createCallback:^{ ... }];
</code></pre>

<p>我们下面来分析这个传入的无参数的代码. 首先这段代码初始化了一个 <code class="highlighter-rouge">NSMutableURLRequest</code>:</p>

<pre><code class="language-objectivec">// SDWebImageDownloader
// downloadImageWithURL:options:progress:completed: #11

NSMutableURLRequest *request = [[NSMutableURLRequest alloc]
		initWithURL:url
        cachePolicy:...
    timeoutInterval:timeoutInterval];
</code></pre>

<p>这个 <code class="highlighter-rouge">request</code> 就用于在之后发送 <code class="highlighter-rouge">HTTP</code> 请求.</p>

<p>在初始化了这个 <code class="highlighter-rouge">request</code> 之后, 又初始化了一个 <code class="highlighter-rouge">SDWebImageDownloaderOperation</code> 的实例, 这个实例, 就是用于请求网络资源的操作. 它是一个 <code class="highlighter-rouge">NSOperation</code> 的子类,</p>

<pre><code class="language-objectivec">// SDWebImageDownloader
// downloadImageWithURL:options:progress:completed: #20

operation = [[SDWebImageDownloaderOperation alloc]
		initWithRequest:request
                options:options
               progress:...
              completed:...
              cancelled:...}];
</code></pre>

<p>但是在初始化之后, 这个操作并不会开始(<code class="highlighter-rouge">NSOperation</code> 实例只有在调用 <code class="highlighter-rouge">start</code> 方法或者加入 <code class="highlighter-rouge">NSOperationQueue</code> 才会执行), 我们需要将这个操作加入到一个 <code class="highlighter-rouge">NSOperationQueue</code> 中.</p>

<pre><code class="language-objectivec">// SDWebImageDownloader
// downloadImageWithURL:options:progress:completed: #59

[wself.downloadQueue addOperation:operation];
</code></pre>

<p>只有将它加入到这个下载队列中, 这个操作才会执行.</p>

<p>###SDWebImageDownloaderOperation</p>

<p>这个类就是处理 HTTP 请求, URL 连接的类, 当这个类的实例被加入队列之后, <code class="highlighter-rouge">start</code> 方法就会被调用, 而 <code class="highlighter-rouge">start</code> 方法首先就会产生一个 <code class="highlighter-rouge">NSURLConnection</code>.</p>

<pre><code class="language-objectivec">// SDWebImageDownloaderOperation
// start #1

@synchronized (self) {
    if (self.isCancelled) {
        self.finished = YES;
        [self reset];
        return;
    }
    self.executing = YES;
    self.connection = [[NSURLConnection alloc] initWithRequest:self.request delegate:self startImmediately:NO];
    self.thread = [NSThread currentThread];
}
</code></pre>

<p>而接下来这个 <code class="highlighter-rouge">connection</code> 就会开始运行:</p>

<pre><code class="language-objectivec">// SDWebImageDownloaderOperation
// start #29

[self.connection start];
</code></pre>

<p>它会发出一个 <code class="highlighter-rouge">SDWebImageDownloadStartNotification</code> 通知</p>

<pre><code class="language-objectivec">// SDWebImageDownloaderOperation
// start #35

[[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadStartNotification object:self];
</code></pre>

<p>####代理</p>

<p>在 <code class="highlighter-rouge">start</code> 方法调用之后, 就是 <code class="highlighter-rouge">NSURLConnectionDataDelegate</code> 中代理方法的调用.</p>

<pre><code class="language-objectivec">- (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response;
- (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response;
- (void)connectionDidFinishLoading:(NSURLConnection *)aConnection;
</code></pre>

<p>在这三个代理方法中的前两个会不停回调 <code class="highlighter-rouge">progressBlock</code> 来提示下载的进度.</p>

<p>而最后一个代理方法会在图片下载完成之后调用 <code class="highlighter-rouge">completionBlock</code> 来完成最后 <code class="highlighter-rouge">UIImageView.image</code> 的更新.</p>

<p>而这里调用的 <code class="highlighter-rouge">progressBlock</code> <code class="highlighter-rouge">completionBlock</code> <code class="highlighter-rouge">cancelBlock</code> 都是在之前存储在 <code class="highlighter-rouge">URLCallbacks</code> 字典中的.</p>

<hr />

<p>到目前为止, 我们就基本解析了 <code class="highlighter-rouge">SDWebImage</code> 中</p>

<pre><code class="language-objectivec">[self.imageView sd_setImageWithURL:[NSURL URLWithString:@"url"]
                  placeholderImage:[UIImage imageNamed:@"placeholder.png"]];
</code></pre>

<p>这个方法执行的全部过程了.</p>

<p>##流程图</p>

<p>我们使用一个流程图来表示上述方法所执行的全过程.</p>

<p><img src="/content/images/2015/04/Untitled-1.png" alt="" /></p>

<p>这段流程图展示了上述方法调用中大部分重要方法的调用.</p>

<h2 id="sdwebimage-如何为-uiimageview-添加图片面试回答">SDWebImage 如何为 UIImageView 添加图片(面试回答)</h2>

<p>SDWebImage 中为 UIView 提供了一个分类叫做 WebCache, 这个分类中有一个最常用的接口, <code class="highlighter-rouge">sd_setImageWithURL:placeholderImage:</code>, 这个分类同时提供了很多类似的方法, 这些方法最终会调用一个同时具有 <code class="highlighter-rouge">option</code> <code class="highlighter-rouge">progressBlock</code> <code class="highlighter-rouge">completionBlock</code> 的方法, 而在这个类最终被调用的方法首先会检查是否传入了 <code class="highlighter-rouge">placeholderImage</code> 以及对应的参数, 并设置 <code class="highlighter-rouge">placeholderImage</code>.</p>

<p>然后会获取 <code class="highlighter-rouge">SDWebImageManager</code> 中的单例调用一个 <code class="highlighter-rouge">downloadImageWithURL:...</code> 的方法来获取图片, 而这个 manager 获取图片的过程有大体上分为两部分, 它首先会在 <code class="highlighter-rouge">SDWebImageCache</code> 中寻找图片是否有对应的缓存, 它会以 url 作为数据的索引先在内存中寻找是否有对应的缓存, 如果缓存未命中就会在磁盘中利用 MD5 处理过的 key 来继续查询对应的数据, 如果找到了, 就会把磁盘中的缓存备份到内存中.</p>

<p>然而, 假设我们在内存和磁盘缓存中都没有命中, 那么 manager 就会调用它持有的一个 <code class="highlighter-rouge">SDWebImageDownloader</code> 对象的方法 <code class="highlighter-rouge">downloadImageWithURL:...</code> 来下载图片, 这个方法会在执行的过程中调用另一个方法 <code class="highlighter-rouge">addProgressCallback:andCompletedBlock:fotURL:createCallback:</code> 来存储下载过程中和下载完成的回调, 当回调块是第一次添加的时候, 方法会实例化一个 <code class="highlighter-rouge">NSMutableURLRequest</code> 和 <code class="highlighter-rouge">SDWebImageDownloaderOperation</code>, 并将后者加入 downloader 持有的下载队列开始图片的异步下载.</p>

<p>而在图片下载完成之后, 就会在主线程设置 <code class="highlighter-rouge">image</code> 属性, 完成整个图像的异步下载和配置.</p>

<p>##总结</p>

<p><code class="highlighter-rouge">SDWebImage</code> 的图片加载过程其实很符合我们的直觉:</p>

<ul>
  <li>查看缓存
    <ul>
      <li>缓存命中
  	* 返回图片
        <ul>
          <li>更新 <code class="highlighter-rouge">UIImageView</code></li>
        </ul>
      </li>
      <li>缓存未命中
  	* 异步下载图片
        <ul>
          <li>加入缓存</li>
          <li>更新 <code class="highlighter-rouge">UIImageView</code></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>只要有足够的耐心, 阅读这个开源项目的源代码也是没有太多困难的.</p>

<p><code class="highlighter-rouge">SDWebImage</code> 的探索到目前为止差不多结束了, 对于这个框架的学习以及解析确实使我受益匪浅, 我也将在之后继续阅读其它的著名框架的源代码. 在这篇博客之中难免会有错误, 希望各位能够指正~</p>



        </section>

        <footer class="post-footer">

            <!-- Everything inside the #author tags pulls data from the author -->
            <!-- #author-->
            
                
                    
                        <figure class="author-image">
                            <a class="img" href="/reprinted/author/Draveness" style="background-image: url(/reprinted/assets/images/draven.png)"><span class="hidden">Draveness's Picture</span></a>
                        </figure>
                    

                    <section class="author">
                        <h4><a href="/reprinted/author/Draveness">Draveness</a></h4>

                        
                            <p>Read <a href="/reprinted/author/Draveness">more posts</a> by this author.</p>
                        
                        <div class="author-meta">
                            <span class="author-location icon-location"> Beijing, China</span>
                            <span class="author-link icon-link"><a href="https://draveness.me/index"> draveness.me/index</a></span>
                        </div>
                    </section>

                    <!-- /author  -->

                    <section class="share">
                        <h4>Share this post</h4>
                        <a class="icon-twitter" href="http://twitter.com/share?text=iOS 源代码分析----SDWebImage&amp;url=ios-yuan-dai-ma-jie-xi-sdwebimage"
                            onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
                            <span class="hidden">Twitter</span>
                        </a>
                        <a class="icon-facebook" href="https://www.facebook.com/sharer/sharer.php?u=ios-yuan-dai-ma-jie-xi-sdwebimage"
                            onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
                            <span class="hidden">Facebook</span>
                        </a>
                        <a class="icon-google-plus" href="https://plus.google.com/share?url=ios-yuan-dai-ma-jie-xi-sdwebimage"
                           onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
                            <span class="hidden">Google+</span>
                        </a>
                    </section>
                
            
            <!-- Add Disqus Comments -->
            

        </footer>

    </article>

</main>
<aside class="read-next">

    <!-- [[! next_post ]] -->
    
        <a class="read-next-story " style="background-image: url(/reprinted/assets/images/cover2.jpg)" href="/reprinted/ios-swizillingzeng-jia-gou-zi-fang-fa">
            <section class="post">
                <h2>iOS 为 UIKit 属性增加钩子方法</h2>
                <p>最近在做一个用于实现夜间模式的开源框架, 需监听 UIKit 中的属性, 而这个监听的通知者就是 UIKit **实例**本身, 当我最开始想要做的时候, 我感觉这个东西实在太简单了, 不过之后... ##KVO 我想到的第一个解决方案是使用 `KVO` 来解决. `KVO`...</p>
            </section>
        </a>
    
    <!-- [[! /next_post ]] -->
    <!-- [[! prev_post ]] -->
    
    <!-- [[! /prev_post ]] -->
</aside>

<!-- /post -->


        <!-- The tiny footer at the very bottom -->
        <footer class="site-footer clearfix">
          <section class="copyright"><a href="/reprinted/"></a> &copy; 2018</section>
          <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> using <a href="https://github.com/jekyller/jasper">Jasper</a></section>
        </footer>
    </div>
    <!-- highlight.js -->
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <!-- jQuery needs to come before `` so that jQuery can be used in code injection -->
    <script type="text/javascript" src="//code.jquery.com/jquery-1.12.0.min.js"></script>
    <!-- Ghost outputs important scripts and data with this tag -->
    <!--  -->
    <!-- Add Google Analytics  -->
        <!-- Google Analytics Tracking code -->
     <script>
	    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	    ga('create', 'UA-69281367-1', 'auto');
	    ga('send', 'pageview');

     </script>
    <!-- Fitvids makes video embeds responsive and awesome -->
    <script type="text/javascript" src="/reprinted/assets/js/jquery.fitvids.js"></script>
    <!-- The main JavaScript file for Casper -->
    <script type="text/javascript" src="/reprinted/assets/js/index.js"></script>

</body>
</html>
