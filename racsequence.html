<!DOCTYPE html>
<html>
<head>
    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Page Meta -->
    <title>Pull-Driven 的数据流 RACSequence</title>
    <meta name="description" content="" />

    <!-- Mobile Meta -->
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- Brand icon -->
    <link rel="shortcut icon" href="/reprinted/assets/images/favicon.ico" >

    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/reprinted/assets/css/screen.css" />
    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400" />
    <link rel="stylesheet" type="text/css" href="/reprinted/assets/css/syntax.css" />

    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/styles/default.min.css">
    <style>.hljs { background: none; }</style>

    <!-- Ghost outputs important style and meta data with this tag -->
        <link rel="canonical" href="/reprinted//racsequence" />
    <meta name="referrer" content="origin" />
    <link rel="next" href="/reprinted/page2/" />

    <meta property="og:site_name" content="" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Pull-Driven 的数据流 RACSequence" />
    <meta property="og:description" content="" />
    <meta property="og:url" content="/reprinted//racsequence" />
    <meta property="og:image" content="/reprinted/assets/images/cover2.jpg" />

    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Pull-Driven 的数据流 RACSequence" />
    <meta name="twitter:description" content="" />
    <meta name="twitter:url" content="/reprinted//racsequence" />
    <meta name="twitter:image:src" content="/reprinted/assets/images/cover2.jpg" />

    <script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "Website",
    "publisher": "",
    "name": "Pull-Driven 的数据流 RACSequence",
    "url": "/reprinted//racsequence",
    "image": "/reprinted/assets/images/cover2.jpg",
    "description": ""
}
    </script>

    <meta name="generator" content="Jekyll 3.0.0" />
    <link rel="alternate" type="application/rss+xml" title="" href="/reprinted/feed.xml" />


</head>
<body class="home-template nav-closed">

    <!-- The blog navigation links -->
    <div class="nav">
    <h3 class="nav-title">Menu</h3>
    <a href="#" class="nav-close">
        <span class="hidden">Close</span>
    </a>
    <ul>
        <li class="nav-home " role="presentation"><a href="/reprinted/">Home</a></li>
        <li class="nav-about " role="presentation"><a href="/reprinted/about">About</a></li>
        <li class="nav-ios " role="presentation"><a href="/reprinted/tag/ios">iOS</a></li>
        <li class="nav-objective-c " role="presentation"><a href="/reprinted/tag/objective-c">objective-c</a></li>
        <li class="nav-swift " role="presentation"><a href="/reprinted/tag/swift">Swift</a></li>
        <li class="nav-others " role="presentation"><a href="/reprinted/tag/others">others</a></li>
    </ul>
    <a class="subscribe-button icon-feed" href="/reprinted/feed.xml">Subscribe</a>
</div>
<span class="nav-cover"></span>


    <div class="site-wrapper">

        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- default -->

<!-- The comment above "< default" means - insert everything in this file into -->
    <!-- the [body] of the default.hbs template, which contains our header/footer. -->

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<header class="main-header post-head " style="background-image: url(/reprinted/assets/images/cover2.jpg) ">
    <nav class="main-nav  overlay  clearfix">
        <a class="blog-logo" href="/reprinted/"><img src="/reprinted/assets/images/ghost.png" alt="Blog Logo" /></a>
        
            <a class="menu-button icon-menu" href="#"><span class="word">Menu</span></a>
        
    </nav>
</header>

<main class="content" role="main">

    <article class="post tag-fiction">

        <header class="post-header">
            <h1 class="post-title">Pull-Driven 的数据流 RACSequence</h1>
            <section class="post-meta">
            <!-- <a href='/reprinted/'></a> -->

            
                
                    <a href='/reprinted/author/Draveness'>Draveness</a>
                
            
            <time class="post-date" datetime="2017-02-04">04 Feb 2017</time>
                <!-- [[tags prefix=" on "]] -->
                
                on
                
                    
                       <a href='/reprinted/tag/iOS'>iOS</a>,
                    
                
                    
                       <a href='/reprinted/tag/RAC'>RAC</a>
                    
                
                
            </section>
        </header>

        <section class="post-content">

            <blockquote>
  <p>转自：<a href="https://draveness.me/racsequence">Pull-Driven 的数据流 RACSequence</a></p>
</blockquote>

<p>ReactiveCocoa 在设计上很大程度借鉴了 Reactive Extension 中的概念，可以说 ReactiveCocoa 是 Rx 在 Objective-C 语言中的实现。</p>

<p>在 Rx 中主要的两个概念<em>信号</em>和<em>序列</em>都在 ReactiveCocoa 中有着相对应的组件 <code class="highlighter-rouge">RACSignal</code> 和 <code class="highlighter-rouge">RACSequence</code>，上一篇文章已经对前者有一个简单的介绍，而这篇文章主要会介绍后者，也就是 <code class="highlighter-rouge">RACSequence</code>。</p>

<h2 id="push-driven--pull-driven">Push-Driven &amp; Pull-Driven</h2>

<p>虽然这篇文章主要介绍 <code class="highlighter-rouge">RACSequence</code>，但是在介绍它之前，笔者想先就推驱动（push-driven）和拉驱动（pull-driven）这两个概念做一点简单的说明。</p>

<p><code class="highlighter-rouge">RACSignal</code> 和 <code class="highlighter-rouge">RACSequence</code> 都是 <code class="highlighter-rouge">RACStream</code> 的子类，它们不仅共享了来自父类的很多方法，也都表示数据流。</p>

<p><img src="https://img.draveness.me/2017-02-04-RACSignal - RACSequence.png-1000width" alt="RACSignal - RACSequence" /></p>

<p><code class="highlighter-rouge">RACSignal</code> 和 <code class="highlighter-rouge">RACSequence</code> 最大区别就是：</p>

<ul>
  <li><code class="highlighter-rouge">RACSignal</code> 是推驱动的，也就是在每次信号中的出现新的数据时，所有的订阅者都会自动接受到最新的值；</li>
  <li><code class="highlighter-rouge">RACSequence</code> 作为推驱动的数据流，在改变时并不会通知使用当前序列的对象，只有使用者再次从这个 <code class="highlighter-rouge">RACSequence</code> 对象中获取数据才能更新，它的更新是需要使用者自己拉取的。</li>
</ul>

<p>由于拉驱动在数据改变时，并不会主动推送给『订阅者』，所以往往适用于简化集合类对象等操作，相比于推驱动，它的适应场合较少。</p>

<p><img src="https://img.draveness.me/2017-02-04-Usage for RACSignal - RACSequence Copy.png-1000width" alt="Usage for RACSignal - RACSequence Copy" /></p>

<blockquote>
  <p>图片中的内容来自 <a href="http://nshipster.com/reactivecocoa/">Reactive​Cocoa · NSHipster</a> 中。</p>
</blockquote>

<h2 id="预加载与延迟加载">预加载与延迟加载</h2>

<p>在 <code class="highlighter-rouge">RACSequence</code> 中还涉及到另外一对概念，也就是预加载和延迟加载（也叫懒加载）；如果你之前学习过 Lisp 这门编程语言，那么你一定知道 Lisp 中有两种列表，一种是正常的列表 List，另一种叫做流 Stream，这两者的主要区别就是<strong>流的加载是延迟加载的</strong>，只有在真正使用数据时才会计算数据的内容。</p>

<p><img src="https://img.draveness.me/2017-02-04-List-and-Stream.png-1000width" alt="List-and-Strea" /></p>

<blockquote>
  <p>由于流是懒加载的，这也就是说它可以<strong>表示无穷长度的列表</strong>。</p>
</blockquote>

<p>Stream 由两部分组成，分别是 <code class="highlighter-rouge">head</code> 和 <code class="highlighter-rouge">tail</code>，两者都是在访问时才会计算，在上图前者是一个数字，而后者会是另一个 Stream 或者 <code class="highlighter-rouge">nil</code>。</p>

<pre><code class="language-objectivec">@interface RACSequence&lt;__covariant ValueType&gt; : RACStream &lt;NSCoding, NSCopying, NSFastEnumeration&gt;

@property (nonatomic, strong, readonly, nullable) ValueType head;
@property (nonatomic, strong, readonly, nullable) RACSequence&lt;ValueType&gt; *tail;

@end
</code></pre>

<p><code class="highlighter-rouge">RACSequence</code> 头文件的中定义能够帮助我们更好理解递归的序列以及 <code class="highlighter-rouge">head</code> 和 <code class="highlighter-rouge">tail</code> 的概念，<code class="highlighter-rouge">head</code> 是一个值，<code class="highlighter-rouge">tail</code> 是一个 <code class="highlighter-rouge">RACSequence</code> 对象。</p>

<h2 id="racsequence-简介">RACSequence 简介</h2>

<p>了解了几个比较重要的概念之后，就可以进入正题了，先看一下在 ReactiveCocoa 中，<code class="highlighter-rouge">RACSequence</code> 都有哪些子类：</p>

<p><img src="https://img.draveness.me/2017-02-04-RACSequence - Subclasses.png-1000width" alt="RACSequence - Subclasses" /></p>

<p><code class="highlighter-rouge">RACSequence</code> 总共有九个子类，这篇文章不会覆盖其中所有的内容，只会简单介绍其中的几个；不过，我们先从父类 <code class="highlighter-rouge">RACSequence</code> 开始。</p>

<h3 id="return-和-bind-方法">return 和 bind 方法</h3>

<p>与介绍 <code class="highlighter-rouge">RACSignal</code> 时一样，这里我们先介绍两个 <code class="highlighter-rouge">RACSequence</code> 必须覆写的方法，第一个就是 <code class="highlighter-rouge">+return:</code></p>

<pre><code class="language-objectivec">+ (RACSequence *)return:(id)value {
	return [RACUnarySequence return:value];
}
</code></pre>

<p><code class="highlighter-rouge">+return:</code> 方法用到了 <code class="highlighter-rouge">RACSequence</code> 的子类 <code class="highlighter-rouge">RACUnarySequence</code> 私有类，这个类在外界是不可见的，其实现非常简单，只是将原来的 <code class="highlighter-rouge">value</code> 包装成了一个简单的 <code class="highlighter-rouge">RACUnarySequence</code> 对象：</p>

<pre><code class="language-objectivec">+ (RACUnarySequence *)return:(id)value {
	RACUnarySequence *sequence = [[self alloc] init];
	sequence.head = value;
	return [sequence setNameWithFormat:@"+return: %@", RACDescription(value)];
}
</code></pre>

<p>这样在访问 <code class="highlighter-rouge">head</code> 时可以获取到传入的 <code class="highlighter-rouge">value</code>；在访问 <code class="highlighter-rouge">tail</code> 时只需要返回 <code class="highlighter-rouge">nil</code>：</p>

<pre><code class="language-objectivec">- (RACSequence *)tail {
	return nil;
}
</code></pre>

<p>整个 <code class="highlighter-rouge">RACUnarySequence</code> 也只是对 <code class="highlighter-rouge">value</code> 简单封装成一个 <code class="highlighter-rouge">RACSequence</code> 对象而已：</p>

<p><img src="https://img.draveness.me/2017-02-04-RACUnarySequence.png-1000width" alt="RACUnarySequence" /></p>

<p>相比于 <code class="highlighter-rouge">+return:</code> 方法的简单实现，<code class="highlighter-rouge">-bind:</code> 的实现就复杂多了：</p>

<pre><code class="language-objectivec">- (RACSequence *)bind:(RACSequenceBindBlock (^)(void))block {
	RACSequenceBindBlock bindBlock = block();
	return [[self bind:bindBlock passingThroughValuesFromSequence:nil] setNameWithFormat:@"[%@] -bind:", self.name];
}
</code></pre>

<p>首先是对 <code class="highlighter-rouge">-bind:</code> 方法进行一次转发，将控制权交给 <code class="highlighter-rouge">-bind:passingThroughValuesFromSequence:</code> 方法中：</p>

<pre><code class="language-objectivec">- (RACSequence *)bind:(RACSequenceBindBlock)bindBlock passingThroughValuesFromSequence:(RACSequence *)passthroughSequence {
	__block RACSequence *valuesSeq = self;
	__block RACSequence *current = passthroughSequence;
	__block BOOL stop = NO;

	RACSequence *sequence = [RACDynamicSequence sequenceWithLazyDependency:^ id {
		while (current.head == nil) {
			if (stop) return nil;
			id value = valuesSeq.head;
			if (value == nil) {
				stop = YES;
				return nil;
			}
			current = (id)bindBlock(value, &amp;stop);
			if (current == nil) {
				stop = YES;
				return nil;
			}

			valuesSeq = valuesSeq.tail;
		}
		return nil;
	} headBlock:^(id _) {
		return current.head;
	} tailBlock:^ id (id _) {
		if (stop) return nil;

		return [valuesSeq bind:bindBlock passingThroughValuesFromSequence:current.tail];
	}];

	sequence.name = self.name;
	return sequence;
}
</code></pre>

<p>这个非常复杂的方法实际作用就是创建了一个私有类 <code class="highlighter-rouge">RACDynamicSequence</code> 对象，使用的初始化方法也都是私有的 <code class="highlighter-rouge">+sequenceWithLazyDependency:headBlock:tailBlock:</code>：</p>

<pre><code class="language-objectivec">+ (RACSequence *)sequenceWithLazyDependency:(id (^)(void))dependencyBlock headBlock:(id (^)(id dependency))headBlock tailBlock:(RACSequence *(^)(id dependency))tailBlock {
	RACDynamicSequence *seq = [[RACDynamicSequence alloc] init];
	seq.headBlock = [headBlock copy];
	seq.tailBlock = [tailBlock copy];
	seq.dependencyBlock = [dependencyBlock copy];
	seq.hasDependency = YES;
	return seq;
}
</code></pre>

<p>在使用 <code class="highlighter-rouge">RACDynamicSequence</code> 中的元素时，无论是 <code class="highlighter-rouge">head</code> 还是 <code class="highlighter-rouge">tail</code> 都会用到在初始化方法中传入的三个 block：</p>

<pre><code class="language-objectivec">- (id)head {
	@synchronized (self) {
		id untypedHeadBlock = self.headBlock;
		if (untypedHeadBlock == nil) return _head;

		if (self.hasDependency) {
			if (self.dependencyBlock != nil) {
				_dependency = self.dependencyBlock();
				self.dependencyBlock = nil;
			}

			id (^headBlock)(id) = untypedHeadBlock;
			_head = headBlock(_dependency);
		} else {
			id (^headBlock)(void) = untypedHeadBlock;
			_head = headBlock();
		}

		self.headBlock = nil;
		return _head;
	}
}
</code></pre>

<p><code class="highlighter-rouge">head</code> 的计算依赖于 <code class="highlighter-rouge">self.headBlock</code> 和 <code class="highlighter-rouge">self.dependencyBlock</code>；</p>

<p>而 <code class="highlighter-rouge">tail</code> 的计算也依赖于 <code class="highlighter-rouge">self.headBlock</code> 和 <code class="highlighter-rouge">self.dependencyBlock</code>，只是 <code class="highlighter-rouge">tail</code> 会执行 <code class="highlighter-rouge">tailBlock</code> 返回另一个 <code class="highlighter-rouge">RACDynamicSequence</code> 的实例：</p>

<pre><code class="language-objectivec">^ id (id _) {
    return [valuesSeq bind:bindBlock passingThroughValuesFromSequence:current.tail];
}
</code></pre>

<p>这里通过一段代码更好的了解 <code class="highlighter-rouge">-bind:</code> 方法是如何使用的：</p>

<pre><code class="language-objectivec">RACSequence *sequence = [RACSequence sequenceWithHeadBlock:^id _Nullable{
    return @1;
} tailBlock:^RACSequence * _Nonnull{
    return [RACSequence sequenceWithHeadBlock:^id _Nullable{
        return @2;
    } tailBlock:^RACSequence * _Nonnull{
        return [RACSequence return:@3];
    }];
}];
RACSequence *bindSequence = [sequence bind:^RACSequenceBindBlock _Nonnull{
    return ^(NSNumber *value, BOOL *stop) {
        NSLog(@"RACSequenceBindBlock: %@", value);
        value = @(value.integerValue * 2);
        return [RACSequence return:value];
    };
}];
NSLog(@"sequence:     head = (%@), tail=(%@)", sequence.head, sequence.tail);
NSLog(@"BindSequence: head = (%@), tail=(%@)", bindSequence.head, bindSequence.tail);
</code></pre>

<p>在上面的代码中，我们使用 <code class="highlighter-rouge">+sequenceWithHeadBlock:tailBlock:</code> 这个唯一暴露出来的初始化方法创建了一个如下图所示的 <code class="highlighter-rouge">RACSequence</code>：</p>

<p><img src="https://img.draveness.me/2017-02-04-RACSequence-Instance.png-1000width" alt="RACSequence-Instance" /></p>

<blockquote>
  <p>图中展示了完整的 <code class="highlighter-rouge">RACSequence</code> 对象的值，其中的内容暂时都是 <code class="highlighter-rouge">unresolved</code> 的。</p>
</blockquote>

<p>上述代码在运行之后，会打印出如下内容：</p>

<pre><code class="language-objectivec">sequence:     head = (1), tail=(&lt;RACDynamicSequence: 0x60800009eb40&gt;{ name = , head = (unresolved), tail = (unresolved) })
RACSequenceBindBlock: 1
BindSequence: head = (2), tail=(&lt;RACDynamicSequence: 0x608000282940&gt;{ name = , head = (unresolved), tail = (unresolved) })
</code></pre>

<p>无论是 <code class="highlighter-rouge">sequence</code> 还是 <code class="highlighter-rouge">bindSequence</code>，其中的 <code class="highlighter-rouge">tail</code> 部分都是一个 <code class="highlighter-rouge">RACDynamicSequence</code> 对象，并且其中的 <code class="highlighter-rouge">head</code> 和 <code class="highlighter-rouge">tail</code> 部分都是 <code class="highlighter-rouge">unresolved</code>。</p>

<p><img src="https://img.draveness.me/2017-02-04-Unsolved-RACSequence-Instance.png-1000width" alt="Unsolved-RACSequence-Instance" /></p>

<p>在上面的代码中 <code class="highlighter-rouge">RACSequenceBindBlock</code> 的执行也是惰性的，只有在获取 <code class="highlighter-rouge">bindSequence.head</code> 时，才会执行将数字转换成 <code class="highlighter-rouge">RACUnarySequence</code> 对象，最后通过 <code class="highlighter-rouge">head</code> 属性取出来。</p>

<h3 id="lazysequence-和-eagersequence">lazySequence 和 eagerSequence</h3>

<p>上一节的代码中展示的所有序列都是惰性的，而在整个 ReactiveCocoa 中，所有的 <code class="highlighter-rouge">RACSequence</code> 对象在<strong>默认情况</strong>下都是惰性的，序列中的值只有在真正需要使用时才会被展开，在其他时间都是 <strong>unresolved</strong>。</p>

<p><code class="highlighter-rouge">RACSequence</code> 中定义了两个分别获取 <code class="highlighter-rouge">lazySequence</code> 和 <code class="highlighter-rouge">eagerSequence</code> 的属性：</p>

<pre><code class="language-objectivec">@property (nonatomic, copy, readonly) RACSequence&lt;ValueType&gt; *eagerSequence;
@property (nonatomic, copy, readonly) RACSequence&lt;ValueType&gt; *lazySequence;
</code></pre>

<blockquote>
  <p>笔者一直认为在大多数情况下，在客户端上的惰性求值都是没有太多意义的，如果一个序列的<strong>长度没有达到比较庞大的数量级或者说计算量比较小</strong>，我们完全都可以使用贪婪求值（Eager Evaluation）的方式尽早获得结果；</p>

  <p>同样，在数量级和计算量不需要考虑时，我们也不需要考虑是否应该设计成哪种求值方式，只需要使用默认行为。</p>
</blockquote>

<p>与上一节相同，在这里使用相同的代码创建一个 <code class="highlighter-rouge">RACSequence</code> 对象：</p>

<pre><code class="language-objectivec">RACSequence *sequence = [RACSequence sequenceWithHeadBlock:^id _Nullable{
    return @1;
} tailBlock:^RACSequence * _Nonnull{
    return [RACSequence sequenceWithHeadBlock:^id _Nullable{
        return @2;
    } tailBlock:^RACSequence * _Nonnull{
        return [RACSequence return:@3];
    }];
}];

NSLog(@"Lazy:  %@", sequence.lazySequence);
NSLog(@"Eager: %@", sequence.eagerSequence);
NSLog(@"Lazy:  %@", sequence.lazySequence);
</code></pre>

<p>然后分别三次打印出当前对象的 <code class="highlighter-rouge">lazySequence</code> 和 <code class="highlighter-rouge">eagerSequence</code> 中的值：</p>

<pre><code class="language-objectivec">Lazy:  &lt;RACDynamicSequence: 0x608000097160&gt;
{ name = , head = (unresolved), tail = (unresolved) }
Eager: &lt;RACEagerSequence: 0x600000035de0&gt;
{ name = , array = (
    1,
    2,
    3
) }
Lazy:  &lt;RACDynamicSequence: 0x608000097160&gt;
{ name = , head = 1, tail = &lt;RACDynamicSequence: 0x600000097070&gt;
    { name = , head = 2, tail = &lt;RACUnarySequence: 0x600000035f00&gt;
        { name = , head = 3 } } }
</code></pre>

<p>在第一调用 <code class="highlighter-rouge">sequence.lazySequence</code> 时，因为元素没有被使用，惰性序列的 <code class="highlighter-rouge">head</code> 和 <code class="highlighter-rouge">tail</code> 都为 unresolved；而在 <code class="highlighter-rouge">sequence.eagerSequence</code> 调用后，访问了序列中的所有元素，在这之后再打印 <code class="highlighter-rouge">sequence.lazySequence</code> 中的值就都不是 unresolved 的了。</p>

<p><img src="https://img.draveness.me/2017-02-04-RACSequence-Status-Before-And-After-Executed.png-1000width" alt="RACSequence-Status-Before-And-After-Executed" /></p>

<p>这种情况的出现不难理解，不过因为 <code class="highlighter-rouge">lazySequence</code> 和 <code class="highlighter-rouge">eagerSequence</code> 是 <code class="highlighter-rouge">RACSequence</code> 的方法，所以我们可以在任意子类的实例包括 <code class="highlighter-rouge">RACEagerSequence</code> 和非惰性序列上调用它们，这就会出现以下的多种情况：</p>

<p><img src="https://img.draveness.me/2017-02-04-EagerSequence - LazySequence.png-1000width" alt="EagerSequence - LazySequence" /></p>

<p>总而言之，调用过 <code class="highlighter-rouge">eagerSequence</code> 的序列的元素已经不再是 <code class="highlighter-rouge">unresolved</code> 了，哪怕再调用 <code class="highlighter-rouge">lazySequence</code> 方法，读者可以自行实验验证这里的结论。</p>

<h3 id="操作-racsequence">操作 RACSequence</h3>

<p><code class="highlighter-rouge">RACStream</code> 为 <code class="highlighter-rouge">RACSequence</code> 提供了很多基本的操作，<code class="highlighter-rouge">-map:</code>、<code class="highlighter-rouge">-filter:</code>、<code class="highlighter-rouge">-ignore:</code> 等等，因为这些方法的实现都基于 <code class="highlighter-rouge">-bind:</code>，而 <code class="highlighter-rouge">-bind:</code> 方法的执行是惰性的，所以在调用上述方法之后返回的 <code class="highlighter-rouge">RACSequence</code> 中所有的元素都是 unresolved 的，需要在访问之后才会计算并展开：</p>

<pre><code class="language-objectivec">RACSequence *sequence = [@[@1, @2, @3].rac_sequence map:^id _Nullable(NSNumber * _Nullable value) {
    return @(value.integerValue * value.integerValue);
}];
NSLog(@"%@", sequence); -&gt; &lt;RACDynamicSequence: 0x60800009ad10&gt;{ name = , head = (unresolved), tail = (unresolved) }
NSLog(@"%@", sequence.eagerSequence); -&gt; &lt;RACEagerSequence: 0x60800002bfc0&gt;{ name = , array = (1, 4, 9) }
</code></pre>

<p>除了从 <code class="highlighter-rouge">RACStream</code> 中继承的一些方法，在 <code class="highlighter-rouge">RACSequence</code> 类中也有一些自己实现的方法，比如说 <code class="highlighter-rouge">-foldLeftWithStart:reduce:</code> 方法：</p>

<pre><code class="language-objectivec">- (id)foldLeftWithStart:(id)start reduce:(id (^)(id, id))reduce {
	if (self.head == nil) return start;

	for (id value in self) {
		start = reduce(start, value);
	}

	return start;
}
</code></pre>

<p>使用简单的 <code class="highlighter-rouge">for</code> 循环，将序列中的数据进行『折叠』，最后返回一个结果：</p>

<pre><code class="language-objectivec">RACSequence *sequence = @[@1, @2, @3].rac_sequence;
NSNumber *sum = [sequence foldLeftWithStart:0 reduce:^id _Nullable(NSNumber * _Nullable accumulator, NSNumber * _Nullable value) {
    return @(accumulator.integerValue + value.integerValue);
}];
NSLog(@"%@", sum);
</code></pre>

<p>与上面方法相似的是 <code class="highlighter-rouge">-foldRightWithStart:reduce:</code> 方法，从右侧开始向左折叠整个序列，虽然过程有一些不同，但是结果还是一样的。</p>

<p><img src="https://img.draveness.me/2017-02-04-FoldLeft - FoldRight.png-1000width" alt="FoldLeft - FoldRight" /></p>

<p>从两次方法的调用栈上来看，就能看出两者实现过程的明显区别：</p>

<p><img src="https://img.draveness.me/2017-02-04-Call-Stacks-of-FoldLeft-FoldRight.png-1000width" alt="Call-Stacks-of-FoldLeft-FoldRight" /></p>

<ul>
  <li><code class="highlighter-rouge">foldLeft</code> 由于其实现是通过 <code class="highlighter-rouge">for</code> 循环遍历序列，所以调用栈不会展开，在循环结束之后就返回了，调用栈中只有当前方法；</li>
  <li><code class="highlighter-rouge">foldRight</code> 的调用栈<strong>递归</strong>的调用自己，直到出现了边界条件 <code class="highlighter-rouge">self.tail == nil</code> 后停止，左侧的调用栈也是其调用栈最深的时候，在这时调用栈的规模开始按照箭头方向缩小，直到方法返回。</li>
</ul>

<p>在源代码中，你也可以看到方法在创建 <code class="highlighter-rouge">RACSequence</code> 的 block 中递归调用了当前的方法：</p>

<pre><code class="language-objectivec">- (id)foldRightWithStart:(id)start reduce:(id (^)(id, RACSequence *))reduce {
	if (self.head == nil) return start;

	RACSequence *rest = [RACSequence sequenceWithHeadBlock:^{
		if (self.tail) {
			return [self.tail foldRightWithStart:start reduce:reduce];
		} else {
			return start;
		}
	} tailBlock:nil];

	return reduce(self.head, rest);
}
</code></pre>

<h3 id="racsequence-与-racsignal">RACSequence 与 RACSignal</h3>

<p>虽然 <code class="highlighter-rouge">RACSequence</code> 与 <code class="highlighter-rouge">RACSignal</code> 有很多不同，但是在 ReactiveCocoa 中 <code class="highlighter-rouge">RACSequence</code> 与 <code class="highlighter-rouge">RACSignal</code> 却可以双向转换。</p>

<p><img src="https://img.draveness.me/2017-02-04-Transform Between RACSequence - RACSignal.png-1000width" alt="Transform Between RACSequence - RACSigna" /></p>

<h4 id="将-racsequence-转换成-racsignal">将 RACSequence 转换成 RACSignal</h4>

<p>将 <code class="highlighter-rouge">RACSequence</code> 转换成 <code class="highlighter-rouge">RACSignal</code> 对象只需要调用一个方法。</p>

<p><img src="https://img.draveness.me/2017-02-04-Transform-RACSequence-To-RACSignal.png-1000width" alt="Transform-RACSequence-To-RACSigna" /></p>

<p>分析其实现之前先看一下如何使用 <code class="highlighter-rouge">-signal</code> 方法将 <code class="highlighter-rouge">RACSequence</code> 转换成 <code class="highlighter-rouge">RACSignal</code> 对象的：</p>

<pre><code class="language-objectivec">RACSequence *sequence = @[@1, @2, @3].rac_sequence;
RACSignal *signal = sequence.signal;
[signal subscribeNext:^(id  _Nullable x) {
    NSLog(@"%@", x);
}];
</code></pre>

<p>其实过程非常简单，原序列 <code class="highlighter-rouge">@[@1, @2, @3]</code> 中的元素会按照次序发送，可以理解为依次调用 <code class="highlighter-rouge">-sendNext:</code>，它可以等价于下面的代码：</p>

<pre><code class="language-objectivec">RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) {
    [subscriber sendNext:@1];
    [subscriber sendNext:@2];
    [subscriber sendNext:@3];
    [subscriber sendCompleted];
    return nil;
}];
[signal subscribeNext:^(id  _Nullable x) {
    NSLog(@"%@", x);
}];
</code></pre>

<p><code class="highlighter-rouge">-signal</code> 方法的实现依赖于另一个实例方法 <code class="highlighter-rouge">-signalWithScheduler:</code>，它会在一个 <code class="highlighter-rouge">RACScheduler</code> 对象上发送序列中的所有元素：</p>

<pre><code class="language-objectivec">- (RACSignal *)signal {
	return [[self signalWithScheduler:[RACScheduler scheduler]] setNameWithFormat:@"[%@] -signal", self.name];
}

- (RACSignal *)signalWithScheduler:(RACScheduler *)scheduler {
	return [[RACSignal createSignal:^(id&lt;RACSubscriber&gt; subscriber) {
		__block RACSequence *sequence = self;

		return [scheduler scheduleRecursiveBlock:^(void (^reschedule)(void)) {
			if (sequence.head == nil) {
				[subscriber sendCompleted];
				return;
			}
			[subscriber sendNext:sequence.head];
			sequence = sequence.tail;
			reschedule();
		}];
	}] setNameWithFormat:@"[%@] -signalWithScheduler: %@", self.name, scheduler];
}
</code></pre>

<p><code class="highlighter-rouge">RACScheduler</code> 并不是这篇文章准备介绍的内容，这里的代码其实相当于递归调用了 <code class="highlighter-rouge">reschedule</code> block，不断向 <code class="highlighter-rouge">subscriber</code> 发送 <code class="highlighter-rouge">-sendNext:</code>，直到 <code class="highlighter-rouge">RACSequence</code> 为空为止。</p>

<h4 id="将-racsignal-转换成-racsequence">将 RACSignal 转换成 RACSequence</h4>

<p>反向转换 <code class="highlighter-rouge">RACSignal</code> 的过程相比之下就稍微复杂一点了，我们需要连续调用两个方法，才能将它转换成 <code class="highlighter-rouge">RACSequence</code>。</p>

<p><img src="https://img.draveness.me/2017-02-04-Transform RACSignal to RACSequence.png-1000width" alt="Transform RACSignal to RACSequence" /></p>

<p>通过一段代码来看转换过程是如何进行的：</p>

<pre><code class="language-objectivec">RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) {
    [subscriber sendNext:@1];
    [subscriber sendNext:@2];
    [subscriber sendNext:@3];
    [subscriber sendCompleted];
    return nil;
}];
NSLog(@"%@", signal.toArray.rac_sequence);
</code></pre>

<p>运行上面的代码，会得到一个如下的 <code class="highlighter-rouge">RACArraySequence</code> 对象：</p>

<pre><code class="language-objectivec">&lt;RACArraySequence: 0x608000024e80&gt;{ name = , array = (
    1,
    2,
    3
) }
</code></pre>

<p>在这里不想过多介绍其实现原理，我们只需要知道这里使用了 <code class="highlighter-rouge">RACStream</code> 提供的操作『收集』了信号发送过程中的发送的所有对象 <code class="highlighter-rouge">@1</code>、<code class="highlighter-rouge">@2</code>、<code class="highlighter-rouge">@3</code> 就可以了。</p>

<h2 id="总结">总结</h2>

<p>相比于 <code class="highlighter-rouge">RACSignal</code> 来说，虽然 <code class="highlighter-rouge">RACSequence</code> 有很多的子类，但是它的用途和实现复杂度都少很多，这主要是因为它是 Pull-Driven 的，只有在使用时才会更新，所以我们一般只会使用 <code class="highlighter-rouge">RACSequence</code> 操作数据流，使用 <code class="highlighter-rouge">map</code>、<code class="highlighter-rouge">filter</code>、<code class="highlighter-rouge">flattenMap</code> 等方法快速操作数据。</p>

<h2 id="references">References</h2>

<ul>
  <li><a href="http://nshipster.com/reactivecocoa/">Reactive​Cocoa · NSHipster</a></li>
  <li><a href="http://stackoverflow.com/questions/28952900/what-is-the-difference-between-racsequence-and-racsignal">What is the difference between RACSequence and RACSignal</a></li>
  <li><a href="http://rcdp.io/Signal.html">ReactiveCocoa Design Patterns</a></li>
</ul>

<blockquote>
  <p>Github Repo：<a href="https://github.com/draveness/iOS-Source-Code-Analyze">iOS-Source-Code-Analyze</a></p>

</blockquote>

<blockquote>

  <p>Source: http://draveness.me/racsignal</p>
</blockquote>


        </section>

        <footer class="post-footer">

            <!-- Everything inside the #author tags pulls data from the author -->
            <!-- #author-->
            
                
                    
                        <figure class="author-image">
                            <a class="img" href="/reprinted/author/Draveness" style="background-image: url(/reprinted/assets/images/draven.png)"><span class="hidden">Draveness's Picture</span></a>
                        </figure>
                    

                    <section class="author">
                        <h4><a href="/reprinted/author/Draveness">Draveness</a></h4>

                        
                            <p>Read <a href="/reprinted/author/Draveness">more posts</a> by this author.</p>
                        
                        <div class="author-meta">
                            <span class="author-location icon-location"> Beijing, China</span>
                            <span class="author-link icon-link"><a href="https://draveness.me/index"> draveness.me/index</a></span>
                        </div>
                    </section>

                    <!-- /author  -->

                    <section class="share">
                        <h4>Share this post</h4>
                        <a class="icon-twitter" href="http://twitter.com/share?text=Pull-Driven 的数据流 RACSequence&amp;url=racsequence"
                            onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
                            <span class="hidden">Twitter</span>
                        </a>
                        <a class="icon-facebook" href="https://www.facebook.com/sharer/sharer.php?u=racsequence"
                            onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
                            <span class="hidden">Facebook</span>
                        </a>
                        <a class="icon-google-plus" href="https://plus.google.com/share?url=racsequence"
                           onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
                            <span class="hidden">Google+</span>
                        </a>
                    </section>
                
            
            <!-- Add Disqus Comments -->
            

        </footer>

    </article>

</main>
<aside class="read-next">

    <!-- [[! next_post ]] -->
    
        <a class="read-next-story " style="background-image: url(/reprinted/assets/images/cover2.jpg)" href="/reprinted/racsubject">
            <section class="post">
                <h2>『可变』的热信号 RACSubject</h2>
                <p>> 转自：[『可变』的热信号 RACSubject](https://draveness.me/racsubject) 在 ReactiveCocoa 中除了不可变的信号 `RACSignal`，也有用于桥接非 RAC 代码到 ReactiveCocoa 世界的『可变』信号 `RACSubject`。 ![“Mutable” RACSignal —...</p>
            </section>
        </a>
    
    <!-- [[! /next_post ]] -->
    <!-- [[! prev_post ]] -->
    
        <a class="read-next-story prev " style="background-image: url(/reprinted/assets/images/cover2.jpg)" href="/reprinted/racsignal">
            <section class="post">
                <h2>『状态』驱动的世界：ReactiveCocoa</h2>
                <p>转自：『状态』驱动的世界：ReactiveCocoa 这篇以及之后的文章主要会对 ReactiveObjc v2.1.2 的实现进行分析，从最简单的例子中了解 ReactiveCocoa 的工作原理以及概念，也是笔者个人对于 RAC 学习的总结与理解。本文主要会围绕 RAC 中核心概念 RACSignal 展开，详细了解其底层实现。 状态驱动 2015...</p>
            </section>
        </a>
    
    <!-- [[! /prev_post ]] -->
</aside>

<!-- /post -->


        <!-- The tiny footer at the very bottom -->
        <footer class="site-footer clearfix">
          <section class="copyright"><a href="/reprinted/"></a> &copy; 2018</section>
          <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> using <a href="https://github.com/jekyller/jasper">Jasper</a></section>
        </footer>
    </div>
    <!-- highlight.js -->
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <!-- jQuery needs to come before `` so that jQuery can be used in code injection -->
    <script type="text/javascript" src="//code.jquery.com/jquery-1.12.0.min.js"></script>
    <!-- Ghost outputs important scripts and data with this tag -->
    <!--  -->
    <!-- Add Google Analytics  -->
        <!-- Google Analytics Tracking code -->
     <script>
	    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	    ga('create', 'UA-69281367-1', 'auto');
	    ga('send', 'pageview');

     </script>
    <!-- Fitvids makes video embeds responsive and awesome -->
    <script type="text/javascript" src="/reprinted/assets/js/jquery.fitvids.js"></script>
    <!-- The main JavaScript file for Casper -->
    <script type="text/javascript" src="/reprinted/assets/js/index.js"></script>

</body>
</html>
