<!DOCTYPE html>
<html>
<head>
    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Page Meta -->
    <title>『零行代码』解决键盘遮挡问题（iOS）</title>
    <meta name="description" content="" />

    <!-- Mobile Meta -->
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- Brand icon -->
    <link rel="shortcut icon" href="/reprinted/assets/images/favicon.ico" >

    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/reprinted/assets/css/screen.css" />
    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400" />
    <link rel="stylesheet" type="text/css" href="/reprinted/assets/css/syntax.css" />

    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/styles/default.min.css">
    <style>.hljs { background: none; }</style>

    <!-- Ghost outputs important style and meta data with this tag -->
        <link rel="canonical" href="/reprinted//keyboard" />
    <meta name="referrer" content="origin" />
    <link rel="next" href="/reprinted/page2/" />

    <meta property="og:site_name" content="" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="『零行代码』解决键盘遮挡问题（iOS）" />
    <meta property="og:description" content="" />
    <meta property="og:url" content="/reprinted//keyboard" />
    <meta property="og:image" content="/reprinted/assets/images/cover2.jpg" />

    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="『零行代码』解决键盘遮挡问题（iOS）" />
    <meta name="twitter:description" content="" />
    <meta name="twitter:url" content="/reprinted//keyboard" />
    <meta name="twitter:image:src" content="/reprinted/assets/images/cover2.jpg" />

    <script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "Website",
    "publisher": "",
    "name": "『零行代码』解决键盘遮挡问题（iOS）",
    "url": "/reprinted//keyboard",
    "image": "/reprinted/assets/images/cover2.jpg",
    "description": ""
}
    </script>

    <meta name="generator" content="Jekyll 3.0.0" />
    <link rel="alternate" type="application/rss+xml" title="" href="/reprinted/feed.xml" />


</head>
<body class="home-template nav-closed">

    <!-- The blog navigation links -->
    <div class="nav">
    <h3 class="nav-title">Menu</h3>
    <a href="#" class="nav-close">
        <span class="hidden">Close</span>
    </a>
    <ul>
        <li class="nav-home " role="presentation"><a href="/reprinted/">Home</a></li>
        <li class="nav-about " role="presentation"><a href="/reprinted/about">About</a></li>
        <li class="nav-ios " role="presentation"><a href="/reprinted/tag/ios">iOS</a></li>
        <li class="nav-objective-c " role="presentation"><a href="/reprinted/tag/objective-c">objective-c</a></li>
        <li class="nav-swift " role="presentation"><a href="/reprinted/tag/swift">Swift</a></li>
        <li class="nav-others " role="presentation"><a href="/reprinted/tag/others">others</a></li>
    </ul>
    <a class="subscribe-button icon-feed" href="/reprinted/feed.xml">Subscribe</a>
</div>
<span class="nav-cover"></span>


    <div class="site-wrapper">

        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- default -->

<!-- The comment above "< default" means - insert everything in this file into -->
    <!-- the [body] of the default.hbs template, which contains our header/footer. -->

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<header class="main-header post-head " style="background-image: url(/reprinted/assets/images/cover2.jpg) ">
    <nav class="main-nav  overlay  clearfix">
        <a class="blog-logo" href="/reprinted/"><img src="/reprinted/assets/images/ghost.png" alt="Blog Logo" /></a>
        
            <a class="menu-button icon-menu" href="#"><span class="word">Menu</span></a>
        
    </nav>
</header>

<main class="content" role="main">

    <article class="post tag-fiction">

        <header class="post-header">
            <h1 class="post-title">『零行代码』解决键盘遮挡问题（iOS）</h1>
            <section class="post-meta">
            <!-- <a href='/reprinted/'></a> -->

            
                
                    <a href='/reprinted/author/Draveness'>Draveness</a>
                
            
            <time class="post-date" datetime="2016-06-22">22 Jun 2016</time>
                <!-- [[tags prefix=" on "]] -->
                
                on
                
                    
                       <a href='/reprinted/tag/iOS'>iOS</a>
                    
                
                
            </section>
        </header>

        <section class="post-content">

            <blockquote>
  <p>转自：<a href="https://draveness.me/keyboard">『零行代码』解决键盘遮挡问题（iOS）</a></p>
</blockquote>

<blockquote>
  <p>关注仓库，及时获得更新：<a href="https://github.com/draveness/iOS-Source-Code-Analyze">iOS-Source-Code-Analyze</a></p>

</blockquote>

<p><img src="https://raw.githubusercontent.com/hackiftekhar/IQKeyboardManager/master/Demo/Resources/icon.png" alt="Icon" /></p>

<blockquote>
  <p>这篇文章会对 IQKeyboardManager 自动解决键盘遮挡问题的方法进行分析。</p>
</blockquote>

<p>最近在项目中使用了 <a href="https://github.com/hackiftekhar/IQKeyboardManager">IQKeyboardManager</a> 来解决 <code class="highlighter-rouge">UITextField</code> 被键盘遮挡的问题，这个框架的使用方法可以说精简到了极致，只需要将 <code class="highlighter-rouge">IQKeyboardManager</code> 加入 <code class="highlighter-rouge">Podfile</code>，然后 <code class="highlighter-rouge">pod install</code> 就可以了。</p>

<pre><code class="language-objectivec">pod 'IQKeyboardManager'
</code></pre>

<p>这篇文章的题目《零行代码解决键盘遮挡问题》来自于开源框架的介绍：</p>

<blockquote>
  <p>Codeless drop-in universal library allows to prevent issues of keyboard sliding up and cover UITextField/UITextView. Neither need to write any code nor any setup required and much more.</p>
</blockquote>

<p>因为在项目中使用了 IQKeyboardManager，所以，我想通过阅读其源代码来了解这个黑箱是如何工作的。</p>

<blockquote>
  <p>虽然这个框架的实现的方法是比较简单的，不过它的实现代码不是很容易阅读，框架因为包含了很多与 UI 有关的实现细节，所以代码比较复杂。</p>
</blockquote>

<h2 id="架构分析">架构分析</h2>

<p>说是架构分析，其实只是对 <a href="https://github.com/hackiftekhar/IQKeyboardManager">IQKeyboardManager</a> 中包含的类以及文件有一个粗略地了解，研究一下这个项目的层级是什么样的。</p>

<p><img src="https://img.draveness.me/2016-06-22-IQKeyboardManager-Hierarchy.png-1000width" alt="IQKeyboardManager-Hierarchy" /></p>

<p>整个项目中最核心的部分就是 <code class="highlighter-rouge">IQKeyboardManager</code> 这个类，它负责<strong>管理键盘出现或者隐藏时视图移动的距离</strong>，是整个框架中最核心的部分。</p>

<p>在这个框架中还有一些用于支持 IQKeyboardManager 的分类，以及显示在键盘上面的 IQToolBar：</p>

<p><img src="https://img.draveness.me/2016-06-22-IQToolBar.png-1000width" alt="IQToolBa" /></p>

<p>使用红色标记的部分就是 <code class="highlighter-rouge">IQToolBar</code>，左侧的按钮可以在不同的 <code class="highlighter-rouge">UITextField</code> 之间切换，中间的文字是 <code class="highlighter-rouge">UITextField.placeholderText</code>，右边的 <code class="highlighter-rouge">Done</code> 应该就不需要解释了。</p>

<p>这篇文章会主要分析 <code class="highlighter-rouge">IQKeyboardManager</code> 中解决的问题，会用小篇幅介绍包含占位符（Placeholder） <code class="highlighter-rouge">IQTextView</code> 的实现。</p>

<h2 id="iqtextview-的实现">IQTextView 的实现</h2>

<p>在具体研究如何解决键盘遮挡问题之前，我们先分析一下框架中最简单的一部分 <code class="highlighter-rouge">IQTextView</code> 是如何为 <code class="highlighter-rouge">UITextView</code> 添加占位符的。</p>

<pre><code class="language-objectivec">@interface IQTextView : UITextView

@end
</code></pre>

<p><code class="highlighter-rouge">IQTextView</code> 继承自 <code class="highlighter-rouge">UITextView</code>，它只是在 <code class="highlighter-rouge">UITextView</code> 上添加上了一个 <code class="highlighter-rouge">placeHolderLabel</code>。</p>

<p>在初始化时，我们会为 <code class="highlighter-rouge">UITextViewTextDidChangeNotification</code> 注册通知：</p>

<pre><code class="language-objectivec">- (void)initialize   {
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(refreshPlaceholder) name:UITextViewTextDidChangeNotification object:self];
}
</code></pre>

<p>在每次 UITextView 中的 text 更改时，就会调用 <code class="highlighter-rouge">refreshPlaceholder</code> 方法更新 <code class="highlighter-rouge">placeHolderLabel</code> 的 <code class="highlighter-rouge">alpha</code> 值来隐藏或者显示 label：</p>

<pre><code class="language-objectivec">-(void)refreshPlaceholder {
    if ([[self text] length]) {
        [placeHolderLabel setAlpha:0];
    } else {
        [placeHolderLabel setAlpha:1];
    }

    [self setNeedsLayout];
    [self layoutIfNeeded];
}
</code></pre>

<h2 id="iqkeyboardmanager">IQKeyboardManager</h2>

<p>下面就会进入这篇文章的正题：<code class="highlighter-rouge">IQKeyboardManager</code>。</p>

<p>如果你对 iOS 开发比较熟悉，可能会发现每当一个类的名字中包含了 <code class="highlighter-rouge">manager</code>，那么这个类可能可能遵循单例模式，<code class="highlighter-rouge">IQKeyboardManager</code> 也不例外。</p>

<h3 id="iqkeyboardmanager-的初始化">IQKeyboardManager 的初始化</h3>

<p>当 <code class="highlighter-rouge">IQKeyboardManager</code> 初始化的时候，它做了这么几件事情：</p>

<ol>
  <li>
    <p>监听有关键盘的通知</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardWillShow:) name:UIKeyboardWillShowNotification object:nil];
 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardWillHide:) name:UIKeyboardWillHideNotification object:nil];
 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardDidHide:) name:UIKeyboardDidHideNotification object:nil];
</code></pre></div>    </div>
  </li>
  <li>
    <p>注册与 <code class="highlighter-rouge">UITextField</code> 以及 <code class="highlighter-rouge">UITextView</code> 有关的通知</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> [self registerTextFieldViewClass:[UITextField class]
  didBeginEditingNotificationName:UITextFieldTextDidBeginEditingNotification
    didEndEditingNotificationName:UITextFieldTextDidEndEditingNotification];

 [self registerTextFieldViewClass:[UITextView class]
  didBeginEditingNotificationName:UITextViewTextDidBeginEditingNotification
    didEndEditingNotificationName:UITextViewTextDidEndEditingNotification];
</code></pre></div>    </div>

    <ul>
      <li>
        <p>调用的方法将通知绑定到了 <code class="highlighter-rouge">textFieldViewDidBeginEditing:</code> 和 <code class="highlighter-rouge">textFieldViewDidEndEditing:</code> 方法上</p>

        <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  - (void)registerTextFieldViewClass:(nonnull Class)aClass
    didBeginEditingNotificationName:(nonnull NSString *)didBeginEditingNotificationName
      didEndEditingNotificationName:(nonnull NSString *)didEndEditingNotificationName {
      [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(textFieldViewDidBeginEditing:) name:didBeginEditingNotificationName object:nil];
      [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(textFieldViewDidEndEditing:) name:didEndEditingNotificationName object:nil];
  }
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>
    <p>初始化一个 <code class="highlighter-rouge">UITapGestureRecognizer</code>，在点击 <code class="highlighter-rouge">UITextField</code> 对应的 <code class="highlighter-rouge">UIWindow</code> 的时候，收起键盘</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> strongSelf.tapGesture = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tapRecognized:)];

 - (void)tapRecognized:(UITapGestureRecognizer*)gesture {
     if (gesture.state == UIGestureRecognizerStateEnded)
         [self resignFirstResponder];
 }
</code></pre></div>    </div>
  </li>
  <li>
    <p>初始化一些默认属性，例如键盘距离、覆写键盘的样式等</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> strongSelf.animationDuration = 0.25;
 strongSelf.animationCurve = UIViewAnimationCurveEaseInOut;
 [self setKeyboardDistanceFromTextField:10.0];
 [self setShouldPlayInputClicks:YES];
 [self setShouldResignOnTouchOutside:NO];
 [self setOverrideKeyboardAppearance:NO];
 [self setKeyboardAppearance:UIKeyboardAppearanceDefault];
 [self setEnableAutoToolbar:YES];
 [self setPreventShowingBottomBlankSpace:YES];
 [self setShouldShowTextFieldPlaceholder:YES];
 [self setToolbarManageBehaviour:IQAutoToolbarBySubviews];
 [self setLayoutIfNeededOnUpdate:NO];
</code></pre></div>    </div>
  </li>
  <li>
    <p>设置不需要解决键盘遮挡问题的类</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> strongSelf.disabledDistanceHandlingClasses = [[NSMutableSet alloc] initWithObjects:[UITableViewController class], nil];
 strongSelf.enabledDistanceHandlingClasses = [[NSMutableSet alloc] init];

 strongSelf.disabledToolbarClasses = [[NSMutableSet alloc] init];
 strongSelf.enabledToolbarClasses = [[NSMutableSet alloc] init];

 strongSelf.toolbarPreviousNextAllowedClasses = [[NSMutableSet alloc] initWithObjects:[UITableView class],[UICollectionView class],[IQPreviousNextView class], nil];

 strongSelf.disabledTouchResignedClasses = [[NSMutableSet alloc] init];
 strongSelf.enabledTouchResignedClasses = [[NSMutableSet alloc] init];
</code></pre></div>    </div>
  </li>
</ol>

<p>整个初始化方法大约有几十行的代码，在这里就不再展示整个方法的全部代码了。</p>

<h3 id="基于通知的解决方案">基于通知的解决方案</h3>

<blockquote>
  <p>在这里，我们以 UITextField 为例，分析方法的调用流程。</p>
</blockquote>

<p>在初始化方法中，我们注册了很多的通知，包括键盘的出现和隐藏，<code class="highlighter-rouge">UITextField</code> 开始编辑与结束编辑。</p>

<pre><code class="language-objectivec">UIKeyboardWillShowNotification
UIKeyboardWillHideNotification
UIKeyboardDidHideNotification
UITextFieldTextDidBeginEditingNotification
UITextFieldTextDidEndEditingNotification
</code></pre>

<p>在这些通知响应时，会执行以下的方法：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Notification</th>
      <th style="text-align: center">Selector</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><code class="highlighter-rouge">UIKeyboardWillShowNotification</code></td>
      <td style="text-align: center"><code class="highlighter-rouge">@selector(keyboardWillShow:)</code></td>
    </tr>
    <tr>
      <td style="text-align: center"><code class="highlighter-rouge">UIKeyboardWillHideNotification</code></td>
      <td style="text-align: center"><code class="highlighter-rouge">@selector(keyboardWillHide:)</code></td>
    </tr>
    <tr>
      <td style="text-align: center"><code class="highlighter-rouge">UIKeyboardDidHideNotification</code></td>
      <td style="text-align: center"><code class="highlighter-rouge">@selector(keyboardDidHide:)</code></td>
    </tr>
    <tr>
      <td style="text-align: center"><code class="highlighter-rouge">UITextFieldTextDidBeginEditingNotification</code></td>
      <td style="text-align: center"><code class="highlighter-rouge">@selector(textFieldViewDidBeginEditing:)</code></td>
    </tr>
    <tr>
      <td style="text-align: center"><code class="highlighter-rouge">UITextFieldTextDidEndEditingNotification</code></td>
      <td style="text-align: center"><code class="highlighter-rouge">@selector(textFieldViewDidEndEditing:)</code></td>
    </tr>
  </tbody>
</table>

<p>整个解决方案其实都是基于 iOS 中的通知系统的；在事件发生时，调用对应的方法做出响应。</p>

<h3 id="开启-debug-模式">开启 Debug 模式</h3>

<p>在阅读源代码的过程中，我发现 <code class="highlighter-rouge">IQKeyboardManager</code> 提供了 <code class="highlighter-rouge">enableDebugging</code> 这一属性，可以通过开启它，来追踪方法的调用，我们可以在 Demo 加入下面这行代码：</p>

<pre><code class="language-objectivec">[IQKeyboardManager sharedManager].enableDebugging = YES;
</code></pre>

<h2 id="键盘的出现">键盘的出现</h2>

<p>然后运行工程，在 Demo 中点击一个 <code class="highlighter-rouge">UITextField</code></p>

<p><img src="https://img.draveness.me/2016-06-22-easiest-integration-demo.png-1000width" alt="easiest-integration-demo" /></p>

<p>上面的操作会打印出如下所示的 Log：</p>

<pre><code class="language-objectivec">IQKeyboardManager: ****** textFieldViewDidBeginEditing: started ******
IQKeyboardManager: adding UIToolbars if required
IQKeyboardManager: Saving &lt;UINavigationController 0x7f905b01b000&gt; beginning Frame: {0, 0}, {320, 568}
IQKeyboardManager: ****** adjustFrame started ******
IQKeyboardManager: Need to move: -451.00
IQKeyboardManager: ****** adjustFrame ended ******
IQKeyboardManager: ****** textFieldViewDidBeginEditing: ended ******
IQKeyboardManager: ****** keyboardWillShow: started ******
IQKeyboardManager: ****** adjustFrame started ******
IQKeyboardManager: Need to move: -154.00
IQKeyboardManager: ****** adjustFrame ended ******
IQKeyboardManager: ****** keyboardWillShow: ended ******
</code></pre>

<p>我们可以通过分析 <code class="highlighter-rouge">- textFieldViewDidBeginEditing:</code> 以及 <code class="highlighter-rouge">- keyboardWillShow:</code> 方法来了解这个项目的原理。</p>

<h3 id="textfieldviewdidbeginediting">textFieldViewDidBeginEditing:</h3>

<p>当 <code class="highlighter-rouge">UITextField</code> 被点击时，方法 <code class="highlighter-rouge">- textFieldViewDidBeginEditing:</code> 被调用，但是注意这里的方法并不是代理方法，它只是一个跟代理方法同名的方法，根据 Log，它做了三件事情：</p>

<ul>
  <li>为 <code class="highlighter-rouge">UITextField</code> 添加 <code class="highlighter-rouge">IQToolBar</code></li>
  <li>在调整 frame 前，保存当前 frame，以备之后键盘隐藏后的恢复</li>
  <li>调用 <code class="highlighter-rouge">- adjustFrame</code> 方法，将视图移动到合适的位置</li>
</ul>

<h4 id="添加-toolbar">添加 ToolBar</h4>

<p>添加 ToolBar 是通过方法 <code class="highlighter-rouge">- addToolbarIfRequired</code> 实现的，在 <code class="highlighter-rouge">- textFieldViewDidBeginEditing:</code> 先通过 <code class="highlighter-rouge">- privateIsEnableAutoToolbar</code> 判断 ToolBar 是否需要添加，再使用相应方法 <code class="highlighter-rouge">- addToolbarIfRequired</code> 实现这一目的。</p>

<p>这个方法会根据根视图上 <code class="highlighter-rouge">UITextField</code> 的数量执行对应的代码，下面为一般情况下执行的代码：</p>

<pre><code class="language-objectivec">- (void)addToolbarIfRequired {
    NSArray *siblings = [self responderViews];
    for (UITextField *textField in siblings) {
        [textField addPreviousNextDoneOnKeyboardWithTarget:self previousAction:@selector(previousAction:) nextAction:@selector(nextAction:) doneAction:@selector(doneAction:) shouldShowPlaceholder:_shouldShowTextFieldPlaceholder];
        textField.inputAccessoryView.tag = kIQPreviousNextButtonToolbarTag;

        IQToolbar *toolbar = (IQToolbar*)[textField inputAccessoryView];
        toolbar.tintColor = [UIColor blackColor];
        [toolbar setTitle:textField.drawingPlaceholderText];
        [textField setEnablePrevious:NO next:YES];
    }
}
</code></pre>

<p>在键盘上的 <code class="highlighter-rouge">IQToolBar</code> 一般由三部分组成：</p>

<ul>
  <li>切换 <code class="highlighter-rouge">UITextField</code> 的箭头按钮</li>
  <li>指示当前 <code class="highlighter-rouge">UITextField</code> 的 placeholder</li>
  <li>Done Button</li>
</ul>

<p><img src="https://img.draveness.me/2016-06-22-IQToolBarItem.png-1000width" alt="IQToolBarIte" /></p>

<blockquote>
  <p>这些 item 都是 <code class="highlighter-rouge">IQBarButtonItem</code> 的子类</p>
</blockquote>

<p>这些 <code class="highlighter-rouge">IQBarButtonItem</code> 以及 <code class="highlighter-rouge">IQToolBar</code> 都是通过方法 <code class="highlighter-rouge">- addPreviousNextDoneOnKeyboardWithTarget:previousAction:nextAction:doneAction:</code> 或者类似方法添加的：</p>

<pre><code class="language-objectivec">- (void)addPreviousNextDoneOnKeyboardWithTarget:(id)target previousAction:(SEL)previousAction nextAction:(SEL)nextAction doneAction:(SEL)doneAction titleText:(NSString*)titleText {
    IQBarButtonItem *prev = [[IQBarButtonItem alloc] initWithImage:imageLeftArrow style:UIBarButtonItemStylePlain target:target action:previousAction];
    IQBarButtonItem *next = [[IQBarButtonItem alloc] initWithImage:imageRightArrow style:UIBarButtonItemStylePlain target:target action:nextAction];
    IQTitleBarButtonItem *title = [[IQTitleBarButtonItem alloc] initWithTitle:self.shouldHideTitle?nil:titleText];
    IQBarButtonItem *doneButton =[[IQBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemDone target:target action:doneAction];

    IQToolbar *toolbar = [[IQToolbar alloc] init];
    toolbar.barStyle = UIBarStyleDefault;
    toolbar.items = @[prev, next, title, doneButton];
    toolbar.titleInvocation = self.titleInvocation;
    [(UITextField*)self setInputAccessoryView:toolbar];
}
</code></pre>

<p>上面是方法简化后的实现代码，初始化需要的 <code class="highlighter-rouge">IQBarButtonItem</code>，然后将这些 <code class="highlighter-rouge">IQBarButtonItem</code> 全部加入到 <code class="highlighter-rouge">IQToolBar</code> 上，最后设置 <code class="highlighter-rouge">UITextField</code> 的 <code class="highlighter-rouge">accessoryView</code>。</p>

<h4 id="保存-frame">保存 frame</h4>

<p>这一步的主要目的是为了在键盘隐藏时恢复到原来的状态，其实现也非常简单：</p>

<pre><code class="language-objectivec">_rootViewController = [_textFieldView topMostController];
_topViewBeginRect = _rootViewController.view.frame;
</code></pre>

<p>获取 <code class="highlighter-rouge">topMostController</code>，在 <code class="highlighter-rouge">_topViewBeginRect</code> 中保存 <code class="highlighter-rouge">frame</code>。</p>

<h4 id="adjustframe">adjustFrame</h4>

<p>在上述的任务都完成之后，最后就需要调用 <code class="highlighter-rouge">- adjustFrame</code> 方法来调整当前根试图控制器的 <code class="highlighter-rouge">frame</code> 了：</p>

<blockquote>
  <p>我们只会研究一般情况下的实现代码，因为这个方法大约有 400 行代码对不同情况下的实现有不同的路径，包括有 <code class="highlighter-rouge">lastScrollView</code>、含有 <code class="highlighter-rouge">superScrollView</code> 等等。</p>

  <p>而这里会省略绝大多数情况下的实现代码。</p>
</blockquote>

<pre><code class="language-objectivec">- (void)adjustFrame {
    UIWindow *keyWindow = [self keyWindow];
    UIViewController *rootController = [_textFieldView topMostController];    
    CGRect textFieldViewRect = [[_textFieldView superview] convertRect:_textFieldView.frame toView:keyWindow];
    CGRect rootViewRect = [[rootController view] frame];
    CGSize kbSize = _kbSize;
    kbSize.height += keyboardDistanceFromTextField;
    CGFloat topLayoutGuide = CGRectGetHeight(statusBarFrame);
    CGFloat move = MIN(CGRectGetMinY(textFieldViewRect)-(topLayoutGuide+5), CGRectGetMaxY(textFieldViewRect)-(CGRectGetHeight(keyWindow.frame)-kbSize.height));

    if (move &gt;= 0) {
        rootViewRect.origin.y -= move;
        [self setRootViewFrame:rootViewRect];
    } else {
        CGFloat disturbDistance = CGRectGetMinY(rootViewRect)-CGRectGetMinY(_topViewBeginRect);
        if (disturbDistance &lt; 0) {
            rootViewRect.origin.y -= MAX(move, disturbDistance);
            [self setRootViewFrame:rootViewRect];
        }
    }
}
</code></pre>

<p>方法 <code class="highlighter-rouge">- adjustFrame</code> 的工作分为两部分：</p>

<ol>
  <li>计算 <code class="highlighter-rouge">move</code> 的距离</li>
  <li>
    <p>调用 <code class="highlighter-rouge">- setRootViewFrame:</code> 方法设置 <code class="highlighter-rouge">rootView</code> 的大小</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> - (void)setRootViewFrame:(CGRect)frame {
     UIViewController *controller = [_textFieldView topMostController];    
     frame.size = controller.view.frame.size;

     [UIView animateWithDuration:_animationDuration delay:0 options:(_animationCurve|UIViewAnimationOptionBeginFromCurrentState) animations:^{
         [controller.view setFrame:frame];
     } completion:NULL];
 }
</code></pre></div>    </div>
  </li>
</ol>

<blockquote>
  <p>不过，在 <code class="highlighter-rouge">- textFieldViewDidBeginEditing:</code> 的调用栈中，并没有执行 <code class="highlighter-rouge">- setRootViewFrame:</code> 来更新视图的大小，因为点击最上面的 <code class="highlighter-rouge">UITextField</code> 时，不需要移动视图就能保证键盘不会遮挡 <code class="highlighter-rouge">UITextField</code>。</p>
</blockquote>

<h3 id="keyboardwillshow">keyboardWillShow:</h3>

<p>上面的代码都是在键盘出现之前执行的，而这里的 <code class="highlighter-rouge">- keyboardWillShow:</code> 方法的目的是为了保证键盘出现之后，依然没有阻挡 <code class="highlighter-rouge">UITextField</code>。</p>

<p>因为每一个 <code class="highlighter-rouge">UITextField</code> 对应的键盘大小可能不同，所以，这里通过检测键盘大小是否改变，来决定是否调用 <code class="highlighter-rouge">- adjustFrame</code> 方法更新视图的大小。</p>

<pre><code class="language-objectivec">- (void)keyboardWillShow:(NSNotification*)aNotification {
    _kbShowNotification = aNotification;

    _animationCurve = [[aNotification userInfo][UIKeyboardAnimationCurveUserInfoKey] integerValue];
    _animationCurve = _animationCurve&lt;&lt;16;
    CGFloat duration = [[aNotification userInfo][UIKeyboardAnimationDurationUserInfoKey] floatValue];
    if (duration != 0.0)    _animationDuration = duration;

    CGSize oldKBSize = _kbSize;
    CGRect kbFrame = [[aNotification userInfo][UIKeyboardFrameEndUserInfoKey] CGRectValue];
    CGRect screenSize = [[UIScreen mainScreen] bounds];
    CGRect intersectRect = CGRectIntersection(kbFrame, screenSize);

    if (CGRectIsNull(intersectRect)) {
        _kbSize = CGSizeMake(screenSize.size.width, 0);
    } else {
        _kbSize = intersectRect.size;
    }

    if (!CGSizeEqualToSize(_kbSize, oldKBSize)) {
        [self adjustFrame];
    }
}
</code></pre>

<p>在 <code class="highlighter-rouge">- adjustFrame</code> 方法调用之前，执行了很多代码都是用来保存一些关键信息的，比如通知对象、动画曲线、动画时间。</p>

<p>最关键的是更新键盘的大小，然后比较键盘的大小 <code class="highlighter-rouge">CGSizeEqualToSize(_kbSize, oldKBSize)</code> 来判断是否执行 <code class="highlighter-rouge">- adjustFrame</code> 方法。</p>

<blockquote>
  <p>因为 <code class="highlighter-rouge">- adjustFrame</code> 方法的结果是依赖于键盘大小的，所以这里对 <code class="highlighter-rouge">- adjustFrame</code> 是有意义并且必要的。</p>
</blockquote>

<h2 id="键盘的隐藏">键盘的隐藏</h2>

<p>通过点击 <code class="highlighter-rouge">IQToolBar</code> 上面的 done 按钮，键盘就会隐藏：</p>

<p><img src="https://img.draveness.me/2016-06-22-IQKeyboardManager-hide-keyboard.png-1000width" alt="IQKeyboardManager-hide-keyboard" /></p>

<p>键盘隐藏的过程中会依次调用下面的三个方法：</p>

<ul>
  <li><code class="highlighter-rouge">- keyboardWillHide:</code></li>
  <li><code class="highlighter-rouge">- textFieldViewDidEndEditing:</code></li>
  <li><code class="highlighter-rouge">- keyboardDidHide:</code></li>
</ul>

<pre><code class="language-objectivec">IQKeyboardManager: ****** keyboardWillHide: started ******
IQKeyboardManager: Restoring &lt;UINavigationController 0x7fbaa4009e00&gt; frame to : {0, 0}, {320, 568}
IQKeyboardManager: ****** keyboardWillHide: ended ******
IQKeyboardManager: ****** textFieldViewDidEndEditing: started ******
IQKeyboardManager: ****** textFieldViewDidEndEditing: ended ******
IQKeyboardManager: ****** keyboardDidHide: started ******
IQKeyboardManager: ****** keyboardDidHide: ended ******
</code></pre>

<p>键盘在收起时，需要将视图恢复至原来的位置，而这也就是 <code class="highlighter-rouge">- keyboardWillHide:</code> 方法要完成的事情：</p>

<pre><code class="language-objectivec">[strongSelf.rootViewController.view setFrame:strongSelf.topViewBeginRect]
</code></pre>

<blockquote>
  <p>并不会给出该方法的全部代码，只会给出关键代码梳理它的工作流程。</p>
</blockquote>

<p>在重新设置视图的大小以及位置之后，会对之前保存的属性进行清理：</p>

<pre><code class="language-objectivec">_lastScrollView = nil;
_kbSize = CGSizeZero;
_startingContentInsets = UIEdgeInsetsZero;
_startingScrollIndicatorInsets = UIEdgeInsetsZero;
_startingContentOffset = CGPointZero;
</code></pre>

<p>而之后调用的两个方法 <code class="highlighter-rouge">- textFieldViewDidEndEditing:</code> 以及 <code class="highlighter-rouge">- keyboardDidHide:</code> 也只做了很多简单的清理工作，包括添加到 <code class="highlighter-rouge">window</code> 上的手势，并重置保存的 <code class="highlighter-rouge">UITextField</code> 和视图的大小。</p>

<pre><code class="language-objectivec">- (void)textFieldViewDidEndEditing:(NSNotification*)notification{
    [_textFieldView.window removeGestureRecognizer:_tapGesture];
    _textFieldView = nil;
}

- (void)keyboardDidHide:(NSNotification*)aNotification {
    _topViewBeginRect = CGRectZero;
}
</code></pre>

<h2 id="uitextfield-和-uitextview-通知机制">UITextField 和 UITextView 通知机制</h2>

<p>因为框架的功能是基于通知实现的，所以通知的时序至关重要，在 <code class="highlighter-rouge">IQKeyboardManagerConstants.h</code> 文件中详细地描述了在编辑 <code class="highlighter-rouge">UITextField</code> 的过程中，通知触发的先后顺序。</p>

<p><img src="https://img.draveness.me/2016-06-22-notification-IQKeyboardManager.png-1000width" alt="notification-IQKeyboardManage" /></p>

<blockquote>
  <p>上图准确说明了通知发出的时机，透明度为 50% 的部分表示该框架没有监听这个通知。</p>
</blockquote>

<p>而 <code class="highlighter-rouge">UITextView</code> 的通知机制与 <code class="highlighter-rouge">UITextField</code> 略有不同：</p>

<p><img src="https://img.draveness.me/2016-06-22-UITextView-Notification-IQKeyboardManager.png-1000width" alt="UITextView-Notification-IQKeyboardManage" /></p>

<p>当 Begin Editing 这个事件发生时，<code class="highlighter-rouge">UITextView</code> 的通知机制会先发出 <code class="highlighter-rouge">UIKeyboardWillShowNotification</code> 通知，而 <code class="highlighter-rouge">UITextField</code> 会先发出 <code class="highlighter-rouge">UITextFieldTextDidBeginEditingNotification</code> 通知。</p>

<p>而这两个通知的方法都调用了 <code class="highlighter-rouge">- adjustFrame</code> 方法来更新视图的大小，最开始我并不清楚到底是为什么？直到我给作者发了一封邮件，作者告诉我这么做的原因：</p>

<blockquote>
  <p>Good questions draveness. I’m very happy to answer your questions. There is a file in library IQKeyboardManagerConstants.h. You can find iOS Notification mechanism structure.</p>

  <p>You’ll find that for UITextField, textField notification gets fire first and then UIKeyboard notification fires.</p>

  <p>For UITextView, UIKeyboard notification gets fire first and then UITextView notification get’s fire.</p>

  <p>So that’s why I have to call adjustFrame at both places to fulfill both situations. But now I think I should add some validation and make sure to call it once to improve performance.</p>

  <p>Let me know if you have some more questions, I would love to answer them. Thanks again to remind me about this issue.</p>
</blockquote>

<p>在不同方法中调用通知的原因是，UITextView 和 UITextField 通知机制的不同，不过作者可能会在未来的版本中修复这一问题，来获得性能上的提升。</p>

<h2 id="小结">小结</h2>

<p><code class="highlighter-rouge">IQKeyboardManager</code> 使用通知机制来解决键盘遮挡输入框的问题，因为使用了分类并且在 <code class="highlighter-rouge">IQKeyboardManager</code> 的 <code class="highlighter-rouge">+ load </code> 方法中激活了框架的使用，所以达到了零行代码解决这一问题的效果。</p>

<p>虽然 <code class="highlighter-rouge">IQKeyboardManager</code> 很好地解决了这一问题、为我们带来了良好的体验。不过，由于其涉及 UI 层级；并且需要考虑非常多的边界以及特殊条件，框架的代码不是很容易阅读，但是这不妨碍 <code class="highlighter-rouge">IQKeyboardManager</code> 成为非常优秀的开源项目。</p>

<blockquote>
  <p>关注仓库，及时获得更新：<a href="https://github.com/draveness/iOS-Source-Code-Analyze">iOS-Source-Code-Analyze</a></p>

</blockquote>



        </section>

        <footer class="post-footer">

            <!-- Everything inside the #author tags pulls data from the author -->
            <!-- #author-->
            
                
                    
                        <figure class="author-image">
                            <a class="img" href="/reprinted/author/Draveness" style="background-image: url(/reprinted/assets/images/draven.png)"><span class="hidden">Draveness's Picture</span></a>
                        </figure>
                    

                    <section class="author">
                        <h4><a href="/reprinted/author/Draveness">Draveness</a></h4>

                        
                            <p>Read <a href="/reprinted/author/Draveness">more posts</a> by this author.</p>
                        
                        <div class="author-meta">
                            <span class="author-location icon-location"> Beijing, China</span>
                            <span class="author-link icon-link"><a href="https://draveness.me/index"> draveness.me/index</a></span>
                        </div>
                    </section>

                    <!-- /author  -->

                    <section class="share">
                        <h4>Share this post</h4>
                        <a class="icon-twitter" href="http://twitter.com/share?text=『零行代码』解决键盘遮挡问题（iOS）&amp;url=keyboard"
                            onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
                            <span class="hidden">Twitter</span>
                        </a>
                        <a class="icon-facebook" href="https://www.facebook.com/sharer/sharer.php?u=keyboard"
                            onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
                            <span class="hidden">Facebook</span>
                        </a>
                        <a class="icon-google-plus" href="https://plus.google.com/share?url=keyboard"
                           onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
                            <span class="hidden">Google+</span>
                        </a>
                    </section>
                
            
            <!-- Add Disqus Comments -->
            

        </footer>

    </article>

</main>
<aside class="read-next">

    <!-- [[! next_post ]] -->
    
        <a class="read-next-story " style="background-image: url(/reprinted/assets/images/cover2.jpg)" href="/reprinted/defer">
            <section class="post">
                <h2>如何在 Objective-C 的环境下实现 defer</h2>
                <p>> 转自：[如何在 Objective-C 的环境下实现 defer](https://draveness.me/defer) > 关注仓库，及时获得更新：[iOS-Source-Code-Analyze](https://github.com/draveness/iOS-Source-Code-Analyze) > 这篇文章会对 [libextobjc](https://github.com/jspahrsummers/libextobjc) 中的一小部分代码进行分析，也是**如何扩展 Objective-C 语言**系列文章的第一篇，笔者会从 libextobjc 中选择一些黑魔法进行介绍。...</p>
            </section>
        </a>
    
    <!-- [[! /next_post ]] -->
    <!-- [[! prev_post ]] -->
    
        <a class="read-next-story prev " style="background-image: url(/reprinted/assets/images/cover2.jpg)" href="/reprinted/ao">
            <section class="post">
                <h2>关联对象 AssociatedObject 完全解析</h2>
                <p>转自：关联对象 AssociatedObject 完全解析 关注仓库，及时获得更新：iOS-Source-Code-Analyze 我们在 iOS 开发中经常需要使用分类（Category），为已经存在的类添加属性的需求，但是使用 @property 并不能在分类中正确创建实例变量和存取方法。 不过，通过 Objective-C 运行时中的关联对象，也就是 Associated Object，我们可以实现上述需求。 写在前面...</p>
            </section>
        </a>
    
    <!-- [[! /prev_post ]] -->
</aside>

<!-- /post -->


        <!-- The tiny footer at the very bottom -->
        <footer class="site-footer clearfix">
          <section class="copyright"><a href="/reprinted/"></a> &copy; 2018</section>
          <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> using <a href="https://github.com/jekyller/jasper">Jasper</a></section>
        </footer>
    </div>
    <!-- highlight.js -->
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <!-- jQuery needs to come before `` so that jQuery can be used in code injection -->
    <script type="text/javascript" src="//code.jquery.com/jquery-1.12.0.min.js"></script>
    <!-- Ghost outputs important scripts and data with this tag -->
    <!--  -->
    <!-- Add Google Analytics  -->
        <!-- Google Analytics Tracking code -->
     <script>
	    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	    ga('create', 'UA-69281367-1', 'auto');
	    ga('send', 'pageview');

     </script>
    <!-- Fitvids makes video embeds responsive and awesome -->
    <script type="text/javascript" src="/reprinted/assets/js/jquery.fitvids.js"></script>
    <!-- The main JavaScript file for Casper -->
    <script type="text/javascript" src="/reprinted/assets/js/index.js"></script>

</body>
</html>
