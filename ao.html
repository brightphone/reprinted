<!DOCTYPE html>
<html>
<head>
    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Page Meta -->
    <title>关联对象 AssociatedObject 完全解析</title>
    <meta name="description" content="" />

    <!-- Mobile Meta -->
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- Brand icon -->
    <link rel="shortcut icon" href="/reprinted/assets/images/favicon.ico" >

    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/reprinted/assets/css/screen.css" />
    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400" />
    <link rel="stylesheet" type="text/css" href="/reprinted/assets/css/syntax.css" />

    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/styles/default.min.css">
    <style>.hljs { background: none; }</style>

    <!-- Ghost outputs important style and meta data with this tag -->
        <link rel="canonical" href="/reprinted//ao" />
    <meta name="referrer" content="origin" />
    <link rel="next" href="/reprinted/page2/" />

    <meta property="og:site_name" content="" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="关联对象 AssociatedObject 完全解析" />
    <meta property="og:description" content="" />
    <meta property="og:url" content="/reprinted//ao" />
    <meta property="og:image" content="/reprinted/assets/images/cover2.jpg" />

    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="关联对象 AssociatedObject 完全解析" />
    <meta name="twitter:description" content="" />
    <meta name="twitter:url" content="/reprinted//ao" />
    <meta name="twitter:image:src" content="/reprinted/assets/images/cover2.jpg" />

    <script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "Website",
    "publisher": "",
    "name": "关联对象 AssociatedObject 完全解析",
    "url": "/reprinted//ao",
    "image": "/reprinted/assets/images/cover2.jpg",
    "description": ""
}
    </script>

    <meta name="generator" content="Jekyll 3.0.0" />
    <link rel="alternate" type="application/rss+xml" title="" href="/reprinted/feed.xml" />


</head>
<body class="home-template nav-closed">

    <!-- The blog navigation links -->
    <div class="nav">
    <h3 class="nav-title">Menu</h3>
    <a href="#" class="nav-close">
        <span class="hidden">Close</span>
    </a>
    <ul>
        <li class="nav-home " role="presentation"><a href="/reprinted/">Home</a></li>
        <li class="nav-about " role="presentation"><a href="/reprinted/about">About</a></li>
        <li class="nav-ios " role="presentation"><a href="/reprinted/tag/ios">iOS</a></li>
        <li class="nav-objective-c " role="presentation"><a href="/reprinted/tag/objective-c">objective-c</a></li>
        <li class="nav-swift " role="presentation"><a href="/reprinted/tag/swift">Swift</a></li>
        <li class="nav-others " role="presentation"><a href="/reprinted/tag/others">others</a></li>
    </ul>
    <a class="subscribe-button icon-feed" href="/reprinted/feed.xml">Subscribe</a>
</div>
<span class="nav-cover"></span>


    <div class="site-wrapper">

        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- default -->

<!-- The comment above "< default" means - insert everything in this file into -->
    <!-- the [body] of the default.hbs template, which contains our header/footer. -->

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<header class="main-header post-head " style="background-image: url(/reprinted/assets/images/cover2.jpg) ">
    <nav class="main-nav  overlay  clearfix">
        <a class="blog-logo" href="/reprinted/"><img src="/reprinted/assets/images/ghost.png" alt="Blog Logo" /></a>
        
            <a class="menu-button icon-menu" href="#"><span class="word">Menu</span></a>
        
    </nav>
</header>

<main class="content" role="main">

    <article class="post tag-fiction">

        <header class="post-header">
            <h1 class="post-title">关联对象 AssociatedObject 完全解析</h1>
            <section class="post-meta">
            <!-- <a href='/reprinted/'></a> -->

            
                
                    <a href='/reprinted/author/Draveness'>Draveness</a>
                
            
            <time class="post-date" datetime="2016-06-08">08 Jun 2016</time>
                <!-- [[tags prefix=" on "]] -->
                
                on
                
                    
                       <a href='/reprinted/tag/iOS'>iOS</a>,
                    
                
                    
                       <a href='/reprinted/tag/runtime'>runtime</a>
                    
                
                
            </section>
        </header>

        <section class="post-content">

            <blockquote>
  <p>转自：<a href="https://draveness.me/ao">关联对象 AssociatedObject 完全解析</a></p>
</blockquote>

<blockquote>
  <p>关注仓库，及时获得更新：<a href="https://github.com/draveness/iOS-Source-Code-Analyze">iOS-Source-Code-Analyze</a></p>

</blockquote>

<p>我们在 iOS 开发中经常需要使用分类（Category），为已经存在的类添加属性的需求，但是使用 <code class="highlighter-rouge"><span class="k">@property</span></code> 并不能在分类中<strong>正确</strong>创建实例变量和存取方法。</p>

<p>不过，通过 Objective-C 运行时中的关联对象，也就是 Associated Object，我们可以实现上述需求。</p>

<h2 id="写在前面">写在前面</h2>

<p>这篇文章包含了两方面的内容：</p>

<ul>
  <li><a href="#关联对象的应用">使用关联对象为已经存在的类中添加属性</a></li>
  <li><a href="#关联对象的实现">关联对象在底层 Objective-C 中的实现</a></li>
</ul>

<blockquote>
  <p>注：如果你刚刚入门 iOS 开发，笔者相信了解第一部分的内容会对你的日常开发中有所帮助，不过第二部分的内容可能有些难以理解。</p>

  <p>如果你对关联对象的使用非常熟悉，可以直接跳过第一部分的内容，从<a href="#关联对象的实现">这里</a>开始深入了解其底层实现。</p>
</blockquote>

<h2 id="关联对象的应用">关联对象的应用</h2>

<p>关于关联对象的使用相信已经成为了一个老生常谈的问题了，不过为了保证这篇文章的完整性，笔者还是会在这里为各位介绍这部分的内容的。</p>

<h3 id="分类中的-property">分类中的 @property</h3>

<p><code class="highlighter-rouge"><span class="k">@property</span></code> 可以说是一个 Objective-C 编程中的“宏”，它有<a href="https://zh.wikipedia.org/zh/元编程">元编程</a>的思想。</p>

<pre><code class="language-objectivec">@interface DKObject : NSObject

@property (nonatomic, strong) NSString *property;

@end
</code></pre>

<p>在使用上述代码时会做三件事：</p>

<ul>
  <li>生成实例变量 <code class="highlighter-rouge">_property</code></li>
  <li>生成 <code class="highlighter-rouge">getter</code> 方法 <code class="highlighter-rouge">- property</code></li>
  <li>生成 <code class="highlighter-rouge">setter</code> 方法 <code class="highlighter-rouge">- setProperty:</code></li>
</ul>

<pre><code class="language-objectivec">@implementation DKObject {
    NSString *_property;
}

- (NSString *)property {
    return _property;
}

- (void)setProperty:(NSString *)property {
    _property = property;
}

@end
</code></pre>

<p>这些代码都是编译器为我们生成的，虽然你看不到它，但是它确实在这里，我们既然可以在类中使用 <code class="highlighter-rouge"><span class="k">@property</span></code> 生成一个属性，那么为什么在分类中不可以呢？</p>

<p>我们来做一个小实验：创建一个 <code class="highlighter-rouge">DKObject</code> 的分类 <code class="highlighter-rouge">Category</code>，并添加一个属性 <code class="highlighter-rouge">categoryProperty</code>：</p>

<pre><code class="language-objectivec">@interface DKObject (Category)

@property (nonatomic, strong) NSString *categoryProperty;

@end
</code></pre>

<p>看起来还是很不错的，不过 Build 一下这个 Demo，会发现有这么一个警告：</p>

<p><img src="https://img.draveness.me/2016-06-08-objc-ao-warning-category-property.png-1000width" alt="objc-ao-warning-category-property" /></p>

<p>在这里的警告告诉我们 <code class="highlighter-rouge">categoryProperty</code> 属性的存取方法需要自己手动去实现，或者使用 <code class="highlighter-rouge">@dynamic</code> 在运行时实现这些方法。</p>

<p>换句话说，分类中的 <code class="highlighter-rouge"><span class="k">@property</span></code> 并没有为我们生成实例变量以及存取方法，而需要我们手动实现。</p>

<h3 id="使用关联对象">使用关联对象</h3>

<p>Q：我们为什么要使用关联对象？</p>

<p>A：因为在分类中 <code class="highlighter-rouge"><span class="k">@property</span></code> 并不会自动生成实例变量以及存取方法，所以<strong>一般使用关联对象为已经存在的类添加『属性』</strong>。</p>

<p>上一小节的内容已经给了我们需要使用关联对象的理由。在这里，我们会介绍 ObjC 运行时为我们提供的与关联对象有关的 API，并在分类中实现一个<strong>伪属性</strong>：</p>

<pre><code class="language-objectivec">#import "DKObject+Category.h"
#import &lt;objc/runtime.h&gt;

@implementation DKObject (Category)

- (NSString *)categoryProperty {
    return objc_getAssociatedObject(self, _cmd);
}

- (void)setCategoryProperty:(NSString *)categoryProperty {
    objc_setAssociatedObject(self, @selector(categoryProperty), categoryProperty, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}

@end
</code></pre>

<blockquote>
  <p>这里的 <code class="highlighter-rouge">_cmd</code> 代指当前方法的选择子，也就是 <code class="highlighter-rouge">@selector(categoryProperty)</code>。</p>
</blockquote>

<p>我们使用了两个方法 <code class="highlighter-rouge">objc_getAssociatedObject</code> 以及 <code class="highlighter-rouge">objc_setAssociatedObject</code> 来模拟『属性』的存取方法，而使用关联对象模拟实例变量。</p>

<p>在这里有必要解释两个问题：</p>

<ol>
  <li>为什么向方法中传入 <code class="highlighter-rouge">@selector(categoryProperty)</code>？</li>
  <li><code class="highlighter-rouge">OBJC_ASSOCIATION_RETAIN_NONATOMIC</code> 是干什么的？</li>
</ol>

<p>关于第一个问题，我们需要看一下这两个方法的原型：</p>

<pre><code class="language-objectivec">id objc_getAssociatedObject(id object, const void *key);
void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy);
</code></pre>

<p><code class="highlighter-rouge">@selector(categoryProperty)</code> 也就是参数中的 <code class="highlighter-rouge">key</code>，其实可以使用静态指针 <code class="highlighter-rouge">static void *</code> 类型的参数来代替，不过在这里，笔者强烈推荐使用 <code class="highlighter-rouge">@selector(categoryProperty)</code> 作为 <code class="highlighter-rouge">key</code> 传入。因为这种方法省略了声明参数的代码，并且能很好地保证 <code class="highlighter-rouge">key</code> 的唯一性。</p>

<p><code class="highlighter-rouge">OBJC_ASSOCIATION_RETAIN_NONATOMIC</code> 又是什么呢？如果我们使用 <code class="highlighter-rouge">Command</code> 加左键查看它的定义：</p>

<pre><code class="language-objectivec">typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) {
    OBJC_ASSOCIATION_ASSIGN = 0,           /**&lt; Specifies a weak reference to the associated object. */
    OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, /**&lt; Specifies a strong reference to the associated object.
                                            *   The association is not made atomically. */
    OBJC_ASSOCIATION_COPY_NONATOMIC = 3,   /**&lt; Specifies that the associated object is copied.
                                            *   The association is not made atomically. */
    OBJC_ASSOCIATION_RETAIN = 01401,       /**&lt; Specifies a strong reference to the associated object.
                                            *   The association is made atomically. */
    OBJC_ASSOCIATION_COPY = 01403          /**&lt; Specifies that the associated object is copied.
                                            *   The association is made atomically. */
};
</code></pre>

<p>从这里的注释我们能看到很多东西，也就是说不同的 <code class="highlighter-rouge">objc_AssociationPolicy</code> 对应了不通的属性修饰符：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">objc_AssociationPolicy</th>
      <th style="text-align: center">modifier</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">OBJC_ASSOCIATION_ASSIGN</td>
      <td style="text-align: center">assign</td>
    </tr>
    <tr>
      <td style="text-align: left">OBJC_ASSOCIATION_RETAIN_NONATOMIC</td>
      <td style="text-align: center">nonatomic, strong</td>
    </tr>
    <tr>
      <td style="text-align: left">OBJC_ASSOCIATION_COPY_NONATOMIC</td>
      <td style="text-align: center">nonatomic, copy</td>
    </tr>
    <tr>
      <td style="text-align: left">OBJC_ASSOCIATION_RETAIN</td>
      <td style="text-align: center">atomic, strong</td>
    </tr>
    <tr>
      <td style="text-align: left">OBJC_ASSOCIATION_COPY</td>
      <td style="text-align: center">atomic, copy</td>
    </tr>
  </tbody>
</table>

<p>而我们在代码中实现的属性 <code class="highlighter-rouge">categoryProperty</code> 就相当于使用了 <code class="highlighter-rouge">nonatomic</code> 和 <code class="highlighter-rouge">strong</code> 修饰符。</p>

<blockquote>
  <p>关于属性修饰符的区别，并不是这篇文章的主要内容，如果你需要了解它们的区别，<a href="https://google.com">Google</a> 是一个很好的选择。</p>
</blockquote>

<p>到这里，我们已经完成了对关联对象应用的介绍，再来回顾一下小节的内容。</p>

<p>@property` 其实有元编程的思想，它能够为我们自动生成<strong>实例变量以及存取方法</strong>，而这三者构成了属性这个类似于语法糖的概念，为我们提供了更便利的点语法来访问属性：</p>

<pre><code class="language-objectivec">self.property &lt;=&gt; [self property]
self.property = value &lt;=&gt; [self setProperty:value]
</code></pre>

<p>在分类中，因为类的实例变量的布局已经固定，使用 <code class="highlighter-rouge"><span class="k">@property</span></code> 已经<strong>无法向固定的布局中添加新的实例变量（这样做可能会覆盖子类的实例变量）</strong>，所以我们需要<strong>使用关联对象以及两个方法来模拟构成属性的三个要素</strong>。</p>

<blockquote>
  <p>如果你是一个 iOS 开发方面的新手，我相信这篇文章的前半部分对已经足够使用了，不过，如果你还对关联对象的实现非常感兴趣，也可以尝试阅读下面的内容。</p>
</blockquote>

<h2 id="关联对象的实现">关联对象的实现</h2>

<blockquote>
  <p>探索关联对象的实现一直是我想要做的一件事情，直到最近，我才有足够的时间来完成这篇文章，希望能够对各位读者有所帮助。</p>
</blockquote>

<p>这一部分会从三个 objc 运行时的方法为入口来对关联对象的实现一探究竟，其中两个方法是上一部分使用到的方法：</p>

<pre><code class="language-objectivec">void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy);
id objc_getAssociatedObject(id object, const void *key);
void objc_removeAssociatedObjects(id object);
</code></pre>

<p>三个方法的作用分别是：</p>

<ul>
  <li>以键值对形式添加关联对象</li>
  <li>根据 <code class="highlighter-rouge">key</code> 获取关联对象</li>
  <li>移除所有关联对象</li>
</ul>

<p>而接下来的内容自然就是围绕这三个方法进行的，我们会对它们的实现进行分析。</p>

<h3 id="objc_setassociatedobject">objc_setAssociatedObject</h3>

<p>首先是 <code class="highlighter-rouge">objc_setAssociatedObject</code> 方法，这个方法的调用栈并不复杂：</p>

<pre><code class="language-objectivec">void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)
└── void objc_setAssociatedObject_non_gc(id object, const void *key, id value, objc_AssociationPolicy policy)
    └── void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy)
</code></pre>

<p>调用栈中的 <code class="highlighter-rouge">_object_set_associative_reference</code> 方法实际完成了设置关联对象的任务：</p>

<pre><code class="language-objectivec">void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) {
    ObjcAssociation old_association(0, nil);
    id new_value = value ? acquireValue(value, policy) : nil;
    {
        AssociationsManager manager;
        AssociationsHashMap &amp;associations(manager.associations());
        ObjectAssociationMap *refs = i-&gt;second;
        ...
    }
    if (old_association.hasValue()) ReleaseValue()(old_association);
}
</code></pre>

<blockquote>
  <p>在这里的实现省略了大多的实现代码，而且忽略了很多逻辑上的顺序，不过不要在意这里的代码能否执行。</p>
</blockquote>

<p>我们需要注意其中的几个类和数据结构，因为在具体分析这个方法的实现之前，我们需要了解其中它们的作用：</p>

<ul>
  <li><code class="highlighter-rouge">AssociationsManager</code></li>
  <li><code class="highlighter-rouge">AssociationsHashMap</code></li>
  <li><code class="highlighter-rouge">ObjcAssociationMap</code></li>
  <li><code class="highlighter-rouge">ObjcAssociation</code></li>
</ul>

<h4 id="associationsmanager">AssociationsManager</h4>

<p><code class="highlighter-rouge">AssociationsManager</code> 在源代码中的定义是这样的：</p>

<pre><code class="language-objectivec">class AssociationsManager {
    static spinlock_t _lock;
    static AssociationsHashMap *_map;
public:
    AssociationsManager()   { _lock.lock(); }
    ~AssociationsManager()  { _lock.unlock(); }

    AssociationsHashMap &amp;associations() {
        if (_map == NULL)
            _map = new AssociationsHashMap();
        return *_map;
    }
};

spinlock_t AssociationsManager::_lock;
AssociationsHashMap *AssociationsManager::_map = NULL;
</code></pre>

<p>它维护了 <code class="highlighter-rouge">spinlock_t</code> 和 <code class="highlighter-rouge">AssociationsHashMap</code> 的单例，初始化它的时候会调用 <code class="highlighter-rouge">lock.lock()</code> 方法，在析构时会调用 <code class="highlighter-rouge">lock.unlock()</code>，而 <code class="highlighter-rouge">associations</code> 方法用于取得一个全局的 <code class="highlighter-rouge">AssociationsHashMap</code> 单例。</p>

<p>也就是说 <code class="highlighter-rouge">AssociationsManager</code> 通过持有一个<a href="https://en.wikipedia.org/wiki/Spinlock">自旋锁</a> <code class="highlighter-rouge">spinlock_t</code> 保证对 <code class="highlighter-rouge">AssociationsHashMap</code> 的操作是线程安全的，即<strong>每次只会有一个线程对 AssociationsHashMap 进行操作</strong>。</p>

<h4 id="如何存储-objcassociation">如何存储 ObjcAssociation</h4>

<p><code class="highlighter-rouge">ObjcAssociation</code> 就是真正的关联对象的类，上面的所有数据结构只是为了更好的存储它。</p>

<p>首先，<code class="highlighter-rouge">AssociationsHashMap</code> 用与保存从对象的 <code class="highlighter-rouge">disguised_ptr_t</code> 到 <code class="highlighter-rouge">ObjectAssociationMap</code> 的映射：</p>

<pre><code class="language-objectivec">class AssociationsHashMap : public unordered_map&lt;disguised_ptr_t, ObjectAssociationMap *, DisguisedPointerHash, DisguisedPointerEqual, AssociationsHashMapAllocator&gt; {
public:
    void *operator new(size_t n) { return ::malloc(n); }
    void operator delete(void *ptr) { ::free(ptr); }
};
</code></pre>

<p>而 <code class="highlighter-rouge">ObjectAssociationMap</code> 则保存了从 <code class="highlighter-rouge">key</code> 到关联对象 <code class="highlighter-rouge">ObjcAssociation</code> 的映射，<strong>这个数据结构保存了当前对象对应的所有关联对象</strong>：</p>

<pre><code class="language-objectivec">class ObjectAssociationMap : public std::map&lt;void *, ObjcAssociation, ObjectPointerLess, ObjectAssociationMapAllocator&gt; {
public:
   void *operator new(size_t n) { return ::malloc(n); }
   void operator delete(void *ptr) { ::free(ptr); }
};
</code></pre>

<p>最关键的 <code class="highlighter-rouge">ObjcAssociation</code> 包含了 <code class="highlighter-rouge">policy</code> 以及 <code class="highlighter-rouge">value</code>：</p>

<pre><code class="language-objectivec">class ObjcAssociation {
    uintptr_t _policy;
    id _value;
public:
    ObjcAssociation(uintptr_t policy, id value) : _policy(policy), _value(value) {}
    ObjcAssociation() : _policy(0), _value(nil) {}

    uintptr_t policy() const { return _policy; }
    id value() const { return _value; }

    bool hasValue() { return _value != nil; }
};
</code></pre>

<p>举一个简单的例子来说明关联对象在内存中以什么形式存储的，以下面的代码为例：</p>

<pre><code class="language-objectivec">int main(int argc, const char * argv[]) {
    @autoreleasepool {

        NSObject *obj = [NSObject new];
        objc_setAssociatedObject(obj, @selector(hello), @"Hello", OBJC_ASSOCIATION_RETAIN_NONATOMIC);

    }
    return 0;
}
</code></pre>

<p>这里的关联对象 <code class="highlighter-rouge">ObjcAssociation(OBJC_ASSOCIATION_RETAIN_NONATOMIC, @"Hello")</code> 在内存中是这么存储的：</p>

<p><img src="https://img.draveness.me/2016-06-08-objc-ao-associateobjcect.png-1000width" alt="objc-ao-associateobjcect" /></p>

<hr />

<p>接下来我们可以重新回到对 <code class="highlighter-rouge">objc_setAssociatedObject</code> 方法的分析了。</p>

<p>在这里会将方法的执行分为两种情况：</p>

<ul>
  <li><code class="highlighter-rouge">new_value != nil</code> 设置/更新关联对象的值</li>
  <li><code class="highlighter-rouge">new_value == nil</code> 删除一个关联对象</li>
</ul>

<h4 id="new_value--nil">new_value != nil</h4>

<p>先来分析在 <code class="highlighter-rouge">new_value != nil</code> 的情况下，该方法的执行是什么样的：</p>

<pre><code class="language-objectivec">void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) {
    ObjcAssociation old_association(0, nil);
    id new_value = value ? acquireValue(value, policy) : nil;
    {
        AssociationsManager manager;
        AssociationsHashMap &amp;associations(manager.associations());
        disguised_ptr_t disguised_object = DISGUISE(object);

        AssociationsHashMap::iterator i = associations.find(disguised_object);
        if (i != associations.end()) {
            ObjectAssociationMap *refs = i-&gt;second;
            ObjectAssociationMap::iterator j = refs-&gt;find(key);
            if (j != refs-&gt;end()) {
                old_association = j-&gt;second;
                j-&gt;second = ObjcAssociation(policy, new_value);
            } else {
                (*refs)[key] = ObjcAssociation(policy, new_value);
            }
        } else {
            ObjectAssociationMap *refs = new ObjectAssociationMap;
            associations[disguised_object] = refs;
            (*refs)[key] = ObjcAssociation(policy, new_value);
            object-&gt;setHasAssociatedObjects();
        }
    }
    if (old_association.hasValue()) ReleaseValue()(old_association);
}
</code></pre>

<ol>
  <li>使用 <code class="highlighter-rouge">old_association(0, nil)</code> 创建一个临时的 <code class="highlighter-rouge">ObjcAssociation</code> 对象（用于持有原有的关联对象，方便在方法调用的最后释放值）</li>
  <li>
    <p>调用 <code class="highlighter-rouge">acquireValue</code> 对 <code class="highlighter-rouge">new_value</code> 进行 <code class="highlighter-rouge">retain</code> 或者 <code class="highlighter-rouge">copy</code></p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> static id acquireValue(id value, uintptr_t policy) {
     switch (policy &amp; 0xFF) {
     case OBJC_ASSOCIATION_SETTER_RETAIN:
         return ((id(*)(id, SEL))objc_msgSend)(value, SEL_retain);
     case OBJC_ASSOCIATION_SETTER_COPY:
         return ((id(*)(id, SEL))objc_msgSend)(value, SEL_copy);
     }
     return value;
 }
</code></pre></div>    </div>
  </li>
  <li>
    <p>初始化一个 <code class="highlighter-rouge">AssociationsManager</code>，并获取唯一的保存关联对象的哈希表 <code class="highlighter-rouge">AssociationsHashMap</code></p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> AssociationsManager manager;
 AssociationsHashMap &amp;associations(manager.associations());
</code></pre></div>    </div>
  </li>
  <li>先使用 <code class="highlighter-rouge">DISGUISE(object)</code> 作为 key 寻找对应的 <code class="highlighter-rouge">ObjectAssociationMap</code></li>
  <li>
    <p>如果没有找到，初始化一个 <code class="highlighter-rouge">ObjectAssociationMap</code>，再实例化 <code class="highlighter-rouge">ObjcAssociation</code> 对象添加到 Map 中，并调用 <code class="highlighter-rouge">setHasAssociatedObjects</code> 方法，表明当前对象含有关联对象</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> ObjectAssociationMap *refs = new ObjectAssociationMap;
 associations[disguised_object] = refs;
 (*refs)[key] = ObjcAssociation(policy, new_value);
 object-&gt;setHasAssociatedObjects();
</code></pre></div>    </div>
  </li>
  <li>
    <p>如果找到了对应的 <code class="highlighter-rouge">ObjectAssociationMap</code>，就要看 <code class="highlighter-rouge">key</code> 是否存在了，由此来决定是更新原有的关联对象，还是增加一个</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> ObjectAssociationMap *refs = i-&gt;second;
 ObjectAssociationMap::iterator j = refs-&gt;find(key);
 if (j != refs-&gt;end()) {
     old_association = j-&gt;second;
     j-&gt;second = ObjcAssociation(policy, new_value);
 } else {
     (*refs)[key] = ObjcAssociation(policy, new_value);
 }
</code></pre></div>    </div>
  </li>
  <li>
    <p>最后的最后，如果原来的关联对象有值的话，会调用 <code class="highlighter-rouge">ReleaseValue()</code> 释放关联对象的值</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> struct ReleaseValue {
     void operator() (ObjcAssociation &amp;association) {
         releaseValue(association.value(), association.policy());
     }
 };

 static void releaseValue(id value, uintptr_t policy) {
     if (policy &amp; OBJC_ASSOCIATION_SETTER_RETAIN) {
         ((id(*)(id, SEL))objc_msgSend)(value, SEL_release);
     }
 }
</code></pre></div>    </div>
  </li>
</ol>

<p>到这里，该条件下的方法实现就结束了。</p>

<h4 id="new_value--nil-1">new_value == nil</h4>

<p>如果 <code class="highlighter-rouge">new_value == nil</code>，就说明我们要删除对应 <code class="highlighter-rouge">key</code> 的关联对象，实现如下：</p>

<pre><code class="language-objectivec">void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) {
    ObjcAssociation old_association(0, nil);
    id new_value = value ? acquireValue(value, policy) : nil;
    {
        AssociationsManager manager;
        AssociationsHashMap &amp;associations(manager.associations());
        disguised_ptr_t disguised_object = DISGUISE(object);

        AssociationsHashMap::iterator i = associations.find(disguised_object);
        if (i !=  associations.end()) {
            ObjectAssociationMap *refs = i-&gt;second;
            ObjectAssociationMap::iterator j = refs-&gt;find(key);
            if (j != refs-&gt;end()) {
                old_association = j-&gt;second;
                refs-&gt;erase(j);
            }
        }
    }
    if (old_association.hasValue()) ReleaseValue()(old_association);
}
</code></pre>

<p>这种情况下方法的实现与前面的唯一区别就是，我们会调用 <code class="highlighter-rouge">erase</code> 方法，擦除 <code class="highlighter-rouge">ObjectAssociationMap</code> 中 <code class="highlighter-rouge">key</code> 对应的节点。</p>

<h4 id="sethasassociatedobjects">setHasAssociatedObjects()</h4>

<p>其实上面的两种情况已经将 <code class="highlighter-rouge">objc_setAssociatedObject</code> 方法的实现分析得很透彻了，不过，这里还有一个小问题来等待我们解决，<code class="highlighter-rouge">setHasAssociatedObjects()</code> 方法的作用是什么？</p>

<pre><code class="language-objectivec">inline void objc_object::setHasAssociatedObjects() {
    if (isTaggedPointer()) return;

 retry:
    isa_t oldisa = LoadExclusive(&amp;isa.bits);
    isa_t newisa = oldisa;
    if (!newisa.indexed) return;
    if (newisa.has_assoc) return;
    newisa.has_assoc = true;
    if (!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)) goto retry;
}
</code></pre>

<p>它会将 <code class="highlighter-rouge">isa</code> 结构体中的标记位 <code class="highlighter-rouge">has_assoc</code> 标记为 <code class="highlighter-rouge">true</code>，也就是表示当前对象有关联对象，在这里我还想祭出这张图来介绍 <code class="highlighter-rouge">isa</code> 中的各个标记位都是干什么的。</p>

<p><img src="https://img.draveness.me/2016-06-08-objc-ao-isa-struct.png-1000width" alt="objc-ao-isa-struct" /></p>

<blockquote>
  <p>如果想要了解关于 isa 的知识，可以阅读<a href="https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/objc/从%20NSObject%20的初始化了解%20isa.md">从 NSObject 的初始化了解 isa</a></p>
</blockquote>

<h3 id="objc_getassociatedobject">objc_getAssociatedObject</h3>

<p>我们既然已经对 <code class="highlighter-rouge">objc_setAssociatedObject</code> 的实现已经比较熟悉了，相信对于 <code class="highlighter-rouge">objc_getAssociatedObject</code> 的理解也会更加容易。</p>

<p>方法的调用栈和 <code class="highlighter-rouge">objc_setAssociatedObject</code> 非常相似：</p>

<pre><code class="language-objectivec">id objc_getAssociatedObject(id object, const void *key)
└── id objc_getAssociatedObject_non_gc(id object, const void *key);
    └── id _object_get_associative_reference(id object, void *key)
</code></pre>

<p>而 <code class="highlighter-rouge">_object_get_associative_reference</code> 相比于前面方法的实现更加简单。</p>

<pre><code class="language-objectivec">id _object_get_associative_reference(id object, void *key) {
    id value = nil;
    uintptr_t policy = OBJC_ASSOCIATION_ASSIGN;
    {
        AssociationsManager manager;
        AssociationsHashMap &amp;associations(manager.associations());
        disguised_ptr_t disguised_object = DISGUISE(object);
        AssociationsHashMap::iterator i = associations.find(disguised_object);
        if (i != associations.end()) {
            ObjectAssociationMap *refs = i-&gt;second;
            ObjectAssociationMap::iterator j = refs-&gt;find(key);
            if (j != refs-&gt;end()) {
                ObjcAssociation &amp;entry = j-&gt;second;
                value = entry.value();
                policy = entry.policy();
                if (policy &amp; OBJC_ASSOCIATION_GETTER_RETAIN) ((id(*)(id, SEL))objc_msgSend)(value, SEL_retain);
            }
        }
    }
    if (value &amp;&amp; (policy &amp; OBJC_ASSOCIATION_GETTER_AUTORELEASE)) {
        ((id(*)(id, SEL))objc_msgSend)(value, SEL_autorelease);
    }
    return value;
}
</code></pre>

<p>代码中寻找关联对象的逻辑和 <code class="highlighter-rouge">objc_setAssociatedObject</code> 差不多：</p>

<ol>
  <li>获取静态变量 <code class="highlighter-rouge">AssociationsHashMap</code></li>
  <li>以 <code class="highlighter-rouge">DISGUISE(object)</code> 为 key 查找 <code class="highlighter-rouge">AssociationsHashMap</code></li>
  <li>以 <code class="highlighter-rouge">void *key</code> 为 key 查找 <code class="highlighter-rouge">ObjcAssociation</code></li>
  <li>
    <p>根据 <code class="highlighter-rouge">policy</code> 调用相应的方法</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> if (policy &amp; OBJC_ASSOCIATION_GETTER_RETAIN) ((id(*)(id, SEL))objc_msgSend)(value, SEL_retain);

 if (value &amp;&amp; (policy &amp; OBJC_ASSOCIATION_GETTER_AUTORELEASE)) {
     ((id(*)(id, SEL))objc_msgSend)(value, SEL_autorelease);
 }
</code></pre></div>    </div>
  </li>
  <li>返回关联对象 <code class="highlighter-rouge">ObjcAssociation</code> 的值</li>
</ol>

<h3 id="objc_removeassociatedobjects">objc_removeAssociatedObjects</h3>

<p>关于最后的 <code class="highlighter-rouge">objc_removeAssociatedObjects</code> 方法，其实现也相对简单，这是方法的调用栈：</p>

<pre><code class="language-objectivec">void objc_removeAssociatedObjects(id object)
└── void _object_remove_assocations(id object)
</code></pre>

<p>这是简化版本的 <code class="highlighter-rouge">objc_removeAssociatedObjects</code> 方法实现：</p>

<pre><code class="language-objectivec">void objc_removeAssociatedObjects(id object) {
    if (object &amp;&amp; object-&gt;hasAssociatedObjects()) {
        _object_remove_assocations(object);
    }
}
</code></pre>

<p>为了加速移除对象的关联对象的速度，我们会通过标记位 <code class="highlighter-rouge">has_assoc</code> 来避免不必要的方法调用，在确认了对象和关联对象的存在之后，才会调用 <code class="highlighter-rouge">_object_remove_assocations</code> 方法移除对象上所有的关联对象：</p>

<pre><code class="language-objectivec">void _object_remove_assocations(id object) {
    vector&lt; ObjcAssociation,ObjcAllocator&lt;ObjcAssociation&gt; &gt; elements;
    {
        AssociationsManager manager;
        AssociationsHashMap &amp;associations(manager.associations());
        if (associations.size() == 0) return;
        disguised_ptr_t disguised_object = DISGUISE(object);
        AssociationsHashMap::iterator i = associations.find(disguised_object);
        if (i != associations.end()) {
            ObjectAssociationMap *refs = i-&gt;second;
            for (ObjectAssociationMap::iterator j = refs-&gt;begin(), end = refs-&gt;end(); j != end; ++j) {
                elements.push_back(j-&gt;second);
            }
            delete refs;
            associations.erase(i);
        }
    }
    for_each(elements.begin(), elements.end(), ReleaseValue());
}
</code></pre>

<p>方法会将对象包含的所有关联对象加入到一个 <code class="highlighter-rouge">vector</code> 中，然后对所有的 <code class="highlighter-rouge">ObjcAssociation</code> 对象调用 <code class="highlighter-rouge">ReleaseValue()</code> 方法，释放不再被需要的值。</p>

<h2 id="小结">小结</h2>

<h3 id="关于应用">关于应用</h3>

<p>本来在这个系列的文章中并不会涉及关联对象这个话题，不过，有人问过我这么一个问题：在分类中到底能否实现属性？其实在回答这个问题之前，首先要知道到底属性是什么？而属性的概念决定了这个问题的答案。</p>

<ul>
  <li>如果你把属性理解为<strong>通过方法访问的实例变量</strong>，我相信这个问题的答案是不能，<strong>因为分类不能为类增加额外的实例变量</strong>。</li>
  <li>不过如果属性只是一个<strong>存取方法以及存储值的容器的集合</strong>，那么分类是可以实现属性的。</li>
</ul>

<blockquote>
  <p><strong>分类中对属性的实现其实只是实现了一个看起来像属性的接口而已</strong>。</p>
</blockquote>

<h3 id="关于实现">关于实现</h3>

<p>关联对象又是如何实现并且管理的呢：</p>

<ul>
  <li>关联对象其实就是 <code class="highlighter-rouge">ObjcAssociation</code> 对象</li>
  <li>关联对象由 <code class="highlighter-rouge">AssociationsManager</code> 管理并在  <code class="highlighter-rouge">AssociationsHashMap</code> 存储</li>
  <li>对象的指针以及其对应 <code class="highlighter-rouge">ObjectAssociationMap</code> 以键值对的形式存储在 <code class="highlighter-rouge">AssociationsHashMap</code> 中</li>
  <li><code class="highlighter-rouge">ObjectAssociationMap</code> 则是用于存储关联对象的数据结构</li>
  <li>每一个对象都有一个标记位 <code class="highlighter-rouge">has_assoc</code> 指示对象是否含有关联对象</li>
</ul>

<blockquote>
  <p>关注仓库，及时获得更新：<a href="https://github.com/draveness/iOS-Source-Code-Analyze">iOS-Source-Code-Analyze</a></p>

</blockquote>



        </section>

        <footer class="post-footer">

            <!-- Everything inside the #author tags pulls data from the author -->
            <!-- #author-->
            
                
                    
                        <figure class="author-image">
                            <a class="img" href="/reprinted/author/Draveness" style="background-image: url(/reprinted/assets/images/draven.png)"><span class="hidden">Draveness's Picture</span></a>
                        </figure>
                    

                    <section class="author">
                        <h4><a href="/reprinted/author/Draveness">Draveness</a></h4>

                        
                            <p>Read <a href="/reprinted/author/Draveness">more posts</a> by this author.</p>
                        
                        <div class="author-meta">
                            <span class="author-location icon-location"> Beijing, China</span>
                            <span class="author-link icon-link"><a href="https://draveness.me/index"> draveness.me/index</a></span>
                        </div>
                    </section>

                    <!-- /author  -->

                    <section class="share">
                        <h4>Share this post</h4>
                        <a class="icon-twitter" href="http://twitter.com/share?text=关联对象 AssociatedObject 完全解析&amp;url=ao"
                            onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
                            <span class="hidden">Twitter</span>
                        </a>
                        <a class="icon-facebook" href="https://www.facebook.com/sharer/sharer.php?u=ao"
                            onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
                            <span class="hidden">Facebook</span>
                        </a>
                        <a class="icon-google-plus" href="https://plus.google.com/share?url=ao"
                           onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
                            <span class="hidden">Google+</span>
                        </a>
                    </section>
                
            
            <!-- Add Disqus Comments -->
            

        </footer>

    </article>

</main>
<aside class="read-next">

    <!-- [[! next_post ]] -->
    
        <a class="read-next-story " style="background-image: url(/reprinted/assets/images/cover2.jpg)" href="/reprinted/keyboard">
            <section class="post">
                <h2>『零行代码』解决键盘遮挡问题（iOS）</h2>
                <p>> 转自：[『零行代码』解决键盘遮挡问题（iOS）](https://draveness.me/keyboard) > 关注仓库，及时获得更新：[iOS-Source-Code-Analyze](https://github.com/draveness/iOS-Source-Code-Analyze) > > 这篇文章会对 IQKeyboardManager 自动解决键盘遮挡问题的方法进行分析。 最近在项目中使用了 [IQKeyboardManager](https://github.com/hackiftekhar/IQKeyboardManager) 来解决 `UITextField` 被键盘遮挡的问题，这个框架的使用方法可以说精简到了极致，只需要将 `IQKeyboardManager`...</p>
            </section>
        </a>
    
    <!-- [[! /next_post ]] -->
    <!-- [[! prev_post ]] -->
    
        <a class="read-next-story prev " style="background-image: url(/reprinted/assets/images/cover2.jpg)" href="/reprinted/rr">
            <section class="post">
                <h2>黑箱中的 retain 和 release</h2>
                <p>转自：黑箱中的 retain 和 release 关注仓库，及时获得更新：iOS-Source-Code-Analyze 由于 Objective-C 中的内存管理是一个比较大的话题，所以会分为两篇文章来对内存管理中的一些机制进行剖析，一部分分析自动释放池以及 autorelease 方法，另一部分分析 retain、release 方法的实现以及自动引用计数。 自动释放池的前世今生 黑箱中的 retain...</p>
            </section>
        </a>
    
    <!-- [[! /prev_post ]] -->
</aside>

<!-- /post -->


        <!-- The tiny footer at the very bottom -->
        <footer class="site-footer clearfix">
          <section class="copyright"><a href="/reprinted/"></a> &copy; 2018</section>
          <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> using <a href="https://github.com/jekyller/jasper">Jasper</a></section>
        </footer>
    </div>
    <!-- highlight.js -->
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <!-- jQuery needs to come before `` so that jQuery can be used in code injection -->
    <script type="text/javascript" src="//code.jquery.com/jquery-1.12.0.min.js"></script>
    <!-- Ghost outputs important scripts and data with this tag -->
    <!--  -->
    <!-- Add Google Analytics  -->
        <!-- Google Analytics Tracking code -->
     <script>
	    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	    ga('create', 'UA-69281367-1', 'auto');
	    ga('send', 'pageview');

     </script>
    <!-- Fitvids makes video embeds responsive and awesome -->
    <script type="text/javascript" src="/reprinted/assets/js/jquery.fitvids.js"></script>
    <!-- The main JavaScript file for Casper -->
    <script type="text/javascript" src="/reprinted/assets/js/index.js"></script>

</body>
</html>
